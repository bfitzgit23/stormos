#!/usr/bin/env python3

import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

import subprocess
import importlib
import sys
import logging
import datetime
import shutil
import os
import mimetypes
import time
import re
import threading
import signal
import math
import atexit
import select
import fcntl
import multiprocessing
import tempfile
#import psutil
from datetime import datetime, timedelta
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Gdk, GLib, GdkPixbuf


logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Cache for detected package manager
cached_package_manager = None

def detect_package_manager():
    global cached_package_manager
    if cached_package_manager:
        return cached_package_manager

    package_managers = {
        'apt': 'debian-based',
        'pacman': 'arch-based',
        'dnf': 'fedora',
        'zypper': 'opensuse',
        'eopkg': 'solus',
        'emerge': 'gentoo'
    }
    for pm in package_managers:
        if shutil.which(pm):
            logging.info(f"Detected package manager: {pm}")
            cached_package_manager = pm
            return pm
    logging.error("Unable to detect package manager. Unsupported distribution.")
    return None

#---------------------------------Mini--Code--------------------------------------------------

import subprocess
import logging
import shutil
import sys
import os

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def detect_os():
    os_info = {}
    try:
        with open("/etc/os-release") as f:
            for line in f:
                if "=" in line:
                    key, value = line.strip().split("=", 1)
                    os_info[key] = value.strip('"')
    except FileNotFoundError:
        logging.error("Unable to read /etc/os-release. Unsupported distribution.")
    return os_info

def detect_package_manager():
    package_managers = {
        'apt': 'debian-based',
        'pacman': 'arch-based',
        'dnf': 'fedora',
        'zypper': 'opensuse',
        'eopkg': 'solus',
        'emerge': 'gentoo'
    }
    for pm in package_managers:
        if shutil.which(pm):
            logging.info(f"Detected package manager: {pm}")
            return pm
    logging.error("Unable to detect package manager. Unsupported distribution.")
    return None

def detect_pacman_db_warnings():
    try:
        process = subprocess.Popen(["pacman", "-Sy"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        stdout, stderr = process.communicate()
        logging.debug(f"pacman -Sy output: {stdout}")
        logging.debug(f"pacman -Sy error: {stderr}")
        if "database file for 'core' does not exist" in stderr or \
           "database file for 'extra' does not exist" in stderr or \
           "database file for 'multilib' does not exist" in stderr:
            logging.warning("Detected missing database files.")
            return True
        return False
    except subprocess.CalledProcessError as e:
        logging.error(f"Error checking pacman database: {e}")
        return False

def run_pacman_sy():
    try:
        subprocess.check_call(["sudo", "pacman", "-Sy", "--noconfirm"])
        logging.info("Executed `sudo pacman -Sy --noconfirm` successfully.")
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to execute `sudo pacman -Sy --noconfirm`. Error: {e}")
        sys.exit(1)

def ensure_arch_dependencies():
    package_manager = detect_package_manager()
    if package_manager != 'pacman':
        logging.info("Skipping pacman-specific steps as the package manager is not pacman.")
        return

    if detect_pacman_db_warnings():
        run_pacman_sy()

    try:
        subprocess.check_call(["pacman", "-Qi", "fakeroot"], stderr=subprocess.STDOUT, universal_newlines=True)
        subprocess.check_call(["pacman", "-Qi", "base-devel"], stderr=subprocess.STDOUT, universal_newlines=True)
        logging.info("fakeroot and base-devel are already installed.")
    except subprocess.CalledProcessError:
        logging.info("Installing fakeroot and base-devel...")
        try:
            run_pacman_sy()  # Ensure the database is updated before installing
            subprocess.check_call(["sudo", "pacman", "-S", "--noconfirm", "fakeroot", "base-devel"])
            logging.info("fakeroot and base-devel installed successfully.")
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to install fakeroot and base-devel. Error: {e}")
            sys.exit(1)

# Example usage:
os_info = detect_os()
logging.info(f"Detected OS: {os_info.get('PRETTY_NAME', 'Unknown')}")
logging.info(f"OS ID: {os_info.get('ID', 'Unknown')}")
logging.info(f"OS ID_LIKE: {os_info.get('ID_LIKE', 'Unknown')}")

ensure_arch_dependencies()




#------------------------------------Mini Code End-------------------------------------------


    



def get_distro():
    try:
        with open('/etc/os-release', 'r') as f:
            lines = f.readlines()
            distro_id = None
            distro_like = None
            for line in lines:
                if line.startswith('ID='):
                    distro_id = line.split('=')[1].strip().strip('"')
                    logging.info(f"Detected ID in /etc/os-release: {distro_id}")
                if line.startswith('ID_LIKE='):
                    distro_like = line.split('=')[1].strip().strip('"')
                    logging.info(f"Detected ID_LIKE in /etc/os-release: {distro_like}")
            if distro_id == 'pop':
                return 'ubuntu'
            if distro_id:
                return distro_id
            if distro_like:
                return distro_like
        logging.error("Could not find ID or ID_LIKE in /etc/os-release.")
    except Exception as e:
        logging.error(f"Exception while reading /etc/os-release: {e}")
    return detect_package_manager()

def detect_display_server():
    if 'WAYLAND_DISPLAY' in os.environ:
        logging.info("Using Wayland display server.")
        return 'wayland'
    elif 'DISPLAY' in os.environ:
        logging.info("Using Xorg display server.")
        return 'xorg'
    else:
        logging.error("Unable to detect the display server.")
        return 'unknown'

def is_pacman_db_missing():
    db_paths = [
        "/var/lib/pacman/sync/core.db",
        "/var/lib/pacman/sync/extra.db",
        "/var/lib/pacman/sync/multilib.db"
    ]



import subprocess
import logging
import sys

def handle_pacman_warnings(command):
    try:
        result = subprocess.run(command, check=True, capture_output=True, text=True)
        output = result.stdout + result.stderr
    except subprocess.CalledProcessError as e:
        output = e.stdout + e.stderr

    warnings = [
        "warning: database file for 'core' does not exist",
        "warning: database file for 'extra' does not exist",
        "warning: database file for 'multilib' does not exist"
    ]

    if any(warning in output for warning in warnings):
        logging.warning("Detected missing database files. Running database update.")
        try:
            subprocess.run(["sudo", "pacman", "-Sy", "--noconfirm"], check=True)
            logging.info("Database update completed successfully.")
            return True
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to update database: {e}")
            return False
    
    return True



import logging
import subprocess
import sys

def run_pacman_sy():
    try:
        logging.info("Running `sudo pacman -Sy` to refresh package databases...")
        subprocess.check_call(["sudo", "pacman", "-Sy"])
        logging.info("Executed `sudo pacman -Sy` successfully.")
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to execute `sudo pacman -Sy`. Error: {e}")
        sys.exit(1)

def ensure_arch_dependencies():
    try:
        output = subprocess.check_output(["sudo", "pacman", "-S", "--noconfirm", "fakeroot", "base-devel"], stderr=subprocess.STDOUT).decode('utf-8')
        if 'database file for' in output:
            logging.info("Detected missing database file warnings. Running `sudo pacman -Sy`...")
            run_pacman_sy()
            output = subprocess.check_output(["sudo", "pacman", "-S", "--noconfirm", "fakeroot", "base-devel"], stderr=subprocess.STDOUT).decode('utf-8')
            if 'database file for' in output:
                logging.error("Failed to update package database. Please check your pacman configuration.")
                sys.exit(1)
        logging.info("fakeroot and base-devel are installed.")
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to install fakeroot and base-devel. Error: {e}")
        sys.exit(1)
        return False



def ensure_v4l_utils_installed_arch():
    try:
        output = subprocess.check_output(["sudo", "pacman", "-S", "--noconfirm", "v4l-utils"], stderr=subprocess.STDOUT).decode('utf-8')
        if 'database file for' in output:
            logging.info("Detected missing database file warnings. Running `sudo pacman -Sy`...")
            run_pacman_sy()
            subprocess.check_call(["sudo", "pacman", "-S", "--noconfirm", "v4l-utils"])
        logging.info("v4l-utils is installed.")
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to install v4l-utils. Error: {e}")
        if "database file for" in str(e.output):
            logging.info("Detected database file issue. Running `sudo pacman -Sy` again...")
            run_pacman_sy()
            try:
                subprocess.check_call(["sudo", "pacman", "-S", "--noconfirm", "v4l-utils"])
            except subprocess.CalledProcessError as e2:
                logging.error(f"Failed to install v4l-utils after running `sudo pacman -Sy`. Error: {e2}")
                sys.exit(1)
        else:
            sys.exit(1)




def install_yay():
    try:
        subprocess.check_call(["yay", "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        logging.info("yay is already installed.")
    except FileNotFoundError:
        logging.info("yay is not installed. Attempting to install it through pacman...")
        try:
            subprocess.check_call(["sudo", "pacman", "-S", "--noconfirm", "yay"])
            logging.info("yay has been successfully installed through pacman.")
        except subprocess.CalledProcessError:
            logging.info("Failed to install yay through pacman. Attempting to install it from AUR...")
            try:
                subprocess.check_call(["sudo", "pacman", "-S", "--needed", "--noconfirm", "base-devel"])
                with tempfile.TemporaryDirectory() as temp_dir:
                    os.chdir(temp_dir)
                    subprocess.check_call(["git", "clone", "https://aur.archlinux.org/yay.git"])
                    os.chdir("yay")
                    subprocess.check_call(["makepkg", "-si", "--noconfirm"])
                logging.info("yay has been successfully installed from AUR.")
            except subprocess.CalledProcessError as e:
                logging.error(f"Failed to install yay. Error: {e}")
                logging.error("Please install yay manually and run the script again.")
                sys.exit(1)
    except subprocess.CalledProcessError:
        logging.info("An error occurred while checking yay version. Attempting to reinstall...")
        try:
            subprocess.check_call(["yay", "-S", "--noconfirm", "yay"])
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to reinstall yay. Error: {e}")
            logging.error("Please install yay manually and run the script again.")
            sys.exit(1)

def install_psutil():
    if not is_package_installed('python3-psutil'):
        logging.info("psutil is not installed. Attempting to install it now...")
        package_manager = detect_package_manager()
        if package_manager == 'apt':
            try:
                subprocess.check_call(["sudo", "apt", "update"])
                subprocess.check_call(["sudo", "apt", "install", "-y", "python3-psutil"])
            except subprocess.CalledProcessError as e:
                logging.error(f"Failed to install psutil with apt. Error: {e}")
                sys.exit(1)
        elif package_manager == 'pacman':
            ensure_arch_dependencies()
            try:
                subprocess.check_call(["sudo", "pacman", "-S", "--noconfirm", "python-psutil"])
            except subprocess.CalledProcessError as e:
                logging.error(f"Failed to install psutil with pacman. Error: {e}")
                sys.exit(1)
        elif package_manager == 'dnf':
            try:
                subprocess.check_call(["sudo", "dnf", "install", "-y", "python3-psutil"])
            except subprocess.CalledProcessError as e:
                logging.error(f"Failed to install psutil with dnf. Error: {e}")
                sys.exit(1)
        elif package_manager == 'zypper':
            try:
                subprocess.check_call(["sudo", "zypper", "install", "-y", "python3-psutil"])
            except subprocess.CalledProcessError as e:
                logging.error(f"Failed to install psutil with zypper. Error: {e}")
                sys.exit(1)
        elif package_manager == 'eopkg':
            try:
                subprocess.check_call(["sudo", "eopkg", "install", "-y", "psutil"])
            except subprocess.CalledProcessError as e:
                logging.error(f"Failed to install psutil with eopkg. Error: {e}")
                sys.exit(1)
        elif package_manager == 'emerge':
            try:
                subprocess.check_call(["sudo", "emerge", "psutil"])
            except subprocess.CalledProcessError as e:
                logging.error(f"Failed to install psutil with emerge. Error: {e}")
                sys.exit(1)
        else:
            logging.error(f"Unsupported distribution: {package_manager}")
            sys.exit(1)
        logging.info("psutil installation attempt completed.")
    else:
        logging.info("psutil is already installed.")

def ensure_git_installed():
    if not is_package_installed('git'):
        logging.info("git is not installed. Attempting to install it now...")
        try:
            package_manager = detect_package_manager()
            if package_manager == 'apt':
                subprocess.check_call(["sudo", "apt", "install", "-y", "git"])
            elif package_manager == 'pacman':
                subprocess.check_call(["sudo", "pacman", "-S", "--noconfirm", "git"])
            elif package_manager == 'dnf':
                subprocess.check_call(["sudo", "dnf", "install", "-y", "git"])
            elif package_manager == 'zypper':
                subprocess.check_call(["sudo", "zypper", "install", "-y", "git"])
            elif package_manager == 'eopkg':
                subprocess.check_call(["sudo", "eopkg", "install", "-y", "git"])
            elif package_manager == 'emerge':
                subprocess.check_call(["sudo", "emerge", "git"])
            logging.info("git installed successfully.")
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to install git. Error: {e}")
            sys.exit(1)
    else:
        logging.info("git is already installed.")

alternative_names = {
    'python3-gi': {
        'apt': 'python3-gi',
        'pacman': 'python-gobject',
        'dnf': 'python3-gobject',
        'zypper': 'python3-gobject',
        'eopkg': 'python-gobject',
        'emerge': 'dev-python/pygobject'
    },
    'python3-cairo': {
        'apt': 'python3-cairo',
        'pacman': 'python-cairo',
        'dnf': 'python3-cairo',
        'zypper': 'python3-cairo',
        'eopkg': 'python-cairo',
        'emerge': 'dev-python/pycairo'
    },
    'gstreamer1.0-plugins-base': {
        'apt': 'gstreamer1.0-plugins-base',
        'pacman': 'gst-plugins-base',
        'dnf': 'gstreamer1.0-plugins-base',
        'zypper': 'gstreamer-plugins-base',
        'eopkg': 'gst-plugins-base',
        'emerge': 'media-libs/gst-plugins-base'
    },
    'gstreamer1.0-plugins-good': {
        'apt': 'gstreamer1.0-plugins-good',
        'pacman': 'gst-plugins-good',
        'dnf': 'gstreamer1.0-plugins-good',
        'zypper': 'gstreamer-plugins-good',
        'eopkg': 'gst-plugins-good',
        'emerge': 'media-plugins/gst-plugins-good'
    },
    'gstreamer1.0-plugins-bad': {
        'apt': 'gstreamer1.0-plugins-bad',
        'pacman': 'gst-plugins-bad',
        'dnf': 'gstreamer1.0-plugins-bad-free',
        'zypper': 'gstreamer-plugins-bad',
        'eopkg': 'gst-plugins-bad',
        'emerge': 'media-plugins/gst-plugins-bad'
    },
    'libappindicator3-dev': {
        'apt': 'libappindicator3-dev',
        'pacman': 'libappindicator-gtk3',
        'dnf': 'libappindicator-gtk3-devel',
        'zypper': 'libappindicator3-devel',
        'eopkg': 'libappindicator-devel',
        'emerge': 'dev-libs/libappindicator'
    },
    'gir1.2-appindicator3-0.1': {
        'apt': 'gir1.2-appindicator3-0.1',
        'pacman': 'libappindicator-gtk3',
        'dnf': 'libappindicator-gtk3',
        'zypper': 'libappindicator3',
        'eopkg': 'libappindicator',
        'emerge': 'dev-libs/libappindicator'
    },
    'libx264-dev': {
        'apt': 'libx264-dev',
        'pacman': 'x264',
        'dnf': 'x264-devel',
        'zypper': 'libx264-devel',
        'eopkg': 'libx264-devel',
        'emerge': 'media-libs/x264'
    },
    'libx265-dev': {
        'apt': 'libx265-dev',
        'pacman': 'x265',
        'dnf': 'x265-devel',
        'zypper': 'libx265-devel',
        'eopkg': 'libx265-devel',
        'emerge': 'media-libs/x265'
    },
    'x11-xserver-utils': {
        'apt': 'x11-xserver-utils',
        'pacman': 'xorg-xrandr',
        'dnf': 'xorg-x11-utils',
        'zypper': 'xorg-x11-utils',
        'eopkg': 'xorg-server-utils',
        'emerge': 'x11-apps/xrandr'
    },
    'psutil': {
        'apt': 'python3-psutil',
        'pacman': 'python-psutil',
        'dnf': 'python3-psutil',
        'zypper': 'python3-psutil',
        'eopkg': 'psutil',
        'emerge': 'dev-python/psutil'
    }
}

def is_package_installed(package_name):
    package_manager = detect_package_manager()
    logging.info(f"Checking if {package_name} is installed using {package_manager}")

    if package_manager == 'apt':
        try:
            result = subprocess.run(["dpkg-query", "-W", "-f=${Status}", package_name], 
                                    capture_output=True, text=True, check=True)
            if "install ok installed" in result.stdout:
                logging.info(f"Package {package_name} is installed")
                return True
        except subprocess.CalledProcessError:
            return False
    elif package_manager == 'pacman':
        try:
            result = subprocess.run(["pacman", "-Q", package_name], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            if result.returncode == 0:
                logging.info(f"Package {package_name} is installed")
                return True
        except subprocess.CalledProcessError:
            return False
    elif package_manager == 'dnf':
        try:
            subprocess.run(["rpm", "-q", package_name], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            logging.info(f"Package {package_name} is installed")
            return True
        except subprocess.CalledProcessError:
            return False
    elif package_manager == 'zypper':
        try:
            result = subprocess.run(["zypper", "se", "-i", package_name], 
                                    capture_output=True, text=True, check=True)
            if "i+ | " + package_name in result.stdout:
                logging.info(f"Package {package_name} is installed (zypper)")
                return True
        except subprocess.CalledProcessError:
            return False
    elif package_manager == 'eopkg':
        try:
            subprocess.run(["eopkg", "list-installed", package_name], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            logging.info(f"Package {package_name} is installed")
            return True
        except subprocess.CalledProcessError:
            return False
    elif package_manager == 'emerge':
        try:
            subprocess.run(["qlist", "-I", package_name], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            logging.info(f"Package {package_name} is installed")
            return True
        except subprocess.CalledProcessError:
            return False
    else:
        logging.error(f"Unsupported package manager: {package_manager}")
        return False

def install_package(package_name):
    if is_package_installed(package_name):
        logging.info(f"{package_name} is already installed.")
        return True

    logging.info(f"Attempting to install {package_name}...")
    package_manager = detect_package_manager()

    try:
        if package_manager == 'apt':
            subprocess.run(["sudo", "apt-get", "update"], check=True)
            subprocess.run(["sudo", "apt-get", "install", "-y", package_name], check=True)
        elif package_manager == 'pacman':
            subprocess.run(["sudo", "pacman", "-S", "--noconfirm", package_name], check=True)
        elif package_manager == 'dnf':
            subprocess.run(["sudo", "dnf", "install", "-y", package_name], check=True)
        elif package_manager == 'zypper':
            subprocess.run(["sudo", "zypper", "install", "-y", package_name], check=True)
        elif package_manager == 'eopkg':
            subprocess.run(["sudo", "eopkg", "install", "-y", package_name], check=True)
        elif package_manager == 'emerge':
            subprocess.run(["sudo", "emerge", package_name], check=True)
        else:
            logging.error(f"Unsupported package manager: {package_manager}")
            return False

        if is_package_installed(package_name):
            logging.info(f"{package_name} installed successfully.")
            return True
        else:
            logging.error(f"Installation of {package_name} failed verification.")
            return False
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to install {package_name}. Command '{e.cmd}' returned non-zero exit status {e.returncode}.")
        if e.output:
            logging.error(f"Command output: {e.output}")
        return False
    except Exception as e:
        logging.error(f"An unexpected error occurred while installing {package_name}: {str(e)}")
        return False

def install_package_if_needed(package_name):
    if not is_package_installed(package_name):
        logging.info(f"{package_name} needs to be installed.")
        if install_package(package_name):
            logging.info(f"{package_name} was successfully installed.")
        else:
            logging.error(f"Failed to install {package_name}.")
    else:
        logging.info(f"{package_name} is already installed. Skipping installation.")

# Specific handling for psutil on Arch Linux
def install_psutil():
    package_name = "python-psutil" if detect_package_manager() == 'pacman' else "python3-psutil"
    install_package_if_needed(package_name)

# Use this function instead of install_psutil()
install_psutil()

def ensure_v4l_utils_installed():
    if not is_package_installed('v4l-utils'):
        logging.info("v4l-utils is not installed. Attempting to install...")
        if install_package('v4l-utils'):
            logging.info("v4l-utils installed successfully.")
        else:
            logging.warning("Failed to install v4l-utils. Some camera functionality may not work.")
    else:
        logging.info("v4l-utils is already available in PATH.")

ensure_v4l_utils_installed()

def add_packman_repository():
    try:
        if distro == 'opensuse-tumbleweed':
            subprocess.check_call(["sudo", "zypper", "ar", "-cfp", "90", "http://packman.inode.at/suse/openSUSE_Tumbleweed/", "packman"])
        elif distro == 'opensuse-leap':
            subprocess.check_call(["sudo", "zypper", "ar", "-cfp", "90", "http://packman.inode.at/suse/openSUSE_Leap_15.5/", "packman"])
        subprocess.check_call(["sudo", "zypper", "refresh"])
        logging.info("Packman repository added and refreshed.")
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to add Packman repository. Error: {e}")
        sys.exit(1)

def check_build_tools():
    package_manager = detect_package_manager()
    if package_manager == 'apt':
        try:
            subprocess.check_call(["dpkg", "-s", "build-essential"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            logging.info("build-essential is already installed.")
        except subprocess.CalledProcessError:
            logging.info("build-essential is not installed. Attempting to install...")
            if not install_package("build-essential"):
                logging.error("Failed to install build-essential. Please install it manually.")
                return False
    elif package_manager in ['pacman', 'dnf', 'zypper', 'eopkg', 'emerge']:
        tools = ['gcc', 'make']
    else:
        logging.error(f"Unsupported package manager: {package_manager}")
        logging.error("Please ensure you have gcc and make installed manually.")
        return False
    
    if package_manager in ['pacman', 'dnf', 'zypper', 'eopkg', 'emerge']:
        missing_tools = []
        for tool in tools:
            try:
                subprocess.check_call(["which", tool], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            except subprocess.CalledProcessError:
                missing_tools.append(tool)
        
        if missing_tools:
            logging.info(f"Missing build tools: {', '.join(missing_tools)}")
            logging.info("Attempting to install missing build tools...")
            for tool in missing_tools:
                if not install_package(tool):
                    logging.error(f"Failed to install {tool}. Please install it manually.")
                    return False
    
    return True

def install_xrectsel():
    logging.info("Attempting to install xrectsel...")
    package_manager = detect_package_manager()
    try:
        if package_manager == 'pacman':
            ensure_arch_dependencies()
            logging.info("Installing xrectsel using yay...")
            install_yay()
            subprocess.check_call(["yay", "-S", "--noconfirm", "xrectsel"])
        elif package_manager == 'dnf':
            logging.info("Installing build dependencies...")
            subprocess.check_call(["sudo", "dnf", "install", "-y", "gcc", "gcc-c++", "make", "libX11-devel", "wget", "tar", "pkgconfig"])
            with tempfile.TemporaryDirectory() as temp_dir:
                os.chdir(temp_dir)
                logging.info(f"Working in temporary directory: {temp_dir}")

                logging.info("Downloading xrectsel source code from ropery's GitHub repository...")
                subprocess.check_call(["wget", "https://github.com/ropery/xrectsel/archive/0.3.2.tar.gz", "-O", "xrectsel.tar.gz"])

                logging.info("Extracting source code...")
                subprocess.check_call(["tar", "-xzf", "xrectsel.tar.gz"])

                logging.info("Changing to xrectsel directory...")
                os.chdir("xrectsel-0.3.2")

                logging.info("Creating a minimal config.h file...")
                with open("config.h", "w") as config_file:
                    config_file.write('#define PACKAGE_NAME "xrectsel"\n#define PACKAGE_VERSION "0.3.2"\n')

                logging.info("Compiling xrectsel...")
                pkg_config_output = subprocess.check_output(["pkg-config", "--cflags", "--libs", "x11", "xrandr"], universal_newlines=True).strip()
                gcc_command = ["gcc", "-o", "xrectsel", "xrectsel.c", "-I."] + pkg_config_output.split()
                make_process = subprocess.Popen(gcc_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
                stdout, stderr = make_process.communicate()

                logging.info("GCC stdout:")
                logging.info(stdout)
                logging.info("GCC stderr:")
                logging.info(stderr)

                if make_process.returncode != 0:
                    logging.error(f"GCC command failed with return code {make_process.returncode}")
                    raise subprocess.CalledProcessError(make_process.returncode, "gcc")

                logging.info("Installing xrectsel...")
                subprocess.check_call(["sudo", "install", "-v", "xrectsel", "/usr/local/bin/"])

            logging.info("xrectsel has been successfully installed to /usr/local/bin/xrectsel.")
            return True
        elif package_manager == 'apt':
            return install_xrectsel_apt()
        elif package_manager in ['zypper', 'eopkg', 'emerge']:
            logging.info("Installing build dependencies...")
            if package_manager == 'zypper':
                subprocess.check_call(["sudo", "zypper", "install", "-y", "gcc", "gcc-c++", "make", "libX11-devel", "wget", "tar"])
            elif package_manager == 'eopkg':
                subprocess.check_call(["sudo", "eopkg", "install", "-y", "gcc", "make", "libx11-devel", "wget", "tar"])
            elif package_manager == 'emerge':
                subprocess.check_call(["sudo", "emerge", "gcc", "make", "libX11", "wget", "tar"])

            with tempfile.TemporaryDirectory() as temp_dir:
                os.chdir(temp_dir)
                logging.info(f"Working in temporary directory: {temp_dir}")

                logging.info("Downloading xrectsel source code from ropery's GitHub repository...")
                subprocess.check_call(["wget", "https://github.com/ropery/xrectsel/archive/0.3.2.tar.gz", "-O", "xrectsel.tar.gz"])

                logging.info("Extracting source code...")
                subprocess.check_call(["tar", "-xzf", "xrectsel.tar.gz"])

                logging.info("Changing to xrectsel directory...")
                extracted_dir = next(name for name in os.listdir() if os.path.isdir(name))
                os.chdir(extracted_dir)

                logging.info("Creating a minimal config.h file...")
                with open("config.h", "w") as config_file:
                    config_file.write('#define PACKAGE_NAME "xrectsel"\n#define PACKAGE_VERSION "0.3.2"\n')

                logging.info("Compiling xrectsel...")
                pkg_config_output = subprocess.check_output(["pkg-config", "--cflags", "--libs", "x11", "xrandr"], universal_newlines=True).strip()
                gcc_command = ["gcc", "-o", "xrectsel", "xrectsel.c", "-I."] + pkg_config_output.split()
                make_process = subprocess.Popen(gcc_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
                stdout, stderr = make_process.communicate()

                logging.info("GCC stdout:")
                logging.info(stdout)
                logging.info("GCC stderr:")
                logging.info(stderr)

                if make_process.returncode != 0:
                    logging.error(f"GCC command failed with return code {make_process.returncode}")
                    raise subprocess.CalledProcessError(make_process.returncode, "gcc")

                logging.info("Installing xrectsel...")
                subprocess.check_call(["sudo", "install", "-v", "xrectsel", "/usr/local/bin/"])

            logging.info("xrectsel has been successfully installed to /usr/local/bin/xrectsel.")
            return True
        else:
            logging.error(f"Unsupported package manager: {package_manager}")
            logging.error("Please install xrectsel manually.")
            return False
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to install xrectsel. Error: {e}")
        logging.error(f"Command '{e.cmd}' returned non-zero exit status {e.returncode}.")
        if hasattr(e, 'output') and e.output:
            logging.error(f"Output: {e.output}")
        return False
    except Exception as e:
        logging.error(f"An unexpected error occurred while installing xrectsel: {str(e)}")
        return False

def install_xrectsel_apt():
    logging.info("Installing build dependencies...")
    subprocess.check_call(["sudo", "apt", "update"])
    subprocess.check_call(["sudo", "apt", "install", "-y", "build-essential", "libx11-dev", "libxrandr-dev", "pkg-config", "wget", "tar"])

    with tempfile.TemporaryDirectory() as temp_dir:
        os.chdir(temp_dir)
        logging.info(f"Working in temporary directory: {temp_dir}")

        logging.info("Downloading xrectsel source code from ropery's GitHub repository...")
        subprocess.check_call(["wget", "https://github.com/ropery/xrectsel/archive/0.3.2.tar.gz", "-O", "xrectsel.tar.gz"])

        logging.info("Extracting source code...")
        subprocess.check_call(["tar", "-xzf", "xrectsel.tar.gz"])

        logging.info("Changing to xrectsel directory...")
        os.chdir("xrectsel-0.3.2")

        logging.info("Creating a minimal config.h file...")
        with open("config.h", "w") as config_file:
            config_file.write('#define PACKAGE_NAME "xrectsel"\n#define PACKAGE_VERSION "0.3.2"\n')

        logging.info("Compiling xrectsel...")
        pkg_config_output = subprocess.check_output(["pkg-config", "--cflags", "--libs", "x11", "xrandr"], universal_newlines=True).strip()
        gcc_command = ["gcc", "-o", "xrectsel", "xrectsel.c", "-I."] + pkg_config_output.split()
        make_process = subprocess.Popen(gcc_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        stdout, stderr = make_process.communicate()

        logging.info("GCC stdout:")
        logging.info(stdout)
        logging.info("GCC stderr:")
        logging.info(stderr)

        if make_process.returncode != 0:
            logging.error(f"GCC command failed with return code {make_process.returncode}")
            raise subprocess.CalledProcessError(make_process.returncode, "gcc")

        logging.info("Installing xrectsel...")
        subprocess.check_call(["sudo", "install", "-v", "xrectsel", "/usr/local/bin/"])

    logging.info("xrectsel has been successfully installed to /usr/local/bin/xrectsel.")
    return True

def setup_ffmpeg_opensuse():
    try:
        logging.info("Setting up FFmpeg with codec support on openSUSE...")
        
        if not check_repositories():
            logging.error("Failed to check repositories. Continuing with setup...")
        
        add_packman_repository()
        subprocess.check_call(["sudo", "zypper", "refresh"])
        logging.info("Installing FFmpeg from Packman repository...")
        ffmpeg_packages = ["ffmpeg", "libavcodec-full", "libavdevice-full", "libavfilter-full", "libavformat-full", "libavutil-full", "libswresample-full", "libswscale-full"]
        for package in ffmpeg_packages:
            result = subprocess.run(["sudo", "zypper", "install", "--from", "packman", "-y", package], 
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
            if result.returncode != 0:
                logging.error(f"Error installing {package}. Return code: {result.returncode}")
                logging.error(f"Command output:\n{result.stdout}\n{result.stderr}")
            else:
                logging.info(f"Successfully installed {package}")
        
        logging.info("Installing additional codecs...")
        codec_packages = ["libx264-155", "libx265-199"]
        for package in codec_packages:
            codec_result = subprocess.run(["sudo", "zypper", "install", "--from", "packman", "-y", package], 
                                          stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
            if codec_result.returncode != 0:
                logging.error(f"Error installing {package}. Return code: {codec_result.returncode}")
                logging.error(f"Command output:\n{codec_result.stdout}\n{codec_result.stderr}")
            else:
                logging.info(f"Successfully installed {package}")
        
        logging.info("Verifying FFmpeg installation...")
        verify_result = subprocess.run(["ffmpeg", "-encoders"], 
                                       stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        if "libx264" in verify_result.stdout:
            logging.info("FFmpeg with libx264 support has been successfully installed.")
        else:
            logging.error("libx264 support not found in FFmpeg. Installation might have failed.")
            logging.info("FFmpeg encoders output:")
            logging.info(verify_result.stdout)
        
        logging.info("Checking FFmpeg version and configuration...")
        version_result = subprocess.run(["ffmpeg", "-version"], 
                                        stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        logging.info(version_result.stdout)
        
    except subprocess.CalledProcessError as e:
        logging.error(f"An error occurred while setting up FFmpeg: {e}")
        logging.error(f"Command that failed: {e.cmd}")
        logging.error(f"Return code: {e.returncode}")
        logging.error(f"Output: {e.output}")
        logging.error(f"Stderr: {e.stderr}")
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
    
    logging.info("FFmpeg setup process completed.")

def check_ffmpeg_installation():
    try:
        # First, check if ffmpeg is in the PATH
        if shutil.which('ffmpeg') is None:
            logging.error("FFmpeg is not found in the system PATH.")
            return False

        # Now, try to run ffmpeg
        result = subprocess.run(["ffmpeg", "-version"], 
                                stdout=subprocess.PIPE, 
                                stderr=subprocess.PIPE, 
                                universal_newlines=True)
        
        if result.returncode != 0:
            logging.error(f"Error running FFmpeg: {result.stderr}")
            return False

        logging.info("FFmpeg is installed and working.")
        
        # Check for required codecs
        encoders_result = subprocess.run(["ffmpeg", "-encoders"], 
                                         stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        
        if "libx264" not in encoders_result.stdout or "libx265" not in encoders_result.stdout:
            logging.warning("FFmpeg is installed but missing required codecs (libx264 or libx265).")
            return False

        logging.info("FFmpeg is installed with required codecs.")
        return True
    except Exception as e:
        logging.error(f"An error occurred while checking FFmpeg installation: {e}")
        return False

def check_ffmpeg_config():
    try:
        version_result = subprocess.run(["ffmpeg", "-version"], 
                                        stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        logging.info("FFmpeg version:")
        logging.info(version_result.stdout)

        encoders_result = subprocess.run(["ffmpeg", "-encoders"], 
                                         stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        logging.info("Available encoders:")
        logging.info(encoders_result.stdout)

        config_result = subprocess.run(["ffmpeg", "-formats"], 
                                       stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        logging.info("FFmpeg configuration:")
        logging.info(config_result.stdout)

        if "libx264" in encoders_result.stdout:
            logging.info("libx264 encoder is available.")
        else:
            logging.warning("libx264 encoder is not available. You may need to install additional packages.")

    except FileNotFoundError:
        logging.error("FFmpeg is not installed or not in the system PATH.")
    except Exception as e:
        logging.error(f"An error occurred while checking FFmpeg configuration: {e}")




def ensure_psutil():
    try:
        import psutil
        return psutil
    except ImportError:
        print("psutil is not installed. Attempting to install...")
        try:
            # Check if we're running as root
            if os.geteuid() != 0:
                print("This script needs to be run with sudo privileges.")
                sys.exit(1)
            
            # Update package list
            subprocess.run(["apt", "update"], check=True)
            
            # Install python3-psutil
            subprocess.run(["apt", "install", "-y", "python3-psutil"], check=True)
            
            print("psutil has been successfully installed.")
            
            # Try importing again
            import psutil
            return psutil
        except subprocess.CalledProcessError as e:
            print(f"An error occurred while installing psutil: {e}")
            sys.exit(1)
        except ImportError:
            print("Failed to import psutil after installation.")
            sys.exit(1)




def check_repositories():
    try:
        result = subprocess.run(['zypper', 'repos'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        logging.info("Defined repositories:")
        logging.info(result.stdout)
        return True
    except subprocess.CalledProcessError as e:
        logging.error(f"Error checking repositories: {e}")
        logging.error(f"Command output: {e.output}")
        return False

def check_and_install_codecs():
    codecs = ['libx264', 'libx265']
    package_manager = detect_package_manager()
    
    def is_ffmpeg_installed():
        return shutil.which('ffmpeg') is not None

    try:
        # First, ensure FFmpeg is installed
        if not is_ffmpeg_installed():
            logging.info("FFmpeg is not installed. Attempting to install...")
            if not install_package('ffmpeg'):
                logging.error("Failed to install FFmpeg. This is a critical error.")
                return False
        
        # Verify FFmpeg installation
        if not is_ffmpeg_installed():
            logging.error("FFmpeg installation failed. This is a critical error.")
            return False

        # Now check for codecs
        try:
            installed_codecs = subprocess.check_output(['ffmpeg', '-codecs'], stderr=subprocess.STDOUT).decode('utf-8')
        except subprocess.CalledProcessError as e:
            logging.error(f"Error checking FFmpeg codecs: {e}")
            logging.error(f"FFmpeg output: {e.output.decode('utf-8')}")
            return False

        for codec in codecs:
            if codec not in installed_codecs:
                logging.info(f"{codec} is not installed. Attempting to install...")
                if package_manager == 'apt':
                    if codec == 'libx264':
                        install_package('libx264-dev')
                    elif codec == 'libx265':
                        install_package('libx265-dev')
                elif package_manager == 'pacman':
                    install_package('ffmpeg')
                elif package_manager == 'dnf':
                    install_package('ffmpeg-free.x86_64')
                    install_package(codec)
                elif package_manager == 'zypper':
                    setup_ffmpeg_opensuse()
                elif package_manager in ['eopkg', 'emerge']:
                    install_package('ffmpeg')
        
        # Verify installation
        if not check_ffmpeg_installation():
            logging.error("FFmpeg installation verification failed. This is a critical error.")
            return False
        
        return True
    except Exception as e:
        logging.error(f"An error occurred while checking or installing codecs: {e}")
        return False

def check_install_python_gobject():
    logging.info("Checking for python-gobject package...")
    package_manager = detect_package_manager()
    
    if is_package_installed('python-gobject'):
        logging.info("python-gobject is already installed.")
        return True

    if package_manager != 'apt':
        logging.info(f"Not using APT package manager. Attempting to install python-gobject using {package_manager}...")
        if install_package('python-gobject'):
            logging.info("python-gobject installed successfully.")
            return True
        else:
            logging.error("Failed to install python-gobject.")
            return False
    
    try:
        subprocess.check_call(["dpkg", "-s", "python3-gi"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        logging.info("python-gobject (python3-gi) is already installed.")
        return True
    except subprocess.CalledProcessError:
        logging.info("python-gobject (python3-gi) is not installed. Attempting to install...")
        try:
            subprocess.check_call(["sudo", "apt", "update"])
            subprocess.check_call(["sudo", "apt", "install", "-y", "python3-gi"])
            logging.info("python-gobject (python3-gi) installed successfully.")
            return True
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to install python-gobject (python3-gi). Error: {e}")
            return False

def install_handbrake_cli():
    distro = get_distro()
    if distro not in ['ubuntu', 'debian']:
        logging.error(f"This function is specific to Ubuntu and Debian. Detected distro: {distro}")
        return False

    if verify_handbrake_cli_installation():
        logging.info("HandBrakeCLI is already installed.")
        return True

    logging.info(f"HandBrakeCLI not found. Installing on {distro.capitalize()}...")
    try:
        # Update package list
        subprocess.check_call(["sudo", "apt", "update"])
        
        # Install handbrake-cli
        subprocess.check_call(["sudo", "apt", "install", "-y", "handbrake-cli"])
        
        if verify_handbrake_cli_installation():
            logging.info("HandBrakeCLI installed successfully.")
            return True
        else:
            logging.error("HandBrakeCLI installation failed verification.")
            return False
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to install HandBrakeCLI. Error: {e}")
        return False

def add_handbrake_ppa():
    try:
        # First, install software-properties-common if it's not already installed
        subprocess.check_call(["sudo", "apt-get", "install", "-y", "software-properties-common"])
        
        # Add the HandBrake PPA
        subprocess.check_call(["sudo", "add-apt-repository", "-y", "ppa:stebbins/handbrake-releases"])
        
        # Update package list
        subprocess.check_call(["sudo", "apt-get", "update"])
        
        logging.info("Successfully added HandBrake PPA.")
        return True
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to add HandBrake PPA. Error: {e}")
        return False

def install_handbrake_cli_from_source():
    logging.info("Attempting to install HandBrakeCLI from source...")
    try:
        # Install build dependencies
        subprocess.check_call(["sudo", "apt-get", "install", "-y", "autoconf", "automake", "build-essential", "cmake", "git", "libass-dev", "libbz2-dev", "libfontconfig1-dev", "libfreetype6-dev", "libfribidi-dev", "libharfbuzz-dev", "libjansson-dev", "liblzma-dev", "libmp3lame-dev", "libnuma-dev", "libogg-dev", "libopus-dev", "libsamplerate-dev", "libspeex-dev", "libtheora-dev", "libtool", "libtool-bin", "libvorbis-dev", "libx264-dev", "libxml2-dev", "libvpx-dev", "m4", "make", "nasm", "ninja-build", "patch", "pkg-config", "python", "tar", "zlib1g-dev"])
        
        # Clone HandBrake repository
        subprocess.check_call(["git", "clone", "https://github.com/HandBrake/HandBrake.git"])
        os.chdir("HandBrake")
        
        # Configure and build
        subprocess.check_call(["./configure", "--launch-jobs=$(nproc)", "--launch"])
        
        # Install
        subprocess.check_call(["sudo", "make", "--directory=build", "install"])
        
        os.chdir("..")
        shutil.rmtree("HandBrake")
        
        if verify_handbrake_cli_installation():
            logging.info("Successfully installed HandBrakeCLI from source.")
            return True
        else:
            logging.error("Failed to install HandBrakeCLI from source.")
            return False
    except subprocess.CalledProcessError as e:
        logging.error(f"Error during HandBrakeCLI source installation: {e}")
        return False
    except Exception as e:
        logging.error(f"Unexpected error during HandBrakeCLI source installation: {e}")
        return False

def verify_handbrake_cli_installation():
    if shutil.which('HandBrakeCLI'):
        logging.info("HandBrakeCLI is installed and in the system PATH.")
        return True
    else:
        logging.info("HandBrakeCLI is not found in the system PATH.")
        return False

def ensure_handbrake_cli_installed():
    try:
        # Check if HandBrakeCLI is already installed
        subprocess.run(["HandBrakeCLI", "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        print("HandBrakeCLI is already installed.")
    except FileNotFoundError:
        print("HandBrakeCLI not found. Installing now...")
        try:
            # Update package list and install HandBrakeCLI
            subprocess.run(["sudo", "apt", "update"], check=True)
            subprocess.run(["sudo", "apt", "install", "-y", "handbrake-cli"], check=True)
            print("HandBrakeCLI has been successfully installed.")
        except subprocess.CalledProcessError as e:
            print(f"Error installing HandBrakeCLI: {e}")
            print("Please make sure you have sudo privileges and try again.")

# Call this function at the start of your program
ensure_handbrake_cli_installed()

def verify_wmctrl_installation():
    if shutil.which('wmctrl'):
        logging.info("wmctrl is installed and in the system PATH.")
        return True
    else:
        logging.error("wmctrl is not found in the system PATH after installation attempt.")
        return False

def install_wmctrl():
    if install_package('wmctrl'):
        if verify_wmctrl_installation():
            return True
    
    logging.warning("Standard installation of wmctrl failed. Attempting alternative methods...")
    
    # Try installing x11-utils which includes wmctrl on some systems
    if install_package('x11-utils'):
        if verify_wmctrl_installation():
            return True
    
    # If all else fails, try to install from source
    return install_wmctrl_from_source()

def install_wmctrl_from_source():
    logging.info("Attempting to install wmctrl from source...")
    try:
        # Install build dependencies
        install_package('build-essential')
        install_package('libx11-dev')
        install_package('libglib2.0-dev')
        install_package('libxmu-dev')
        
        # Clone wmctrl repository
        subprocess.check_call(["git", "clone", "https://github.com/geekless/wmctrl.git"])
        os.chdir("wmctrl")
        
        # Build and install
        subprocess.check_call(["./configure"])
        subprocess.check_call(["make"])
        subprocess.check_call(["sudo", "make", "install"])
        
        os.chdir("..")
        shutil.rmtree("wmctrl")
        
        if verify_wmctrl_installation():
            logging.info("Successfully installed wmctrl from source.")
            return True
        else:
            logging.error("Failed to install wmctrl from source.")
            return False
    except subprocess.CalledProcessError as e:
        logging.error(f"Error during wmctrl source installation: {e}")
        return False
    except Exception as e:
        logging.error(f"Unexpected error during wmctrl source installation: {e}")
        return False

# In your main script or where you check for dependencies
if not verify_wmctrl_installation():
    if not install_wmctrl():
        logging.error("Failed to install wmctrl. Some features may not work correctly.")
    else:
        logging.info("wmctrl has been successfully installed.")

def check_and_install_dependencies():
    package_manager = detect_package_manager()
    distro = get_distro()
    
    logging.info(f"Detected package manager: {package_manager}")
    logging.info(f"Detected distribution: {distro}")

    if not install_psutil():
        logging.error("Failed to install psutil. This may affect some functionality.")
    ensure_git_installed()
    
    if not check_build_tools():
        return False
    
    if not check_install_python_gobject():
        logging.error("Failed to install python-gobject. This is a critical dependency.")
        return False
    
    missing_packages = []
    installed_packages = []
    failed_packages = []
    
    for package in alternative_names:
        installed = False
        if package in alternative_names:
            logging.info(f"Checking alternatives for {package}...")
            for alt_name in alternative_names[package]:
                if is_package_installed(alt_name):
                    logging.info(f"Alternative {alt_name} for {package} is installed.")
                    installed_packages.append(alt_name)
                    installed = True
                    break
            if not installed:
                package_to_install = alternative_names[package].get(distro, package)
        
        if not installed:
            if is_package_installed(package_to_install):
                logging.info(f"{package_to_install} is already installed.")
                installed_packages.append(package_to_install)
            else:
                logging.info(f"{package_to_install} needs to be installed.")
                missing_packages.append(package_to_install)
    
    logging.info("\nInstalled packages:")
    logging.info(installed_packages)
    logging.info("Packages to be installed:")
    logging.info(missing_packages)
    
    for package in missing_packages:
        if not install_package(package):
            logging.error(f"Failed to install {package}. Continuing without it.")
            failed_packages.append(package)
    
    # Specific check for handbrake-cli
    if not is_package_installed('handbrake-cli') and not is_package_installed('handbrake'):
        logging.info("handbrake-cli is not installed. Attempting to install...")
        if not install_package('handbrake-cli') and not install_package('handbrake'):
            logging.error("Failed to install handbrake-cli or handbrake. Continuing without it.")
            failed_packages.append('handbrake-cli')
    
    if shutil.which('xrectsel') is None:
        logging.info("xrectsel is not installed. Attempting to install...")
        if not install_xrectsel():
            logging.error("Failed to install xrectsel. Continuing without it.")
            failed_packages.append('xrectsel')
    
    for package in missing_packages:
        if package == 'wmctrl':
            if not install_wmctrl():
                logging.error("Failed to install wmctrl. Continuing without it.")
                failed_packages.append('wmctrl')
        elif not install_package(package):
            logging.error(f"Failed to install {package}. Continuing without it.")
            failed_packages.append(package)

    if package_manager == 'zypper':
        setup_ffmpeg_opensuse()
    else:
        check_and_install_codecs()
    
    if not check_ffmpeg_installation():
        logging.error("FFmpeg installation or codec verification failed. Some features may not work correctly.")
    else:
        logging.info("FFmpeg installation and codec verification successful.")
    
    # Check and install xclip
    if not ensure_xclip_installed():
        logging.warning("Failed to install xclip. Some clipboard functionality may not work.")
        failed_packages.append('xclip')
    
    if failed_packages:
        logging.warning(f"The following packages could not be installed: {', '.join(failed_packages)}")
        logging.warning("Some features may not work correctly. Please install these packages manually if needed.")
    else:
        logging.info("All required packages were successfully installed.")
    
    return len(failed_packages) == 0

def ensure_xclip_installed():
    logging.info("Checking xclip installation...")
    
    # Check if xclip is installed
    if shutil.which('xclip') is not None:
        logging.info("xclip is already installed.")
        return True
    
    logging.warning("xclip is not installed. Attempting to install...")
    
    package_manager = detect_package_manager()
    
    if package_manager == 'apt':
        install_command = ['sudo', 'apt-get', 'install', '-y', 'xclip']
    elif package_manager == 'pacman':
        install_command = ['sudo', 'pacman', '-S', '--noconfirm', 'xclip']
    elif package_manager == 'dnf':
        install_command = ['sudo', 'dnf', 'install', '-y', 'xclip']
    elif package_manager == 'zypper':
        install_command = ['sudo', 'zypper', 'install', '-y', 'xclip']
    elif package_manager == 'eopkg':
        install_command = ['sudo', 'eopkg', 'install', '-y', 'xclip']
    elif package_manager == 'emerge':
        install_command = ['sudo', 'emerge', 'x11-misc/xclip']
    else:
        logging.error(f"Unsupported package manager: {package_manager}")
        return False

    try:
        subprocess.run(install_command, check=True)
        logging.info("xclip installed successfully.")
        return True
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to install xclip. Error: {e}")
        return False


def install_psutil():
    logging.info("Checking psutil installation...")
    
    try:
        import psutil
        logging.info("psutil is already installed.")
        return True
    except ImportError:
        logging.info("psutil is not installed. Attempting to install...")
    
    package_manager = detect_package_manager()
    
    if package_manager == 'apt':
        try:
            # First, update the package list
            subprocess.run(['sudo', 'apt-get', 'update'], check=True)
            # Then try to install python3-psutil
            subprocess.run(['sudo', 'apt-get', 'install', '-y', 'python3-psutil'], check=True)
        except subprocess.CalledProcessError:
            logging.error("Failed to install python3-psutil. Attempting to install via pip...")
            try:
                subprocess.run(['sudo', 'apt-get', 'install', '-y', 'python3-pip'], check=True)
                subprocess.run(['pip3', 'install', 'psutil'], check=True)
            except subprocess.CalledProcessError as e:
                logging.error(f"Failed to install psutil via pip. Error: {e}")
                return False
    elif package_manager == 'pacman':
        subprocess.run(['sudo', 'pacman', '-S', '--noconfirm', 'python-psutil'], check=True)
    elif package_manager == 'dnf':
        subprocess.run(['sudo', 'dnf', 'install', '-y', 'python3-psutil'], check=True)
    elif package_manager == 'zypper':
        subprocess.run(['sudo', 'zypper', 'install', '-y', 'python3-psutil'], check=True)
    elif package_manager == 'eopkg':
        subprocess.run(['sudo', 'eopkg', 'install', '-y', 'python3-psutil'], check=True)
    elif package_manager == 'emerge':
        subprocess.run(['sudo', 'emerge', 'dev-python/psutil'], check=True)
    else:
        logging.error(f"Unsupported package manager: {package_manager}")
        return False

    logging.info("psutil installation completed. Verifying...")
    try:
        import psutil
        logging.info("psutil was successfully installed and imported.")
        return True
    except ImportError:
        logging.error("Failed to import psutil after installation. Please try installing it manually.")
        return False


def install_appindicator():
    logging.info("Checking AppIndicator installation...")
    
    package_manager = detect_package_manager()
    
    if package_manager != 'apt':
        logging.error("This function is designed for Debian-based systems. Please install AppIndicator manually.")
        return False
    
    try:
        # First, update the package list
        subprocess.run(['sudo', 'apt-get', 'update'], check=True)
        
        # Try to install AppIndicator3
        subprocess.run(['sudo', 'apt-get', 'install', '-y', 'gir1.2-appindicator3-0.1'], check=True)
        logging.info("AppIndicator3 installed successfully.")
    except subprocess.CalledProcessError:
        logging.warning("Failed to install AppIndicator3. Trying AyatanaAppIndicator3...")
        try:
            subprocess.run(['sudo', 'apt-get', 'install', '-y', 'gir1.2-ayatanaappindicator3-0.1'], check=True)
            logging.info("AyatanaAppIndicator3 installed successfully.")
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to install AyatanaAppIndicator3. Error: {e}")
            return False
    
    logging.info("AppIndicator installation completed.")
    return True        



def check_camera_availability():
    try:
        cameras = [dev for dev in os.listdir('/dev') if dev.startswith('video')]
        if cameras:
            logging.info(f"Cameras detected: {cameras}")
            return True
        else:
            logging.warning("No camera detected in /dev")
            return False
    except Exception as e:
        logging.error(f"Error checking camera availability: {e}")
        return False

def select_screen_region():
    try:
        output = subprocess.check_output(["xrectsel"]).decode('utf-8').strip()
        return output
    except FileNotFoundError:
        logging.warning("xrectsel not found. Using fallback method for screen selection.")
        return "0,0,1920,1080"
    except subprocess.CalledProcessError:
        logging.warning("Error running xrectsel. Using fallback method for screen selection.")
        return "0,0,1920,1080"

if not check_and_install_dependencies():
    logging.error("Not all dependencies could be installed. Some features may not work.")
else:
    logging.info("All critical dependencies are installed.")

import psutil

camera_available = check_camera_availability()

import gi
import cairo

gi.require_version('Gtk', '3.0')
gi.require_version('Gst', '1.0')

AppIndicator3 = None
try:
    gi.require_version('AppIndicator3', '0.1')
    from gi.repository import AppIndicator3
except ValueError:
    try:
        gi.require_version('AyatanaAppIndicator3', '0.1')
        from gi.repository import AyatanaAppIndicator3 as AppIndicator3
    except ValueError:
        logging.error("Neither AppIndicator3 nor AyatanaAppIndicator3 is available. The system tray icon will not be displayed.")

from gi.repository import Gtk, Gdk, GLib, Gst, GdkX11, GdkPixbuf, Pango

Gst.init(None)

def import_camera_modules():
    global GstVideo
    try:
        gi.require_version('GstVideo', '1.0')
        from gi.repository import GstVideo
        return True
    except (ValueError, ImportError) as e:
        logging.error(f"Failed to import GstVideo: {e}")
        return False

if camera_available:
    camera_modules_imported = import_camera_modules()
    if not camera_modules_imported:
        camera_available = False
        logging.error("Failed to import camera modules. Continuing without camera functionality.")
else:
    logging.error("No camera detected. Continuing without camera functionality.")


def ensure_scrot_installed():
    if not is_package_installed('scrot'):
        logging.info("Scrot is not installed. Attempting to install...")
        package_manager = detect_package_manager()
        try:
            if package_manager == 'apt':
                subprocess.check_call(["sudo", "apt", "update"])
                subprocess.check_call(["sudo", "apt", "install", "-y", "scrot"])
            elif package_manager == 'pacman':
                subprocess.check_call(["sudo", "pacman", "-S", "--noconfirm", "scrot"])
            elif package_manager == 'dnf':
                subprocess.check_call(["sudo", "dnf", "install", "-y", "scrot"])
            elif package_manager == 'zypper':
                subprocess.check_call(["sudo", "zypper", "install", "-y", "scrot"])
            elif package_manager == 'emerge':
                subprocess.check_call(["sudo", "emerge", "media-gfx/scrot"])
            else:
                logging.error(f"Unsupported package manager: {package_manager}")
                return False
            logging.info("Scrot installed successfully.")
            return True
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to install scrot. Error: {e}")
            return False
    else:
        logging.info("Scrot is already installed.")
        return True


def install_packages_debian_bookworm():
    required_packages = [
        'gir1.2-ayatanaappindicator3-0.1',
        'python3-gi',
        'python3-gi-cairo',
        'mpv'
    ]
    
    packages_to_install = [pkg for pkg in required_packages if not is_package_installed(pkg)]
    
    if not packages_to_install:
        logging.info("All required packages are already installed.")
        return
    
    try:
        logging.info("Updating package list...")
        subprocess.check_call(["sudo", "apt", "update"])
        logging.info("Installing required packages...")
        subprocess.check_call(["sudo", "apt", "install", "-y"] + packages_to_install)
        logging.info("Required packages installed successfully.")
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to install packages. Error: {e}")
        sys.exit(1)

def install_scrot():
    logging.info("Attempting to install scrot...")
    package_manager = detect_package_manager()
    logging.info(f"Detected package manager: {package_manager}")
    
    if package_manager is None:
        logging.error("Unable to detect package manager. Cannot install scrot.")
        return
    
    try:
        if package_manager == 'apt':
            logging.info("Using apt to install scrot...")
            subprocess.check_call(["sudo", "apt", "update"])
            subprocess.check_call(["sudo", "apt", "install", "-y", "scrot"])
        elif package_manager == 'pacman':
            logging.info("Using pacman to install scrot...")
            subprocess.check_call(["sudo", "pacman", "-S", "--noconfirm", "scrot"])
        elif package_manager == 'dnf':
            logging.info("Using dnf to install scrot...")
            subprocess.check_call(["sudo", "dnf", "install", "-y", "scrot"])
        elif package_manager == 'zypper':
            logging.info("Using zypper to install scrot...")
            subprocess.check_call(["sudo", "zypper", "install", "-y", "scrot"])
        elif package_manager == 'emerge':
            logging.info("Using emerge to install scrot...")
            subprocess.check_call(["sudo", "emerge", "media-gfx/scrot"])
        else:
            logging.error(f"Unsupported package manager: {package_manager}")
            return
        
        logging.info("Scrot installation command completed successfully.")
        
        # Verify installation
        if shutil.which('scrot'):
            logging.info("Scrot is now available in the system path.")
        else:
            logging.warning("Scrot was supposedly installed but is not found in the system path.")
        
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to install scrot. Error: {e}")
        logging.error(f"Command that failed: {e.cmd}")
        logging.error(f"Return code: {e.returncode}")
        if e.output:
            logging.error(f"Command output: {e.output}")
    except Exception as e:
        logging.error(f"An unexpected error occurred while installing scrot: {str(e)}")

import subprocess
import logging
import os
import sys

def is_debian_bookworm():
    try:
        with open('/etc/os-release', 'r') as f:
            os_release = f.read()
        return 'debian' in os_release.lower() and 'bookworm' in os_release.lower()
    except FileNotFoundError:
        return False

def is_package_installed(package_name):
    package_manager = detect_package_manager()
    try:
        if package_manager == 'apt':
            subprocess.check_call(['dpkg', '-s', package_name], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        elif package_manager == 'pacman':
            subprocess.check_call(['pacman', '-Qi', package_name], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        elif package_manager == 'dnf':
            subprocess.check_call(['rpm', '-q', package_name], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        elif package_manager == 'zypper':
            subprocess.check_call(['rpm', '-q', package_name], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        elif package_manager == 'emerge':
            subprocess.check_call(['qlist', '-I', package_name], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        else:
            logging.error(f"Unsupported package manager: {package_manager}")
            return False
        return True
    except subprocess.CalledProcessError:
        return False

def install_packages():
    package_manager = detect_package_manager()
    
    # Always try to install scrot, regardless of the distribution
    ensure_scrot_installed()
    
    if is_debian_bookworm():
        required_packages = [
            'gir1.2-ayatanaappindicator3-0.1',
            'python3-gi',
            'python3-gi-cairo',
            'mpv'
        ]

        packages_to_install = [pkg for pkg in required_packages if not is_package_installed(pkg)]

        if not packages_to_install:
            logging.info("All Debian Bookworm-specific packages are already installed.")
        else:
            try:
                logging.info("Updating package list...")
                subprocess.check_call(["sudo", "apt", "update"])

                logging.info("Installing required Debian Bookworm-specific packages...")
                subprocess.check_call(["sudo", "apt", "install", "-y"] + packages_to_install)

                logging.info("Required Debian Bookworm-specific packages installed successfully.")
            except subprocess.CalledProcessError as e:
                logging.error(f"Failed to install Debian Bookworm-specific packages. Error: {e}")
    else:
        logging.info("This is not Debian Bookworm. Only scrot has been installed.")

# Call the function to install the packages
install_packages()

# Try to import AppIndicator3 or fall back to AyatanaAppIndicator3
try:
    import gi
    gi.require_version('AppIndicator3', '0.1')
    from gi.repository import AppIndicator3
    logging.info("Using AppIndicator3 for system tray icon.")
except (ImportError, ValueError):
    try:
        gi.require_version('AyatanaAppIndicator3', '0.1')
        from gi.repository import AyatanaAppIndicator3 as AppIndicator3
        logging.info("Using AyatanaAppIndicator3 for system tray icon.")
    except (ImportError, ValueError):
        logging.error("Neither AppIndicator3 nor AyatanaAppIndicator3 is available.")
        sys.exit(1)

# Rest of your script, including the use of AppIndicator3, follows here



def draw(window):
    cr = window.get_property('window').cairo_create()
    cr.set_source_rgb(0, 0, 0)
    cr.paint()

display_server = detect_display_server()
logging.info(f"Using {display_server} display server.")



import os
import subprocess

def detect_display_server():
    # Check environment variables
    if 'WAYLAND_DISPLAY' in os.environ:
        return 'wayland'
    elif 'DISPLAY' in os.environ and 'WAYLAND_DISPLAY' not in os.environ:
        return 'x11'
    
    # Check XDG_SESSION_TYPE
    xdg_session_type = os.environ.get('XDG_SESSION_TYPE', '').lower()
    if xdg_session_type in ['wayland', 'x11']:
        return xdg_session_type
    
    # Check loginctl
    try:
        output = subprocess.check_output([
            'loginctl', 'show-session', '$(loginctl show-user $(whoami) -p Display --value)',
            '-p', 'Type', '--value'
        ], universal_newlines=True).strip()
        if output.lower() in ['wayland', 'x11']:
            return output.lower()
    except subprocess.CalledProcessError:
        pass
    
    # Check for Wayland-specific processes
    try:
        output = subprocess.check_output(['ps', 'aux'], universal_newlines=True)
        if any('wayland' in line.lower() for line in output.splitlines()):
            return 'wayland'
    except subprocess.CalledProcessError:
        pass
    
    return 'unknown'

import subprocess
import logging
import shutil

def ensure_pactl_installed():
    if shutil.which('pactl'):
        logging.info("pactl is already installed.")
        return True

    logging.info("pactl is not installed. Attempting to install...")
    
    # Check if we're on a system that uses apt
    if not shutil.which('apt-get'):
        logging.error("This system does not use apt. Cannot automatically install pactl.")
        return False

    try:
        # Update package list
        subprocess.run(['sudo', 'apt-get', 'update'], check=True)
        
        # Install pulseaudio-utils which contains pactl
        subprocess.run(['sudo', 'apt-get', 'install', '-y', 'pulseaudio-utils'], check=True)
        
        if shutil.which('pactl'):
            logging.info("pactl has been successfully installed.")
            return True
        else:
            logging.error("pactl installation seemed to succeed, but the program is still not found.")
            return False
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to install pactl: {e}")
        return False

# Usage
if ensure_pactl_installed():
    print("pactl is available and ready to use.")
else:
    print("Failed to ensure pactl is installed. Some audio-related features may not work.")

def display_progress_bar(total_steps, current_step, description):
    progress = int((current_step / total_steps) * 100)
    bar = f"[{'#' * (progress // 10)}{'.' * (10 - progress // 10)}]"
    print(f"\r{bar} {progress}% - {description}", end='')




































class AudioVisualizer(Gtk.DrawingArea):
    def __init__(self):
        super().__init__()
        self.set_size_request(200, 100)
        self.left_level = 0
        self.right_level = 0
        self.connect("draw", self.on_draw)

    def on_draw(self, widget, cr):
        width = widget.get_allocated_width()
        height = widget.get_allocated_height()

        # Background
        cr.set_source_rgb(0.1, 0.1, 0.1)
        cr.rectangle(0, 0, width, height)
        cr.fill()

        # Draw left channel
        cr.set_source_rgb(0, 0.7, 0)
        self.draw_channel(cr, self.left_level, 0, width, height / 2)

        # Draw right channel
        cr.set_source_rgb(0.7, 0, 0)
        self.draw_channel(cr, self.right_level, height / 2, width, height / 2)

        # Draw labels
        cr.set_source_rgb(1, 1, 1)
        cr.select_font_face("Sans", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
        cr.set_font_size(12)
        cr.move_to(5, 15)
        cr.show_text("L")
        cr.move_to(5, height / 2 + 15)
        cr.show_text("R")

    def draw_channel(self, cr, level, y_offset, width, height):
        bar_width = int(width * level)
        cr.rectangle(0, y_offset, bar_width, height)
        cr.fill()

        # Draw level text
        cr.set_source_rgb(1, 1, 1)
        cr.select_font_face("Sans", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        cr.set_font_size(10)
        text = f"{int(level * 100)}%"
        x_bearing, y_bearing, text_width, text_height = cr.text_extents(text)[:4]
        cr.move_to(width - text_width - 5, y_offset + height / 2 + text_height / 2)
        cr.show_text(text)

    def update_levels(self, left_level, right_level):
        self.left_level = left_level
        self.right_level = right_level
        self.queue_draw()





class VideoTrimmingDialog(Gtk.Dialog):
    def __init__(self, parent, video_path):
        super().__init__(title="Trim Video", transient_for=parent, flags=0)
        self.video_path = video_path
        self.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OK, Gtk.ResponseType.OK
        )

        self.set_default_size(350, 150)

        box = self.get_content_area()
        
        # Start time entry
        start_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        start_label = Gtk.Label(label="Start Time (seconds):")
        self.start_entry = Gtk.Entry()
        start_box.pack_start(start_label, False, False, 0)
        start_box.pack_start(self.start_entry, True, True, 0)
        box.add(start_box)

        # End time entry
        end_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        end_label = Gtk.Label(label="End Time (seconds):")
        self.end_entry = Gtk.Entry()
        end_box.pack_start(end_label, False, False, 0)
        end_box.pack_start(self.end_entry, True, True, 0)
        box.add(end_box)

        # Video duration label
        self.duration_label = Gtk.Label()
        box.add(self.duration_label)

        self.show_all()
        self.get_video_duration()

    def get_video_duration(self):
        try:
            result = subprocess.run(['ffprobe', '-v', 'error', '-show_entries', 'format=duration', '-of', 'default=noprint_wrappers=1:nokey=1', self.video_path], 
                                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            duration = float(result.stdout)
            self.duration_label.set_text(f"Video Duration: {duration:.2f} seconds")
        except Exception as e:
            print(f"Error getting video duration: {e}")
            self.duration_label.set_text("Unable to get video duration")

    def get_trim_times(self):
        start = float(self.start_entry.get_text() or 0)
        end = float(self.end_entry.get_text() or 0)
        return start, end









class VideoConverter:
    def __init__(self, parent):
        self.input_entry = Gtk.Entry()
        
        self.parent = parent
        self.conversion_thread = None
        self.process = None
        self.is_converting = False
        self.input_formats = ["MKV", "MP4", "TS", "WebM"]
        self.output_formats = ["MKV", "MP4", "WebM"]
        self.recent_output_file = None
        self.start_time = None
        self.progress_samples = []
        self.current_file_size = 0
        self.detected_gpu = self.detect_gpu()
        self.create_converter_ui()

    def create_converter_ui(self):
        self.grid = Gtk.Grid()
        self.grid.set_column_spacing(10)
        self.grid.set_row_spacing(10)

        # Input file
        input_label = Gtk.Label(label="Input File:")
        self.grid.attach(input_label, 0, 0, 1, 1)
        self.input_entry = Gtk.Entry()
        self.grid.attach(self.input_entry, 1, 0, 1, 1)
        input_browse_button = Gtk.Button(label="Browse")
        input_browse_button.set_image(Gtk.Image.new_from_icon_name("folder-open", Gtk.IconSize.BUTTON))
        input_browse_button.connect("clicked", self.browse_input_file)
        self.grid.attach(input_browse_button, 2, 0, 1, 1)

        # Output file
        output_label = Gtk.Label(label="Output File:")
        self.grid.attach(output_label, 0, 1, 1, 1)
        self.output_entry = Gtk.Entry()
        self.grid.attach(self.output_entry, 1, 1, 1, 1)
        output_browse_button = Gtk.Button(label="Browse")
        output_browse_button.set_image(Gtk.Image.new_from_icon_name("document-save", Gtk.IconSize.BUTTON))
        output_browse_button.connect("clicked", self.browse_output_file)
        self.grid.attach(output_browse_button, 2, 1, 1, 1)

        # Input format
        input_format_label = Gtk.Label(label="Input Format:")
        self.grid.attach(input_format_label, 0, 2, 1, 1)
        self.input_format_combo = Gtk.ComboBoxText()
        for format in self.input_formats:
            self.input_format_combo.append_text(format)
        self.input_format_combo.set_active(0)
        self.grid.attach(self.input_format_combo, 1, 2, 1, 1)

        # Output format
        output_format_label = Gtk.Label(label="Output Format:")
        self.grid.attach(output_format_label, 0, 3, 1, 1)
        self.output_format_combo = Gtk.ComboBoxText()
        for format in self.output_formats:
            self.output_format_combo.append_text(format)
        self.output_format_combo.set_active(0)
        self.output_format_combo.connect("changed", self.on_output_format_changed)
        self.grid.attach(self.output_format_combo, 1, 3, 1, 1)

        # CPU cores selection
        cores_label = Gtk.Label(label="CPU Cores:")
        self.grid.attach(cores_label, 0, 4, 1, 1)
        self.cores_combo = Gtk.ComboBoxText()
        max_cores = self.get_cpu_count()
        for i in range(1, max_cores + 1):
            self.cores_combo.append_text(str(i))
        self.cores_combo.set_active(max_cores - 1)  # Default to max cores
        self.grid.attach(self.cores_combo, 1, 4, 1, 1)

        # GPU information and option
        if self.detected_gpu:
            gpu_type, gpu_name = self.detected_gpu.split(":", 1)
            if gpu_type != "cpu":
                gpu_label = Gtk.Label(label=f"Detected GPU: {gpu_name}")
                self.grid.attach(gpu_label, 0, 5, 2, 1)
                self.use_gpu_checkbox = Gtk.CheckButton(label=f"Use {gpu_type.upper()} GPU")
                self.grid.attach(self.use_gpu_checkbox, 2, 5, 1, 1)
            else:
                gpu_label = Gtk.Label(label="No compatible GPU detected")
                self.grid.attach(gpu_label, 0, 5, 3, 1)
                self.use_gpu_checkbox = None
        else:
            gpu_label = Gtk.Label(label="GPU detection failed")
            self.grid.attach(gpu_label, 0, 5, 3, 1)
            self.use_gpu_checkbox = None

        # Buttons
        self.convert_button = Gtk.Button(label="Convert")
        self.convert_button.set_image(Gtk.Image.new_from_icon_name("media-playback-start", Gtk.IconSize.BUTTON))
        self.convert_button.connect("clicked", self.convert_media)
        self.grid.attach(self.convert_button, 0, 6, 1, 1)

        self.stop_button = Gtk.Button(label="Stop")
        self.stop_button.set_image(Gtk.Image.new_from_icon_name("process-stop", Gtk.IconSize.BUTTON))
        self.stop_button.connect("clicked", self.stop_conversion)
        self.stop_button.set_sensitive(False)
        self.grid.attach(self.stop_button, 1, 6, 1, 1)

        self.reset_button = Gtk.Button(label="Reset")
        self.reset_button.set_image(Gtk.Image.new_from_icon_name("edit-clear", Gtk.IconSize.BUTTON))
        self.reset_button.connect("clicked", self.reset_conversion)
        self.reset_button.set_sensitive(False)
        self.grid.attach(self.reset_button, 2, 6, 1, 1)

        # Play button
        self.play_button = Gtk.Button(label="Play Last Converted File")
        self.play_button.set_image(Gtk.Image.new_from_icon_name("media-playback-start", Gtk.IconSize.BUTTON))
        self.play_button.connect("clicked", self.play_recent_file)
        self.play_button.set_sensitive(False)
        self.grid.attach(self.play_button, 0, 7, 3, 1)

        # Progress bar
        self.progress_bar = Gtk.ProgressBar()
        self.grid.attach(self.progress_bar, 0, 8, 3, 1)

        # Progress label
        self.progress_label = Gtk.Label(label="")
        self.grid.attach(self.progress_label, 0, 9, 3, 1)

        # Log
        self.log_text = Gtk.TextView()
        self.log_text.set_editable(False)
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_hexpand(True)
        scrolled_window.set_vexpand(True)
        scrolled_window.add(self.log_text)
        self.grid.attach(scrolled_window, 0, 10, 3, 1)

        # Create a mark to keep track of the end of the log
        self.log_buffer = self.log_text.get_buffer()
        self.log_end_mark = self.log_buffer.create_mark("log_end", self.log_buffer.get_end_iter(), False)

    # The rest of the methods remain unchanged



    def get_cpu_count(self):
        try:
            return psutil.cpu_count(logical=True)  # Return logical core count
        except:
            return 1  # Default to 1 if unable to determine

    def browse_input_file(self, widget):
        dialog = Gtk.FileChooserDialog(
            title="Select Input File",
            parent=self.parent,
            action=Gtk.FileChooserAction.OPEN
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OPEN, Gtk.ResponseType.OK
        )
        
        filter_video = Gtk.FileFilter()
        filter_video.set_name("Video files")
        filter_video.add_mime_type("video/*")
        dialog.add_filter(filter_video)

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            file_path = dialog.get_filename()
            self.input_entry.set_text(file_path)
            self.detect_input_format(file_path)
        dialog.destroy()

    def browse_output_file(self, widget):
        dialog = Gtk.FileChooserDialog(
            title="Select Output File",
            parent=self.parent,
            action=Gtk.FileChooserAction.SAVE
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_SAVE, Gtk.ResponseType.OK
        )
        
        output_format = self.output_format_combo.get_active_text()
        filter_video = Gtk.FileFilter()
        filter_video.set_name(f"{output_format} files")
        filter_video.add_pattern(f"*.{output_format.lower()}")
        dialog.add_filter(filter_video)

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            file_path = dialog.get_filename()
            if not file_path.lower().endswith(f".{output_format.lower()}"):
                file_path += f".{output_format.lower()}"
            self.output_entry.set_text(file_path)
        dialog.destroy()

    def detect_input_format(self, file_path):
        _, extension = os.path.splitext(file_path)
        extension = extension.lower()

        format_map = {
            '.mkv': 'MKV',
            '.mp4': 'MP4',
            '.ts': 'TS',
            '.webm': 'WebM'
        }

        detected_format = format_map.get(extension)

        if not detected_format:
            mime_type, _ = mimetypes.guess_type(file_path)
            if mime_type:
                if 'webm' in mime_type:
                    detected_format = 'WebM'
                elif 'mp4' in mime_type:
                    detected_format = 'MP4'
                elif 'matroska' in mime_type:
                    detected_format = 'MKV'
                elif 'mpegts' in mime_type:
                    detected_format = 'TS'

        if detected_format in self.input_formats:
            index = self.input_formats.index(detected_format)
            GLib.idle_add(self.input_format_combo.set_active, index)
            GLib.idle_add(self.update_log, f"Detected input format: {detected_format}")
        else:
            GLib.idle_add(self.update_log, f"Unable to detect format for {file_path}. Please select manually.")

    def on_output_format_changed(self, widget):
        output_file = self.output_entry.get_text()
        if output_file:
            output_format = self.output_format_combo.get_active_text()
            updated_output_file = self.ensure_correct_extension(output_file, output_format)
            self.output_entry.set_text(updated_output_file)



    def run_conversion(self, input_file, output_file, input_format, output_format, cpu_cores, use_gpu):
        if not os.path.exists(input_file):
            GLib.idle_add(self.conversion_error, f"Input file does not exist: {input_file}")
            return

        command = [
            "HandBrakeCLI",
            "-i", input_file,
            "-o", output_file,
            "-q", "20",    # Constant quality
            "-B", "128",   # Audio bitrate
            "--verbose", "0"
        ]

        if self.detected_gpu:
            gpu_type, gpu_name = self.detected_gpu.split(":", 1)
            if use_gpu and gpu_type != "cpu":
                if gpu_type == "nvidia":
                    command.extend(["--enable-nvenc"])
                    GLib.idle_add(self.update_log, f"Using NVIDIA GPU ({gpu_name}) for encoding.")
                elif gpu_type == "amd":
                    command.extend(["--enable-vce"])
                    GLib.idle_add(self.update_log, f"Using AMD GPU ({gpu_name}) for encoding.")
            else:
                GLib.idle_add(self.update_log, "Using CPU for encoding.")
        else:
            GLib.idle_add(self.update_log, "GPU detection failed. Using CPU for encoding.")

        if output_format == "WebM":
            command.extend(["-e", "VP9"])  # Use VP9 for WebM
        elif output_format in ["MP4", "MKV"]:
            command.extend(["-e", "x264"])  # Use x264 for MP4 and MKV

        GLib.idle_add(self.update_log, f"Running command: {' '.join(command)}")

        self.on_conversion_start()  # Set the start time and update UI state

        try:
            self.process = psutil.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, bufsize=1)
            self.is_converting = True
            
            self.set_cpu_affinity(cpu_cores)

            while self.is_converting:
                line = self.process.stdout.readline()
                if not line:
                    break
                GLib.idle_add(self.update_progress, line.strip())

                if self.process.is_running():
                    cpu_percent = self.process.cpu_percent(interval=1)
                    num_threads = self.process.num_threads()
                    actual_cores = len(self.process.cpu_affinity())
                    GLib.idle_add(self.update_log, f"CPU Usage: {cpu_percent}%, Assigned Cores: {actual_cores}, HandBrake Threads: {num_threads}")

            if self.is_converting:  # If we exited the loop normally
                self.process.wait()
                if self.process.returncode == 0:
                    GLib.idle_add(self.conversion_completed)
                else:
                    error_message = f"Conversion failed with return code {self.process.returncode}"
                    GLib.idle_add(self.conversion_error, error_message)
            else:
                GLib.idle_add(self.update_log, "Conversion stopped by user")

        except Exception as e:
            GLib.idle_add(self.conversion_error, f"Error during conversion: {str(e)}")
        finally:
            self.is_converting = False
            if self.process:
                try:
                    self.process.terminate()
                    self.process.wait(timeout=5)
                except:
                    pass
            self.process = None
            GLib.idle_add(self.update_log, "Conversion process finished")

    def convert_media(self, widget):
        if not self.check_handbrake_cli():
            return

        input_file = self.input_entry.get_text()
        output_file = self.output_entry.get_text()
        input_format = self.input_format_combo.get_active_text()
        output_format = self.output_format_combo.get_active_text()
        cpu_cores = int(self.cores_combo.get_active_text())
        
        # Check if use_gpu_checkbox is not None
        use_gpu = self.use_gpu_checkbox and self.use_gpu_checkbox.get_active()

        # Update the output file extension based on the selected format
        output_file = self.ensure_correct_extension(output_file, output_format)
        self.output_entry.set_text(output_file)

        if not input_file or not output_file:
            self.update_log("Please select both input and output files.")
            return

        GLib.idle_add(self.convert_button.set_sensitive, False)
        GLib.idle_add(self.stop_button.set_sensitive, True)
        GLib.idle_add(self.reset_button.set_sensitive, False)
        GLib.idle_add(self.progress_bar.set_fraction, 0.0)
        GLib.idle_add(self.progress_label.set_text, "0%")

        self.conversion_thread = threading.Thread(
            target=self.run_conversion,
            args=(input_file, output_file, input_format, output_format, cpu_cores, use_gpu)
        )
        self.conversion_thread.start()



    def get_encoder_settings(self, output_format):
        gpu_type = self.detect_gpu()
        encoder = self.get_video_encoder(gpu_type, output_format)
        return encoder

    def detect_gpu(self):
        try:
            # Check for NVIDIA GPU
            nvidia_smi = subprocess.run(["nvidia-smi", "-L"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            if nvidia_smi.returncode == 0:
                gpu_name = nvidia_smi.stdout.split(":")[1].split("(")[0].strip()
                return f"nvidia:{gpu_name}"
            
            # Check for AMD GPU
            amdgpu_info = subprocess.run(["lspci", "-v"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            if "AMD" in amdgpu_info.stdout and "VGA" in amdgpu_info.stdout:
                for line in amdgpu_info.stdout.splitlines():
                    if "AMD" in line and "VGA" in line:
                        gpu_name = line.split(":")[2].strip()
                        return f"amd:{gpu_name}"
            
            # If no specific GPU is detected, assume CPU only
            return "cpu:No GPU detected"
        except Exception:
            return "cpu:No GPU detected"

    def get_video_encoder(self, gpu_type, output_format):
        if gpu_type == "nvidia":
            return "nvenc_h264" if output_format.lower() == "mp4" else "nvenc_h265"
        elif gpu_type == "amd":
            return "vce_h264" if output_format.lower() == "mp4" else "vce_h265"
        else:
            return "x264" if output_format.lower() == "mp4" else "x265"

    def stop_conversion(self, widget):
        if self.is_converting and self.process:
            try:
                self.is_converting = False
                self.process.terminate()
                try:
                    self.process.wait(timeout=5)
                except psutil.TimeoutExpired:
                    self.process.kill()
                    
                GLib.idle_add(self.update_log, "Conversion stopped by user")
            except Exception as e:
                GLib.idle_add(self.update_log, f"Error stopping conversion: {str(e)}")
        else:
            GLib.idle_add(self.update_log, "No active conversion to stop")

    def reset_conversion(self, widget=None):
        GLib.idle_add(self.convert_button.set_sensitive, True)
        GLib.idle_add(self.stop_button.set_sensitive, False)
        GLib.idle_add(self.reset_button.set_sensitive, False)
        GLib.idle_add(self.progress_bar.set_fraction, 0.0)
        GLib.idle_add(self.progress_label.set_text, "")
        GLib.idle_add(self.log_buffer.set_text, "", -1)
        self.update_ui_state(False)  # Ensure all UI elements are enabled

    def enable_ui_elements(self):
        GLib.idle_add(self.convert_button.set_sensitive, True)
        GLib.idle_add(self.input_entry.set_sensitive, True)
        GLib.idle_add(self.output_entry.set_sensitive, True)
        GLib.idle_add(self.input_format_combo.set_sensitive, True)
        GLib.idle_add(self.output_format_combo.set_sensitive, True)
        GLib.idle_add(self.cores_combo.set_sensitive, True)
        GLib.idle_add(self.play_button.set_sensitive, self.recent_output_file is not None)

    def on_tab_switch(self, widget, event):
        # Assuming widget is the notebook or tab control
        if widget.get_current_page() == self.video_converter_tab_index:  # Check if the current tab is the video converter tab
            self.enable_ui_elements()

    def update_progress(self, line):
        GLib.idle_add(self.update_log, line)
        progress_match = re.search(r'(\d+\.\d+) %', line)
        if progress_match:
            progress_float = float(progress_match.group(1))
            GLib.idle_add(self.progress_bar.set_fraction, progress_float / 100)
            self.update_progress_samples(progress_float / 100)
            eta = self.estimate_remaining_time()
            current_size = self.get_file_size(self.output_entry.get_text())
            projected_size = self.estimate_final_size(progress_float / 100, current_size)
            
            progress_text = f"{progress_float:.2f}%"
            
            if eta is not None:
                eta_formatted = self.format_time(eta)
                progress_text += f" (ETA: {eta_formatted})"
            
            progress_text += f" Current Size: {self.format_size(current_size)}"
            
            if projected_size is not None:
                progress_text += f" Projected Size: {self.format_size(projected_size)}"
            
            GLib.idle_add(self.progress_label.set_text, progress_text)

    def conversion_completed(self):
        self.recent_output_file = self.output_entry.get_text()  # Update the recent file
        GLib.idle_add(self.update_log, "Conversion completed successfully")
        GLib.idle_add(self.progress_bar.set_fraction, 1.0)
        GLib.idle_add(self.progress_label.set_text, "100%")
        GLib.idle_add(self.convert_button.set_sensitive, True)
        GLib.idle_add(self.stop_button.set_sensitive, False)
        GLib.idle_add(self.reset_button.set_sensitive, True)
        GLib.idle_add(self.play_button.set_sensitive, True)  # Enable the play button

    def conversion_error(self, message):
        GLib.idle_add(self.update_log, f"Error: {message}")
        GLib.idle_add(self.convert_button.set_sensitive, True)
        GLib.idle_add(self.stop_button.set_sensitive, False)
        GLib.idle_add(self.reset_button.set_sensitive, True)
        GLib.idle_add(self.progress_bar.set_fraction, 0.0)
        GLib.idle_add(self.progress_label.set_text, "Error")

    def update_log(self, message):
        buffer = self.log_buffer
        GLib.idle_add(buffer.insert, buffer.get_end_iter(), message + "\n")
        GLib.idle_add(self.log_text.scroll_to_mark, self.log_end_mark, 0.0, False, 0.0, 0.0)

    def set_cpu_affinity(self, core_count):
        if self.process:
            try:
                cores_to_use = list(range(core_count))
                self.process.cpu_affinity(cores_to_use)
                actual_cores = len(self.process.cpu_affinity())
                GLib.idle_add(self.update_log, f"CPU affinity set to {actual_cores} cores (Requested: {core_count})")
                
                if actual_cores != core_count:
                    GLib.idle_add(self.update_log, "Warning: Actual core count differs from requested. This may be due to system limitations.")
                
                GLib.idle_add(self.update_log, f"Using CPU cores: {cores_to_use}")
            except Exception as e:
                GLib.idle_add(self.update_log, f"Error setting CPU affinity: {str(e)}")
                GLib.idle_add(self.update_log, "Conversion will proceed without CPU affinity restrictions.")

    def play_recent_file(self, widget):
        if self.recent_output_file and os.path.exists(self.recent_output_file):
            try:
                if os.name == 'nt':  # For Windows
                    os.startfile(self.recent_output_file)
                elif os.name == 'posix':  # For Linux, macOS
                    subprocess.call(('xdg-open', self.recent_output_file))
                GLib.idle_add(self.update_log, f"Playing file: {self.recent_output_file}")
            except Exception as e:
                GLib.idle_add(self.update_log, f"Error playing file: {str(e)}")
        else:
            GLib.idle_add(self.update_log, "No recent file to play or file does not exist.")

    def get_widget(self):
        return self.grid

    def update_ui_state(self, is_converting):
        GLib.idle_add(self.convert_button.set_sensitive, not is_converting)
        GLib.idle_add(self.stop_button.set_sensitive, is_converting)
        GLib.idle_add(self.reset_button.set_sensitive, not is_converting)
        GLib.idle_add(self.input_entry.set_sensitive, not is_converting)
        GLib.idle_add(self.output_entry.set_sensitive, not is_converting)
        GLib.idle_add(self.input_format_combo.set_sensitive, not is_converting)
        GLib.idle_add(self.output_format_combo.set_sensitive, not is_converting)
        GLib.idle_add(self.cores_combo.set_sensitive, not is_converting)

    def get_conversion_settings(self):
        return {
            'input_file': self.input_entry.get_text(),
            'output_file': self.output_entry.get_text(),
            'input_format': self.input_format_combo.get_active_text(),
            'output_format': self.output_format_combo.get_active_text(),
            'cpu_cores': int(self.cores_combo.get_active_text())
        }

    def set_conversion_settings(self, settings):
        GLib.idle_add(self.input_entry.set_text, settings.get('input_file', ''))
        GLib.idle_add(self.output_entry.set_text, settings.get('output_file', ''))
        self.set_combo_active_text(self.input_format_combo, settings.get('input_format'))
        self.set_combo_active_text(self.output_format_combo, settings.get('output_format'))
        self.set_combo_active_text(self.cores_combo, str(settings.get('cpu_cores', 1)))

    def set_combo_active_text(self, combo, text):
        model = combo.get_model()
        for i, item in enumerate(model):
            if item[0] == text:
                GLib.idle_add(combo.set_active, i)
                break

    def clear_log(self):
        GLib.idle_add(self.log_buffer.set_text, "", -1)

    def get_log_content(self):
        buffer = self.log_buffer
        return buffer.get_text(buffer.get_start_iter(), buffer.get_end_iter(), True)

    def save_log_to_file(self, filename):
        log_content = self.get_log_content()
        try:
            with open(filename, 'w') as f:
                f.write(log_content)
            GLib.idle_add(self.update_log, f"Log saved to {filename}")
        except Exception as e:
            GLib.idle_add(self.update_log, f"Error saving log: {str(e)}")

    def is_conversion_in_progress(self):
        return self.is_converting

    def get_progress(self):
        return self.progress_bar.get_fraction()

    def estimate_remaining_time(self):
        if self.progress_samples:
            elapsed_time = time.time() - self.start_time
            progress = sum(self.progress_samples) / len(self.progress_samples)
            if progress > 0:
                total_estimated_time = elapsed_time / progress
                remaining_time = total_estimated_time - elapsed_time
                return int(remaining_time)
        return None

    def estimate_final_size(self, progress, current_size):
        if progress > 0:
            projected_size = current_size / progress
            return projected_size
        return None

    def get_file_size(self, file_path):
        if os.path.exists(file_path):
            return os.path.getsize(file_path)
        return 0

    def format_size(self, size):
        if size < 1024:
            return f"{size} B"
        elif size < 1024 ** 2:
            return f"{size / 1024:.2f} KB"
        elif size < 1024 ** 3:
            return f"{size / 1024 ** 2:.2f} MB"
        elif size < 1024 ** 4:
            return f"{size / 1024 ** 3:.2f} GB"
        else:
            return f"{size / 1024 ** 4:.2f} TB"

    def update_progress_samples(self, progress):
        self.progress_samples.append(progress)
        if len(self.progress_samples) > 10:  # Keep the last 10 samples
            self.progress_samples.pop(0)

    def format_time(self, seconds):
        minutes, secs = divmod(seconds, 60)
        hours, minutes = divmod(minutes, 60)
        return f"{hours:02d}:{minutes:02d}:{secs:02d}"

    def update_progress_with_eta(self, progress):
        GLib.idle_add(self.progress_bar.set_fraction, progress)
        percentage = f"{progress * 100:.2f}%"
        remaining_time = self.estimate_remaining_time(progress)
        if remaining_time is not None:
            eta = self.format_time(remaining_time)
            GLib.idle_add(self.progress_label.set_text, f"{percentage} (ETA: {eta})")
        else:
            GLib.idle_add(self.progress_label.set_text, percentage)

    def on_conversion_start(self):
        # Reset timing and progress variables
        self.start_time = time.time()
        self.progress_samples = []
        self.current_file_size = 0

        # Update UI state
        GLib.idle_add(self.update_ui_state, True)

        # Clear the log and add initial message
        GLib.idle_add(self.clear_log)
        GLib.idle_add(self.update_log, "Conversion started.")

        # Reset progress bar and label
        GLib.idle_add(self.progress_bar.set_fraction, 0.0)
        GLib.idle_add(self.progress_label.set_text, "0%")

        # Disable convert button and enable stop button
        GLib.idle_add(self.convert_button.set_sensitive, False)
        GLib.idle_add(self.stop_button.set_sensitive, True)
        GLib.idle_add(self.reset_button.set_sensitive, False)

        # Disable input fields
        GLib.idle_add(self.input_entry.set_sensitive, False)
        GLib.idle_add(self.output_entry.set_sensitive, False)
        GLib.idle_add(self.input_format_combo.set_sensitive, False)
        GLib.idle_add(self.output_format_combo.set_sensitive, False)
        GLib.idle_add(self.cores_combo.set_sensitive, False)

        # If you have a play button for the last converted file, disable it
        if hasattr(self, 'play_button'):
            GLib.idle_add(self.play_button.set_sensitive, False)

        # If you're using a tray icon, update its status
        if hasattr(self, 'update_tray_status'):
            GLib.idle_add(self.update_tray_status, True)

        # Start monitoring file size if applicable
        if hasattr(self, 'monitor_file_size'):
            threading.Thread(target=self.monitor_file_size, daemon=True).start()

        # Start updating tray info if applicable
        if hasattr(self, 'update_tray_info'):
            threading.Thread(target=self.update_tray_info, daemon=True).start()

        # If you have any audio visualization, reset and start it
        if hasattr(self, 'reset_audio_visualizer'):
            GLib.idle_add(self.reset_audio_visualizer)

        # Log the conversion settings
        settings = self.get_conversion_settings()
        GLib.idle_add(self.update_log, "Conversion settings:")
        for key, value in settings.items():
            GLib.idle_add(self.update_log, f"  {key}: {value}")

        # If you're using CPU affinity, log it
        if hasattr(self, 'set_cpu_affinity'):
            cpu_cores = int(self.cores_combo.get_active_text())
            GLib.idle_add(self.update_log, f"Setting CPU affinity to {cpu_cores} cores")

        # Start any additional monitoring or background tasks here

    def on_conversion_end(self):
        self.update_ui_state(False)
        elapsed_time = time.time() - self.start_time
        self.update_log(f"Conversion ended. Total time: {self.format_time(int(elapsed_time))}")
        self.conversion_completed()

    def check_handbrake_cli(self):
        try:
            subprocess.run(["HandBrakeCLI", "--version"], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            return True
        except subprocess.CalledProcessError:
            self.update_log("Error: HandBrakeCLI not found. Please install HandBrake.")
            return False
        except Exception as e:
            self.update_log(f"Error checking HandBrakeCLI: {str(e)}")
            return False

    def ensure_correct_extension(self, file_path, output_format):
        base, ext = os.path.splitext(file_path)
        new_ext = f".{output_format.lower()}"
        if ext.lower() != new_ext:
            file_path = base + new_ext
        return file_path




class ScreenRecorder(Gtk.Window):
    def __init__(self):
        super().__init__(title="Seekers Eye Of The Storm Recorder")
        self.copy_to_clipboard = False
        self.save_to_file = False
        self.connect("delete-event", self.on_window_delete_event)
        self.current_session_screenshots = []

        # ... (rest of your initialization code)




        # Save a reference to the main window
        self.main_window = self

        self.output_directory = os.path.join(os.path.expanduser('~'), 'Videos')
        self.temp_directory = os.path.join(self.output_directory, 'temp')
        os.makedirs(self.output_directory, exist_ok=True)
        os.makedirs(self.temp_directory, exist_ok=True)

        self.use_custom_save = False
        self.custom_save_location = self.output_directory  # Default to the output directory

        self.is_recording = False
        self.is_paused = False
        self.start_time = 0
        self.output_filename = None
        self.ffmpeg_process = None
        self.file_size = 0
        self.custom_region_start_x = None
        self.custom_region_start_y = None
        self.custom_region_end_x = None
        self.custom_region_end_y = None


        # ... other initializations ...
        self.recording_start_time = None
        self.scheduled_end_time = None

        self.is_custom_region = False

        self.recording_region = None
        self.completed_recordings = []
        self.recent_recording_menu_item = None
        self.camera_window = None
        self.camera_window_id = None

        self.image_size_percentage = 25  # Default to 25%

        self.is_camera_on_top = False
        self.is_webcam_overlay = False  # New variable for webcam overlay
        self.webcam_position = "top-right"  # Default position
        self.webcam_resolution = "640x480"  # Default webcam resolution
        self.is_journal_mode = False  # Initialize journaling mode
        self.is_keep_mode = False  # Add missing initialization

        self.timer_active = False
        self.timer_seconds = 0
        self.timer_thread = None
        self.timer_completed = False

        self.webcam_size_percentage = 20

        self.scheduled_recordings = []
        self.scheduled_end_time = None  # Initialize the scheduled_end_time attribute
        #self.create_tray_icon()

        self.webcam_positions = ["top-left", "top-right", "bottom-left", "bottom-right", "center"]
        self.completed_scheduled_recordings = []
        self.monitors = self.get_monitors()


        self.volume_update_timeout = GLib.timeout_add(1000, self.update_volume_mic_sliders)
        self.tray_update_timeout = GLib.timeout_add(1000, self.update_tray_tooltip)


        # Add this code to set a system icon
        try:
            icon_theme = Gtk.IconTheme.get_default()
            icon = icon_theme.load_icon("system-run", 48, 0)
            self.set_icon(icon)
        except Exception as e:
            print(f"Error setting system icon: {e}")



        Gst.init(None)

        self.monitors = self.get_monitors()  # Assuming get_monitors() is a method that returns a list of monitors
        self.preview_active = False

        if self.monitors:
            self.selected_preview_monitor = self.monitors[0]  # Default to first monitor (dictionary)
        else:
            self.selected_preview_monitor = None  # Handle case where no monitors are found

        GLib.timeout_add(1000, self.update_volume_mic_sliders)  # Update every second


        GLib.timeout_add(1000, self.update_video_stats_display)  # Update every second



        self.preview_thread = None
        self.preview_active = False
        self.preview_pixbuf = None
        self.preview_lock = threading.Lock()

        # Other initialization code
        self.preview_monitor_combo = self.initialize_preview_monitor_combo()  # Assuming this initializes the combo box

        # Now you can safely use self.monitors
        self.selected_preview_monitor = self.monitors[0] if self.monitors else None

        atexit.register(self.cleanup_on_exit)

        signal.signal(signal.SIGINT, self.cleanup_on_exit)
        signal.signal(signal.SIGTERM, self.cleanup_on_exit)

        notebook = Gtk.Notebook()
        notebook.set_tab_pos(Gtk.PositionType.LEFT)  # Set the tabs to be on the left

        # Function to create a tab label with an icon
        def create_tab_label(icon_name, label_text):
            icon = Gtk.Image.new_from_icon_name(icon_name, Gtk.IconSize.MENU)
            label = Gtk.Label(label_text)
            box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
            box.pack_start(icon, False, False, 0)
            box.pack_start(label, False, False, 0)
            box.show_all()
            return box

        # Controls & Streaming tab
        controls_camera_streaming_grid = self.create_controls_camera_streaming_grid()
        notebook.append_page(controls_camera_streaming_grid, 
                             create_tab_label("media-playback-start", "Controls & Streaming Tab"))

        # Overlay Settings tab
        #overlay_settings_grid = self.create_overlay_settings_tab()
        #notebook.append_page(overlay_settings_grid, 
                             #create_tab_label("preferences-desktop-display", "Overlay Settings"))

        # Settings Tab
        settings_grid = self.create_settings_grid()
        notebook.append_page(settings_grid, 
                             create_tab_label("preferences-system", "Settings Tab"))

        # Camera Settings tab
        camera_settings_grid = self.create_camera_settings_grid()
        notebook.append_page(camera_settings_grid, 
                             create_tab_label("camera-web", "Camera Settings Tab"))

        # Scheduler Tab
        scheduler_grid = self.create_scheduler_tab()
        notebook.append_page(scheduler_grid, 
                             create_tab_label("x-office-calendar", "Scheduler Tab"))

        # Preview tab
        preview_grid = self.create_preview_tab()
        notebook.append_page(preview_grid, 
                             create_tab_label("video-display", "Preview Tab"))

        # Screenshot Tool tab
        screenshot_grid = self.create_screenshot_tab()
        notebook.append_page(screenshot_grid, 
                             create_tab_label("camera-photo", "Screenshot Tool Tab"))

        # Video Converter tab
        converter_grid = self.create_converter_tab()
        notebook.append_page(converter_grid, 
                             create_tab_label("video-x-generic", "Video Converter Tab"))


        # About Us tab
        about_page = self.create_about_page()
        notebook.append_page(about_page, 
                             create_tab_label("help-about", "About Us"))

        self.add(notebook)

        self.show_all()
        self.create_tray_icon()
        self.update_tray_tooltip()  # Add this line to initialize the tooltip with the current settings

        self.preview_active = False
        self.preview_pixbuf = None
        self.preview_lock = threading.Lock()

        # Connect signal handlers for the combo boxes
        self.recording_size_combo.connect("changed", self.on_combobox_changed)
        self.video_codec_combo.connect("changed", self.on_combobox_changed)
        self.audio_codec_combo.connect("changed", self.on_combobox_changed)
        self.audio_input_combo.connect("changed", self.on_combobox_changed)
        self.secondary_audio_input_combo.connect("changed", self.on_combobox_changed)
        self.recording_area_combo.connect("changed", self.on_combobox_changed)
        self.output_format_combo.connect("changed", self.on_combobox_changed)
        self.active_window_combo.connect("changed", self.on_combobox_changed)

    def create_controls_camera_streaming_grid(self):
        grid = Gtk.Grid()
        grid.set_column_spacing(10)
        grid.set_row_spacing(10)

        self.controls_record_button = Gtk.Button(label="Record")
        record_icon = Gtk.Image.new_from_icon_name("media-record", Gtk.IconSize.BUTTON)
        self.controls_record_button.set_image(record_icon)
        self.controls_record_button.set_always_show_image(True)
        self.controls_record_button.connect("clicked", self.start_recording)
        grid.attach(self.controls_record_button, 0, 0, 1, 1)

        self.stop_button = Gtk.Button(label="Stop")
        stop_icon = Gtk.Image.new_from_icon_name("media-playback-stop", Gtk.IconSize.BUTTON)
        self.stop_button.set_image(stop_icon)
        self.stop_button.set_always_show_image(True)
        self.stop_button.connect("clicked", self.stop_recording)
        self.stop_button.set_sensitive(False)
        grid.attach(self.stop_button, 1, 0, 1, 1)

        self.pause_button = Gtk.Button(label="Pause")
        pause_icon = Gtk.Image.new_from_icon_name("media-playback-pause", Gtk.IconSize.BUTTON)
        self.pause_button.set_image(pause_icon)
        self.pause_button.set_always_show_image(True)
        self.pause_button.connect("clicked", self.pause_recording)
        self.pause_button.set_sensitive(False)
        grid.attach(self.pause_button, 0, 1, 1, 1)

        self.resume_button = Gtk.Button(label="Resume")
        resume_icon = Gtk.Image.new_from_icon_name("media-playback-start", Gtk.IconSize.BUTTON)
        self.resume_button.set_image(resume_icon)
        self.resume_button.set_always_show_image(True)
        self.resume_button.connect("clicked", self.resume_recording)
        self.resume_button.set_sensitive(False)
        grid.attach(self.resume_button, 1, 1, 1, 1)

        self.status_label = Gtk.Label(label="Press Record to start recording.")
        self.status_label.set_justify(Gtk.Justification.CENTER)
        self.status_label.set_halign(Gtk.Align.CENTER)
        grid.attach(self.status_label, 0, 2, 2, 1)

        self.play_recent_button = Gtk.Button(label="Play Recent Recording")
        recent_recording_icon = Gtk.Image.new_from_icon_name("media-playback-start", Gtk.IconSize.BUTTON)
        self.play_recent_button.set_image(recent_recording_icon)
        self.play_recent_button.set_always_show_image(True)
        self.play_recent_button.connect("clicked", self.open_recent_recording)
        grid.attach(self.play_recent_button, 0, 3, 1, 1)

        self.trim_button = Gtk.Button(label="Trim Recent Recording")
        trim_icon = Gtk.Image.new_from_icon_name("edit-cut", Gtk.IconSize.BUTTON)
        self.trim_button.set_image(trim_icon)
        self.trim_button.set_always_show_image(True)
        self.trim_button.connect("clicked", self.trim_video)
        grid.attach(self.trim_button, 0, 4, 1, 1)


        # Add the new convert button
        self.convert_button = Gtk.Button(label="Convert Recent Recording")
        convert_icon = Gtk.Image.new_from_icon_name("video-x-generic", Gtk.IconSize.BUTTON)
        self.convert_button.set_image(convert_icon)
        self.convert_button.set_always_show_image(True)
        self.convert_button.connect("clicked", self.convert_recent_recording)
        grid.attach(self.convert_button, 1, 4, 1, 1)

        self.recent_recording_info_label = Gtk.Label(label="No recent recording")
        self.recent_recording_info_label.set_justify(Gtk.Justification.CENTER)
        self.recent_recording_info_label.set_halign(Gtk.Align.CENTER)
        grid.attach(self.recent_recording_info_label, 1, 3, 1, 1)

        self.file_size_label = Gtk.Label(label="")
        self.file_size_label.set_justify(Gtk.Justification.CENTER)
        self.file_size_label.set_halign(Gtk.Align.CENTER)
        grid.attach(self.file_size_label, 0, 4, 2, 1)

        self.webcam_overlay_checkbox = Gtk.CheckButton(label="Enable Webcam Overlay")
        grid.attach(self.webcam_overlay_checkbox, 0, 9, 1, 1)
        self.webcam_overlay_checkbox.connect("toggled", self.on_webcam_overlay_toggled)

        self.webcam_position_label = Gtk.Label(label="Select Webcam Position:")
        grid.attach(self.webcam_position_label, 0, 10, 1, 1)
        self.webcam_position_combo = Gtk.ComboBoxText()
        for position in self.webcam_positions:
            self.webcam_position_combo.append_text(position)
        self.webcam_position_combo.set_active(1)  # Default to top-right
        self.webcam_position_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.webcam_position_combo, 1, 10, 1, 1)

        self.preview_webcam_button = Gtk.Button(label="Show Webcam Preview")
        self.preview_webcam_button.connect("clicked", self.toggle_webcam_preview)
        grid.attach(self.preview_webcam_button, 0, 17, 2, 1)

        self.streaming_label = Gtk.Label(label="Streaming Options:")
        grid.attach(self.streaming_label, 0, 12, 1, 1)
        self.streaming_combo = Gtk.ComboBoxText()
        streaming_options = ["None", "Twitch", "YouTube"]
        for option in streaming_options:
            self.streaming_combo.append_text(option)
        self.streaming_combo.set_active(0)
        self.streaming_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.streaming_combo, 1, 12, 1, 1)

        self.streaming_key_label = Gtk.Label(label="Streaming Key:")
        grid.attach(self.streaming_key_label, 0, 13, 1, 1)
        self.streaming_key_entry = Gtk.Entry()
        grid.attach(self.streaming_key_entry, 1, 13, 1, 1)

        self.audio_visualizer = AudioVisualizer()
        grid.attach(self.audio_visualizer, 0, 5, 2, 1)

        self.webcam_size_label = Gtk.Label(label="Webcam Overlay Size:")
        grid.attach(self.webcam_size_label, 0, 11, 1, 1)

        self.webcam_size_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 10, 100, 5)
        self.webcam_size_scale.set_value(20)  # Default to 20% of screen size
        self.webcam_size_scale.connect("value-changed", self.on_webcam_size_changed)
        grid.attach(self.webcam_size_scale, 1, 11, 1, 1)

        volume_label = Gtk.Label(label="Volume:")
        grid.attach(volume_label, 0, 14, 1, 1)


        self.volume_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 0, 100, 1)
        self.volume_scale.set_value(100)  # Default to 100%
        self.volume_scale.connect("value-changed", self.on_volume_changed)
        grid.attach(self.volume_scale, 1, 14, 1, 1)

        mic_label = Gtk.Label(label="Microphone:")
        grid.attach(mic_label, 0, 15, 1, 1)

        self.mic_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 0, 100, 1)
        self.mic_scale.set_value(100)  # Default to 100%
        self.mic_scale.connect("value-changed", self.on_mic_changed)
        grid.attach(self.mic_scale, 1, 15, 1, 1)

        # Add video stats labels horizontally
        stats_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=20)
        
        # Create labels with static text and dynamic value labels
        self.create_stat_label_pair(stats_box, "Size:", "N/A")
        self.create_stat_label_pair(stats_box, "Duration:", "N/A")
        self.create_stat_label_pair(stats_box, "Bitrate:", "N/A")
        self.create_stat_label_pair(stats_box, "FPS:", "N/A")
        self.create_stat_label_pair(stats_box, "Video:", "N/A")
        self.create_stat_label_pair(stats_box, "Audio:", "N/A")
        self.create_stat_label_pair(stats_box, "Res:", "N/A")
        
        grid.attach(stats_box, 0, 16, 2, 1)

        return grid

    def create_settings_grid(self):
        grid = Gtk.Grid()
        grid.set_column_spacing(10)
        grid.set_row_spacing(10)

        self.monitor_label = Gtk.Label(label="Select Monitor:")
        grid.attach(self.monitor_label, 0, 0, 1, 1)
        self.monitor_combo = Gtk.ComboBoxText()
        self.monitors = self.get_available_monitors()
        for monitor in self.monitors:
            self.monitor_combo.append_text(monitor['name'])
        self.monitor_combo.set_active(0)
        grid.attach(self.monitor_combo, 1, 0, 1, 1)

        self.audio_input_configs = ["Primary Only", "Secondary Only"]
        self.audio_input_config_label = Gtk.Label(label="Select Audio Input Configuration:")
        grid.attach(self.audio_input_config_label, 0, 1, 1, 1)
        self.audio_input_config_combo = Gtk.ComboBoxText()
        for config in self.audio_input_configs:
            self.audio_input_config_combo.append_text(config)
        self.audio_input_config_combo.set_active(0)
        self.audio_input_config_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.audio_input_config_combo, 1, 1, 1, 1)

        self.recording_sizes = self.get_available_resolutions()
        if not self.recording_sizes:
            self.recording_sizes = [
                ("1920x1080", "1920x1080"),
                ("1280x720", "1280x720"),
                ("640x480", "640x480"),
                ("2560x1440", "2560x1440"),
                ("3840x2160", "3840x2160")
            ]
        self.recording_size_label = Gtk.Label(label="Select Recording Size:")
        grid.attach(self.recording_size_label, 0, 2, 1, 1)
        self.recording_size_combo = Gtk.ComboBoxText()
        for size in self.recording_sizes:
            self.recording_size_combo.append_text(size[0])
        self.recording_size_combo.set_active(0)
        self.recording_size_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.recording_size_combo, 1, 2, 1, 1)

        self.video_codec_label = Gtk.Label(label="Select Video Codec:")
        grid.attach(self.video_codec_label, 0, 3, 1, 1)
        self.video_codec_combo = Gtk.ComboBoxText()
        self.video_codecs = ["libx264", "libvpx-vp9", "libx265", "libvpx"]
        for codec in self.video_codecs:
            self.video_codec_combo.append_text(codec)
        self.video_codec_combo.set_active(0)
        self.video_codec_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.video_codec_combo, 1, 3, 1, 1)

        self.audio_codec_label = Gtk.Label(label="Select Audio Codec:")
        grid.attach(self.audio_codec_label, 0, 4, 1, 1)
        self.audio_codec_combo = Gtk.ComboBoxText()
        self.audio_codecs = ["aac", "mp3", "opus"]
        for codec in self.audio_codecs:
            self.audio_codec_combo.append_text(codec)
        self.audio_codec_combo.set_active(0)
        self.audio_codec_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.audio_codec_combo, 1, 4, 1, 1)

        self.audio_input_label = Gtk.Label(label="Select Primary Audio Input:")
        grid.attach(self.audio_input_label, 0, 5, 1, 1)
        self.audio_input_combo = Gtk.ComboBoxText()
        self.audio_inputs = self.get_available_audio_inputs()
        for input_device in self.audio_inputs:
            self.audio_input_combo.append_text(input_device)
        self.audio_input_combo.set_active(0)
        self.audio_input_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.audio_input_combo, 1, 5, 1, 1)

        self.secondary_audio_input_label = Gtk.Label(label="Select Secondary Audio Input:")
        grid.attach(self.secondary_audio_input_label, 0, 6, 1, 1)
        self.secondary_audio_input_combo = Gtk.ComboBoxText()
        self.secondary_audio_inputs = self.get_available_audio_inputs()
        for input_device in self.secondary_audio_inputs:
            self.secondary_audio_input_combo.append_text(input_device)
        self.secondary_audio_input_combo.set_active(0)
        self.secondary_audio_input_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.secondary_audio_input_combo, 1, 6, 1, 1)

        self.recording_area_label = Gtk.Label(label="Select Recording Area:")
        grid.attach(self.recording_area_label, 0, 7, 1, 1)
        self.recording_area_combo = Gtk.ComboBoxText()
        self.recording_areas = ["Full Screen", "Camera Only", "Active Window", "Custom Region"]
        for area in self.recording_areas:
            self.recording_area_combo.append_text(area)
        self.recording_area_combo.set_active(0)
        self.recording_area_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.recording_area_combo, 1, 7, 1, 1)

        self.output_format_label = Gtk.Label(label="Select Output Format:")
        grid.attach(self.output_format_label, 0, 8, 1, 1)
        self.output_format_combo = Gtk.ComboBoxText()
        output_formats = ["mkv", "mp4", "webm"]
        for format in output_formats:
            self.output_format_combo.append_text(format)
        self.output_format_combo.set_active(0)
        self.output_format_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.output_format_combo, 1, 8, 1, 1)

        self.active_window_label = Gtk.Label(label="Select Active Window:")
        grid.attach(self.active_window_label, 0, 9, 1, 1)
        self.active_window_combo = Gtk.ComboBoxText()
        self.update_active_windows()
        self.active_window_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.active_window_combo, 1, 9, 1, 1)

        self.settings_record_button = Gtk.Button(label="Record")
        record_icon = Gtk.Image.new_from_icon_name("media-record", Gtk.IconSize.BUTTON)
        self.settings_record_button.set_image(record_icon)
        self.settings_record_button.set_always_show_image(True)
        self.settings_record_button.connect("clicked", self.start_recording)
        grid.attach(self.settings_record_button, 0, 10, 1, 1)

        self.stop_button_settings = Gtk.Button(label="Stop")
        stop_icon = Gtk.Image.new_from_icon_name("media-playback-stop", Gtk.IconSize.BUTTON)
        self.stop_button_settings.set_image(stop_icon)
        self.stop_button_settings.set_always_show_image(True)
        self.stop_button_settings.connect("clicked", self.stop_recording)
        self.stop_button_settings.set_sensitive(False)
        grid.attach(self.stop_button_settings, 1, 10, 1, 1)

        self.refresh_windows_button = Gtk.Button(label="Refresh Windows")
        refresh_icon = Gtk.Image.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON)
        self.refresh_windows_button.set_image(refresh_icon)
        self.refresh_windows_button.set_always_show_image(True)
        self.refresh_windows_button.connect("clicked", self.refresh_windows)
        grid.attach(self.refresh_windows_button, 0, 11, 1, 1)

        self.select_custom_region_button = Gtk.Button(label="Select Custom Region")
        custom_region_icon = Gtk.Image.new_from_icon_name("image-x-generic", Gtk.IconSize.BUTTON)
        self.select_custom_region_button.set_image(custom_region_icon)
        self.select_custom_region_button.set_always_show_image(True)
        self.select_custom_region_button.connect("clicked", self.select_custom_region)
        grid.attach(self.select_custom_region_button, 1, 11, 1, 1)

        self.journaling_mode_checkbox = Gtk.CheckButton(label="Journaling Mode")
        grid.attach(self.journaling_mode_checkbox, 1, 12, 1, 1)
        self.journaling_mode_checkbox.connect("toggled", self.on_journaling_mode_toggled)

        self.timer_checkbox = Gtk.CheckButton(label="Enable Timer")
        self.timer_checkbox.connect("toggled", self.on_timer_toggled)
        grid.attach(self.timer_checkbox, 0, 12, 1, 1)

        self.timer_label = Gtk.Label(label="Set Timer:")
        grid.attach(self.timer_label, 0, 13, 1, 1)

        self.timer_hours_combo = Gtk.ComboBoxText()
        for hour in range(24):
            self.timer_hours_combo.append_text(str(hour))
        self.timer_hours_combo.set_active(0)
        grid.attach(self.timer_hours_combo, 1, 13, 1, 1)

        self.timer_minutes_combo = Gtk.ComboBoxText()
        for minute in range(60):
            self.timer_minutes_combo.append_text(str(minute))
        self.timer_minutes_combo.set_active(0)
        grid.attach(self.timer_minutes_combo, 2, 13, 1, 1)

        self.timer_hours_combo.connect("changed", self.on_timer_changed)
        self.timer_minutes_combo.connect("changed", self.on_timer_changed)

        self.custom_save_checkbox = Gtk.CheckButton(label="Custom File Name and Location")
        self.custom_save_checkbox.connect("toggled", self.on_custom_save_toggled)
        grid.attach(self.custom_save_checkbox, 0, 14, 1, 1)

        self.custom_filename_entry = Gtk.Entry()
        self.custom_filename_entry.set_placeholder_text("Enter custom file name")
        self.custom_filename_entry.set_sensitive(False)
        grid.attach(self.custom_filename_entry, 1, 14, 1, 1)

        self.choose_location_button = Gtk.Button(label="Choose Save Location")
        self.choose_location_button.connect("clicked", self.on_choose_location_clicked)
        self.choose_location_button.set_sensitive(False)
        grid.attach(self.choose_location_button, 0, 15, 1, 1)

        self.save_location_label = Gtk.Label(label="Default save location")
        grid.attach(self.save_location_label, 1, 15, 1, 1)

        return grid

    def create_camera_settings_grid(self):
        grid = Gtk.Grid()
        grid.set_column_spacing(10)
        grid.set_row_spacing(10)

        self.available_cameras = self.get_available_cameras_v4l2()
        self.camera_label = Gtk.Label(label="Select Camera:")
        grid.attach(self.camera_label, 0, 0, 1, 1)
        self.camera_combo = Gtk.ComboBoxText()
        for camera in self.available_cameras:
            self.camera_combo.append_text(camera)
        self.camera_combo.set_active(0)
        grid.attach(self.camera_combo, 1, 0, 1, 1)

        self.camera_resolution_label = Gtk.Label(label="Select Camera Resolution:")
        grid.attach(self.camera_resolution_label, 0, 1, 1, 1)
        self.camera_resolution_combo = Gtk.ComboBoxText()
        camera_resolutions = ["480x320", "640x480", "1280x720", "1920x1080"]
        for resolution in camera_resolutions:
            self.camera_resolution_combo.append_text(resolution)
        self.camera_resolution_combo.set_active(0)
        self.camera_resolution_combo.connect("changed", self.on_combobox_changed)
        grid.attach(self.camera_resolution_combo, 1, 1, 1, 1)

        self.camera_button = Gtk.Button(label="Show Camera")
        camera_icon = Gtk.Image.new_from_icon_name("camera-photo", Gtk.IconSize.BUTTON)
        self.camera_button.set_image(camera_icon)
        self.camera_button.set_always_show_image(True)
        self.camera_button.connect("clicked", self.show_camera_window)
        grid.attach(self.camera_button, 0, 2, 1, 1)

        self.close_camera_button = Gtk.Button(label="Close Camera")
        close_camera_icon = Gtk.Image.new_from_icon_name("window-close", Gtk.IconSize.BUTTON)
        self.close_camera_button.set_image(close_camera_icon)
        self.close_camera_button.set_always_show_image(True)
        self.close_camera_button.connect("clicked", self.close_camera_window)
        grid.attach(self.close_camera_button, 1, 2, 1, 1)

        self.keep_camera_on_top_checkbox = Gtk.CheckButton(label="Keep Camera on Top")
        grid.attach(self.keep_camera_on_top_checkbox, 0, 3, 1, 1)
        self.keep_camera_on_top_checkbox.connect("toggled", self.on_keep_camera_on_top_toggled)

        return grid



    def create_screenshot_tab(self):
        print("Creating screenshot tab")
        screenshot_grid = Gtk.Grid()
        screenshot_grid.set_column_spacing(10)
        screenshot_grid.set_row_spacing(10)

        # Capture Full Screen Button
        btn_capture_full = Gtk.Button(label='Capture Full Screen')
        btn_capture_full.connect("clicked", self.capture_full_screen)
        screenshot_grid.attach(btn_capture_full, 0, 0, 1, 1)

        # Capture Current Window Button
        btn_capture_window = Gtk.Button(label='Capture Current Window')
        btn_capture_window.connect("clicked", self.capture_current_window)
        screenshot_grid.attach(btn_capture_window, 0, 1, 1, 1)

        # Capture Selected Area Button
        btn_capture_area = Gtk.Button(label='Capture Selected Area')
        btn_capture_area.connect("clicked", self.capture_selected_area)
        screenshot_grid.attach(btn_capture_area, 0, 2, 1, 1)

        # Checkbox to enable/disable clipboard copying
        self.copy_to_clipboard_checkbox = Gtk.CheckButton(label='Copy to Clipboard')
        self.copy_to_clipboard_checkbox.connect("toggled", self.on_copy_to_clipboard_toggled)
        screenshot_grid.attach(self.copy_to_clipboard_checkbox, 0, 3, 1, 1)

        # Checkbox to enable/disable saving to file
        self.save_to_file_checkbox = Gtk.CheckButton(label='Save to File')
        self.save_to_file_checkbox.connect("toggled", self.on_save_to_file_toggled)
        screenshot_grid.attach(self.save_to_file_checkbox, 0, 4, 1, 1)

        # Add the info label
        self.screenshot_info_label = Gtk.Label()
        self.screenshot_info_label.set_line_wrap(True)
        self.screenshot_info_label.set_max_width_chars(50)
        self.screenshot_info_label.set_halign(Gtk.Align.START)
        self.screenshot_info_label.set_valign(Gtk.Align.START)
        screenshot_grid.attach(self.screenshot_info_label, 0, 5, 2, 1)

        # Button to open recent saved screenshot
        btn_open_recent = Gtk.Button(label='Open Recent Screenshot')
        btn_open_recent.connect("clicked", self.open_recent_screenshot)
        screenshot_grid.attach(btn_open_recent, 0, 6, 1, 1)

        # Button to open default save location
        btn_open_save_location = Gtk.Button(label='Open Save Location')
        btn_open_save_location.connect("clicked", self.open_save_location)
        screenshot_grid.attach(btn_open_save_location, 1, 6, 1, 1)

        # Add preview image
        self.preview_image = Gtk.Image()
        self.preview_image.set_size_request(300, 200)  # Set a reasonable size
        screenshot_grid.attach(self.preview_image, 0, 7, 2, 1)

        return screenshot_grid

    def create_about_page(self):
        grid = Gtk.Grid()
        grid.set_column_spacing(10)
        grid.set_row_spacing(10)

        about_label = Gtk.Label(label="Seekers Eye Of The Storm Recorder\nVersion 4.6_hybrid\n\nA powerful and easy-to-use screen recording application.")
        about_label.set_justify(Gtk.Justification.CENTER)
        grid.attach(about_label, 0, 0, 1, 1)

        author_label = Gtk.Label(label="Authors:\nThe Seeker\nBen StormOS Dev (Tester/Contributor)\nRicki aka YughioMaster88 (Tester/Contributor)\nFishman aka Pescado (Tester/Contributor)")
        author_label.set_justify(Gtk.Justification.LEFT)
        grid.attach(author_label, 0, 1, 1, 1)

        notes_text = (
            "Notes:\n"
            "1. Ensure you have sufficient disk space before recording.\n"
            "2. For best performance, close unnecessary applications.\n"
            "3. If you encounter any issues, please report them to Seekers StormOS Project Team.\n"
            "4. Also please remember this program is a Work In Progress.\n"
            "5. This Hybrid Version will look for needed dependencies and install them as needed.\n (Currently working in most Arch Distro's and in Manjaro. Also working in most Ubuntu's and some Debian's)\n"
            "6. In this latest edition for the public I added a Screenshot Tab Tool.\n"
        )
        notes_label = Gtk.Label(label=notes_text)
        notes_label.set_justify(Gtk.Justification.LEFT)
        grid.attach(notes_label, 0, 2, 1, 1)

#-----------------------------Bug Fixes Addition-------------------------

        known_issues_text = (
            "Known Issues and Bug Fixes:\n"
            "1. Issue: Audio desync in long recordings\n"
            "   Fix: Applied in v4.3 - Improved audio-video synchronization algorithm\n"
            "2. Issue: Crash when recording on multi-monitor setups\n"
            "   Status: Under investigation, temporary workaround available\n"
            "3. Issue: High CPU usage on certain systems\n"
            "   Fix: Partially addressed in v4.1 - Optimized encoding process\n"
            "4. Issue: Inconsistent behavior with some window managers Doesnt work well with Gnome\n"
            "   Status: Actively working on a fix, expected in next release\n"
            "5. Added the ability within the program to tell the difference between Ubuntu and Debian systems using the Apt Package Manager\n"
            "   Status: Actively working on a fix, expected in next release\n"
            "   So for right now this code will wotk in all Arch Systems and Ubuntu and Debian that currently use Xfce not tested in Kde yet\n"
            "6. Added a preview window inside the Screenshot Tab\n"
            "7. Corrected Fps Issue within the start_record method and also corrected issue with Webcam Overlay not having hflip added on\n"
            


            #"\nFor the most up-to-date list of known issues and bug fixes, "
            #"please visit our GitHub repository or contact our support team."
        )
        known_issues_label = Gtk.Label(label=known_issues_text)
        known_issues_label.set_justify(Gtk.Justification.LEFT)
        grid.attach(known_issues_label, 0, 3, 1, 1)

#-----------------------------Bug Fixes Addition----End---------------------


        return grid     






#----------------------------------------------------------------------------------------
        self.show_all()
        self.create_tray_icon()
        self.update_tray_tooltip()  # Add this line to initialize the tooltip with the current settings

        self.preview_active = False
        self.preview_pixbuf = None
        self.preview_lock = threading.Lock()

        # Connect signal handlers for the combo boxes
        self.recording_size_combo.connect("changed", self.on_combobox_changed)
        self.video_codec_combo.connect("changed", self.on_combobox_changed)
        self.audio_codec_combo.connect("changed", self.on_combobox_changed)
        self.audio_input_combo.connect("changed", self.on_combobox_changed)
        self.secondary_audio_input_combo.connect("changed", self.on_combobox_changed)
        self.recording_area_combo.connect("changed", self.on_combobox_changed)
        self.output_format_combo.connect("changed", self.on_combobox_changed)
        self.active_window_combo.connect("changed", self.on_combobox_changed)








    def create_overlay_settings_tab(self):
        overlay_grid = Gtk.Grid()
        overlay_grid.set_column_spacing(10)
        overlay_grid.set_row_spacing(10)

        # Enable overlay checkbox
        self.enable_overlay_checkbox = Gtk.CheckButton(label="Enable Overlay")
        overlay_grid.attach(self.enable_overlay_checkbox, 0, 0, 2, 1)

        # Text overlay section
        text_frame = Gtk.Frame(label="Text Overlay")
        text_grid = Gtk.Grid()
        text_grid.set_column_spacing(10)
        text_grid.set_row_spacing(10)
        text_frame.add(text_grid)

        self.enable_text_overlay = Gtk.CheckButton(label="Enable Text Overlay")
        text_grid.attach(self.enable_text_overlay, 0, 0, 2, 1)

        text_label = Gtk.Label(label="Overlay Text:")
        self.overlay_text_entry = Gtk.Entry()
        text_grid.attach(text_label, 0, 1, 1, 1)
        text_grid.attach(self.overlay_text_entry, 1, 1, 1, 1)

        font_size_label = Gtk.Label(label="Font Size:")
        self.font_size_adjustment = Gtk.Adjustment(value=24, lower=8, upper=72, step_increment=1, page_increment=5)
        self.font_size_spinbutton = Gtk.SpinButton()
        self.font_size_spinbutton.set_adjustment(self.font_size_adjustment)
        text_grid.attach(font_size_label, 0, 2, 1, 1)
        text_grid.attach(self.font_size_spinbutton, 1, 2, 1, 1)

        text_position_label = Gtk.Label(label="Text Position:")
        self.text_position_combo = Gtk.ComboBoxText()
        positions = ["top-left", "top-center", "top-right", "bottom-left", "bottom-center", "bottom-right"]
        for pos in positions:
            self.text_position_combo.append_text(pos)
        self.text_position_combo.set_active(0)
        text_grid.attach(text_position_label, 0, 3, 1, 1)
        text_grid.attach(self.text_position_combo, 1, 3, 1, 1)

        overlay_grid.attach(text_frame, 0, 1, 2, 1)

        # Image overlay section
        image_frame = Gtk.Frame(label="Image Overlay")
        image_grid = Gtk.Grid()
        image_grid.set_column_spacing(10)
        image_grid.set_row_spacing(10)
        image_frame.add(image_grid)

        self.enable_image_overlay = Gtk.CheckButton(label="Enable Image Overlay")
        image_grid.attach(self.enable_image_overlay, 0, 0, 2, 1)

        image_label = Gtk.Label(label="Overlay Image:")
        self.image_path_entry = Gtk.Entry()
        self.image_path_entry.set_editable(False)
        self.choose_image_button = Gtk.Button(label="Choose Image")
        self.choose_image_button.connect("clicked", self.on_choose_image_clicked)
        image_grid.attach(image_label, 0, 1, 1, 1)
        image_grid.attach(self.image_path_entry, 1, 1, 1, 1)
        image_grid.attach(self.choose_image_button, 2, 1, 1, 1)

        image_position_label = Gtk.Label(label="Image Position:")
        self.image_position_combo = Gtk.ComboBoxText()
        for pos in positions:
            self.image_position_combo.append_text(pos)
        self.image_position_combo.set_active(0)
        image_grid.attach(image_position_label, 0, 2, 1, 1)
        image_grid.attach(self.image_position_combo, 1, 2, 1, 1)

        # Add image size slider
        image_size_label = Gtk.Label(label="Image Size:")
        self.image_size_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 10, 100, 1)
        self.image_size_scale.set_value(25)  # Default to 50% (original size)
        self.image_size_scale.connect("value-changed", self.on_image_size_changed)
        image_grid.attach(image_size_label, 0, 3, 1, 1)
        image_grid.attach(self.image_size_scale, 1, 3, 2, 1)

        overlay_grid.attach(image_frame, 0, 2, 2, 1)

        # Connect signals
        self.enable_overlay_checkbox.connect("toggled", self.on_overlay_settings_changed)
        self.enable_text_overlay.connect("toggled", self.on_overlay_settings_changed)
        self.overlay_text_entry.connect("changed", self.on_overlay_settings_changed)
        self.font_size_spinbutton.connect("value-changed", self.on_overlay_settings_changed)
        self.text_position_combo.connect("changed", self.on_overlay_settings_changed)
        self.enable_image_overlay.connect("toggled", self.on_overlay_settings_changed)
        self.image_path_entry.connect("changed", self.on_overlay_settings_changed)
        self.image_position_combo.connect("changed", self.on_overlay_settings_changed)
        self.image_size_scale.connect("value-changed", self.on_overlay_settings_changed)

        return overlay_grid
#--------------------------------Converter Button Assignment------------------------

    # In the ScreenRecorder class, add this method:
    def create_converter_tab(self):
        self.converter = VideoConverter(self)
        return self.converter.grid



    def convert_recent_recording(self, widget):
        if self.completed_recordings:
            most_recent_recording = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)[0][0]
            if os.path.exists(most_recent_recording):
                # Switch to the Video Converter tab
                notebook = self.get_child()
                converter_page_index = 6  # Adjust this index if needed
                notebook.set_current_page(converter_page_index)

                # Set the input file in the Video Converter
                if hasattr(self, 'converter'):
                    self.converter.input_entry.set_text(most_recent_recording)
                    self.status_label.set_text("Recent recording loaded for conversion.")
                else:
                    self.status_label.set_text("Error: Video Converter not initialized.")
            else:
                self.status_label.set_text("Error: Recent recording file not found.")
        else:
            self.status_label.set_text("No recent recordings available for conversion.")

    def get_converter_instance(self):
        notebook = self.get_child()
        converter_page = notebook.get_nth_page(6)  # Assuming Video Converter is the 7th tab (index 6)
        return converter_page.get_child()


#--------------------Scheduler Begin-------------------------------------------------

    def create_scheduler_tab(self):
        grid = Gtk.Grid()
        grid.set_column_spacing(10)
        grid.set_row_spacing(10)

        # Date picker
        date_label = Gtk.Label(label="Date:")
        grid.attach(date_label, 0, 0, 1, 1)
        self.date_picker = Gtk.Calendar()
        grid.attach(self.date_picker, 1, 0, 1, 1)

        # Time picker for scheduled recordings
        time_label = Gtk.Label(label="Start Time:")
        grid.attach(time_label, 0, 1, 1, 1)
        
        time_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        
        self.schedule_hour_spin = Gtk.SpinButton.new_with_range(1, 12, 1)
        time_box.pack_start(self.schedule_hour_spin, False, False, 0)
        
        time_box.pack_start(Gtk.Label(label=":"), False, False, 0)
        
        self.schedule_minute_spin = Gtk.SpinButton.new_with_range(0, 59, 1)
        self.schedule_minute_spin.set_value(0)
        time_box.pack_start(self.schedule_minute_spin, False, False, 0)
        
        self.schedule_am_pm_combo = Gtk.ComboBoxText()
        self.schedule_am_pm_combo.append_text("AM")
        self.schedule_am_pm_combo.append_text("PM")
        time_box.pack_start(self.schedule_am_pm_combo, False, False, 0)
        
        grid.attach(time_box, 1, 1, 1, 1)

        # Set current time for scheduled recordings
        current_time = datetime.now()
        self.schedule_hour_spin.set_value(current_time.hour % 12 or 12)
        self.schedule_minute_spin.set_value(current_time.minute)
        self.schedule_am_pm_combo.set_active(0 if current_time.hour < 12 else 1)

        # Duration
        duration_label = Gtk.Label(label="Duration:")
        grid.attach(duration_label, 0, 2, 1, 1)
        duration_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        
        self.duration_hours_spin = Gtk.SpinButton.new_with_range(0, 23, 1)
        self.duration_hours_spin.set_value(0)  # Default to 0 hours
        duration_box.pack_start(self.duration_hours_spin, False, False, 0)
        duration_box.pack_start(Gtk.Label(label="hours"), False, False, 0)
        
        self.duration_minutes_spin = Gtk.SpinButton.new_with_range(0, 59, 1)
        self.duration_minutes_spin.set_value(0)  # Default to 0 minutes
        duration_box.pack_start(self.duration_minutes_spin, False, False, 0)
        duration_box.pack_start(Gtk.Label(label="minutes"), False, False, 0)
        
        grid.attach(duration_box, 1, 2, 1, 1)



        # Buttons to advance time
        advance_1min_button = Gtk.Button(label="Advance 1 Minute")
        advance_1min_button.connect("clicked", self.advance_time, 1)
        grid.attach(advance_1min_button, 0, 3, 1, 1)

        advance_5min_button = Gtk.Button(label="Advance 5 Minutes")
        advance_5min_button.connect("clicked", self.advance_time, 5)
        grid.attach(advance_5min_button, 1, 3, 1, 1)

        # Select Custom Region button
        self.select_custom_region_button = Gtk.Button(label="Select Custom Region")
        self.select_custom_region_button.connect("clicked", self.on_select_custom_region_button_clicked)
        grid.attach(self.select_custom_region_button, 0, 4, 2, 1)

        # Add to schedule button
        add_button = Gtk.Button(label="Add to Schedule")
        add_button.connect("clicked", self.add_to_schedule)
        grid.attach(add_button, 0, 5, 2, 1)

        # Scheduled recordings list
        list_label = Gtk.Label(label="Scheduled Recordings:")
        grid.attach(list_label, 0, 6, 2, 1)

        self.schedule_list = Gtk.ListBox()
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_vexpand(True)
        scrolled_window.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scrolled_window.add(self.schedule_list)
        grid.attach(scrolled_window, 0, 7, 2, 1)

        # Clear all scheduled recordings button
        clear_all_button = Gtk.Button(label="Clear All Scheduled Recordings")
        clear_all_button.connect("clicked", self.clear_all_scheduled_recordings)
        grid.attach(clear_all_button, 0, 8, 2, 1)

        # Completed scheduled recordings list
        completed_label = Gtk.Label(label="Completed Scheduled Recordings:")
        grid.attach(completed_label, 0, 9, 2, 1)

        self.completed_schedule_list = Gtk.ListBox()
        completed_scrolled_window = Gtk.ScrolledWindow()
        completed_scrolled_window.set_vexpand(True)
        completed_scrolled_window.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        completed_scrolled_window.add(self.completed_schedule_list)
        grid.attach(completed_scrolled_window, 0, 10, 2, 1)

        # Clear completed recordings button
        clear_completed_button = Gtk.Button(label="Clear Completed Recordings")
        clear_completed_button.connect("clicked", self.clear_completed_recordings)
        grid.attach(clear_completed_button, 0, 11, 2, 1)

        # Status label for scheduler
        self.scheduler_status_label = Gtk.Label(label="Scheduler status: Inactive")
        grid.attach(self.scheduler_status_label, 0, 12, 2, 1)

        # Current time and date display
        self.current_time_label = Gtk.Label()
        grid.attach(self.current_time_label, 0, 13, 2, 1)

        # Add "Start Now" button and current time display
        start_now_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)

        # Current time display (read-only)
        self.current_hour_spin = Gtk.SpinButton.new_with_range(1, 12, 1)
        self.current_hour_spin.set_editable(False)
        start_now_box.pack_start(self.current_hour_spin, False, False, 0)

        start_now_box.pack_start(Gtk.Label(label=":"), False, False, 0)

        self.current_minute_spin = Gtk.SpinButton.new_with_range(0, 59, 1)
        self.current_minute_spin.set_editable(False)
        start_now_box.pack_start(self.current_minute_spin, False, False, 0)

        # AM/PM combo box for current time
        self.current_am_pm_combo = Gtk.ComboBoxText()
        self.current_am_pm_combo.append_text("AM")
        self.current_am_pm_combo.append_text("PM")
        self.current_am_pm_combo.set_sensitive(False)  # Make it read-only
        start_now_box.pack_start(self.current_am_pm_combo, False, False, 0)

        # Start Now button
        start_now_button = Gtk.Button(label="Start Recording Now")
        start_now_button.connect("clicked", self.start_recording_now)
        start_now_box.pack_start(start_now_button, True, True, 0)

        grid.attach(start_now_box, 0, 14, 2, 1)  # Span 2 columns

        # Add end time picker for "Start Now" functionality
        end_time_label = Gtk.Label(label="End Time:")
        grid.attach(end_time_label, 0, 15, 1, 1)

        end_time_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)

        # Hour spinner (12-hour format)
        self.end_hour_spin = Gtk.SpinButton.new_with_range(1, 12, 1)
        self.end_hour_spin.set_wrap(True)
        end_time_box.pack_start(self.end_hour_spin, False, False, 0)

        end_time_box.pack_start(Gtk.Label(label=":"), False, False, 0)

        # Minute spinner
        self.end_minute_spin = Gtk.SpinButton.new_with_range(0, 59, 1)
        self.end_minute_spin.set_wrap(True)
        end_time_box.pack_start(self.end_minute_spin, False, False, 0)

        # AM/PM combo box
        self.end_time_am_pm = Gtk.ComboBoxText()
        self.end_time_am_pm.append_text("AM")
        self.end_time_am_pm.append_text("PM")
        self.end_time_am_pm.set_active(0)  # Default to AM
        end_time_box.pack_start(self.end_time_am_pm, False, False, 0)

        grid.attach(end_time_box, 1, 15, 1, 1)

        # Set default end time (e.g., 1 hour from now)
        current_time = datetime.now()
        default_end_time = current_time + timedelta(hours=1)
        self.end_hour_spin.set_value(default_end_time.hour % 12 or 12)  # Convert to 12-hour format
        self.end_minute_spin.set_value(default_end_time.minute)
        self.end_time_am_pm.set_active(0 if default_end_time.hour < 12 else 1)

        # Start updating current time and date
        self.update_current_time_display()
        GLib.timeout_add_seconds(1, self.update_current_time_display)

        return grid



    def advance_time(self, widget, minutes):
        current_time = datetime.now()
        new_time = current_time + timedelta(minutes=minutes)
        self.current_time_label.set_text(new_time.strftime("%Y-%m-%d %I:%M:%S %p"))
        
        # Update the date picker and time picker
        self.date_picker.select_month(new_time.month - 1, new_time.year)
        self.date_picker.select_day(new_time.day)
        self.hour_spin.set_value(new_time.hour if new_time.hour <= 12 else new_time.hour - 12)
        self.minute_spin.set_value(new_time.minute)
        self.am_pm_combo.set_active(0 if new_time.hour < 12 else 1)



    import threading
    import time
    from datetime import datetime, timedelta



    def start_recording_now(self, widget):
        try:
            # Get current system time
            current_time = datetime.fromtimestamp(time.time())
            logging.info(f"Current system time: {current_time}")
            
            # Get end time from spin buttons and AM/PM combo box
            end_hour = self.end_hour_spin.get_value_as_int()
            end_minute = self.end_minute_spin.get_value_as_int()
            is_pm = self.end_time_am_pm.get_active_text() == "PM"
            
            # Adjust hour for PM
            if is_pm and end_hour != 12:
                end_hour += 12
            elif not is_pm and end_hour == 12:
                end_hour = 0  # 12 AM is 00:00 in 24-hour format
            
            logging.info(f"User set end time to: {end_hour:02d}:{end_minute:02d} {'PM' if is_pm else 'AM'}")
            
            # Calculate end time based on the current time
            end_time = current_time.replace(hour=end_hour, minute=end_minute, second=0, microsecond=0)
            
            # If end time is earlier than current time, add a day
            if end_time <= current_time:
                end_time += timedelta(days=1)
                logging.info("End time adjusted to next day")
            
            duration = (end_time - current_time).total_seconds()  # Duration in seconds
            
            logging.info(f"Calculated end time: {end_time}")
            logging.info(f"Recording duration: {duration} seconds")

            # Set recording start time and scheduled end time
            self.recording_start_time = current_time
            self.scheduled_end_time = end_time

            # Format end time string
            end_time_str = end_time.strftime('%I:%M %p').lstrip('0')
            if end_time_str.startswith('0'):
                end_time_str = end_time_str[1:]

            # Add to scheduled recordings
            self.scheduled_recordings.append({
                'time': current_time,
                'duration': duration / 60,
                'display_time': current_time.strftime('%I:%M %p'),
                'display_date': current_time.strftime('%Y-%m-%d'),
                'display_duration': f"{int(duration // 3600)}h {int((duration % 3600) // 60)}m"
            })
            
            self.update_schedule_list()
            self.start_scheduler()
            self.update_tray_tooltip()
            
            # Start recording immediately
            if not self.is_recording:
                self.start_recording(None)
            else:
                logging.warning("Recording is already in progress. Not starting a new one.")
            
            # Start a timer thread
            timer_thread = threading.Thread(target=self.recording_timer, args=(duration, time.time()))
            timer_thread.start()
            
            # Log the start of the recording instead of showing a dialog
            logging.info(f"Recording started at {current_time.strftime('%Y-%m-%d %I:%M %p')}")
            logging.info(f"Recording scheduled to stop at: {end_time_str}")
            
            # Update the status label instead of showing a dialog
            GLib.idle_add(self.status_label.set_text, f"Recording started. Will stop at {end_time_str}")
            
        except Exception as e:
            logging.error(f"Error in start_recording_now: {e}", exc_info=True)
            self.show_error_dialog(f"Failed to start recording: {str(e)}")



    def recording_timer(self, duration, start_time):
        logging.info(f"Timer started for {duration} seconds")
        while self.is_recording and (time.time() - start_time) < duration:
            remaining = duration - (time.time() - start_time)
            logging.info(f"Recording in progress. {remaining:.2f} seconds remaining.")
            time.sleep(1)  # Check every second
        
        if self.is_recording:
            logging.info("Timer completed. Stopping recording.")
            self.stop_recording_from_timer()
        else:
            logging.info("Recording was stopped before timer completed.")

    def stop_recording_from_timer(self):
        logging.info("stop_recording_from_timer called")
        GLib.idle_add(self.safe_stop_recording)

    def safe_stop_recording(self):
        logging.info("safe_stop_recording called")
        if self.is_recording:
            self.stop_recording(None)
        else:
            logging.warning("safe_stop_recording called but is_recording is already False")
        # De-toggle the timer in the main window
        self.timer_checkbox.set_active(False)
        # De-toggle the timer in the tray icon menu
        for item in self.indicator.get_menu().get_children():
            if isinstance(item, Gtk.CheckMenuItem) and item.get_label() == "Enable Timer":
                item.set_active(False)
        return False  # Important for GLib.idle_add


    def check_system_time(self):
        system_time = datetime.fromtimestamp(time.time())
        if abs((datetime.now() - system_time).total_seconds()) > 60:  # If difference is more than 1 minute
            logging.warning(f"System time ({system_time}) differs significantly from Python's datetime.now() ({datetime.now()})")
            self.show_warning_dialog("The system time may be incorrect. Please check your system clock settings.")



    def check_and_correct_python_time(self):
        system_time = datetime.fromtimestamp(time.time())
        python_time = datetime.now()
        if abs((python_time - system_time).total_seconds()) > 60:  # If difference is more than 1 minute
            logging.warning(f"Python time ({python_time}) differs from system time ({system_time}). Attempting to correct.")
            # Attempt to correct Python's time
            try:
                import ntplib
                client = ntplib.NTPClient()
                response = client.request('pool.ntp.org')
                corrected_time = datetime.fromtimestamp(response.tx_time)
                logging.info(f"Time corrected to: {corrected_time}")
                # You might need to use this corrected time throughout your application
            except:
                logging.error("Failed to correct time using NTP. Please check your system clock manually.")
                self.show_warning_dialog("The system time may be incorrect. Please check your system clock settings.")



    def update_current_time_display(self):
        current_time = datetime.now()
        self.current_time_label.set_text(current_time.strftime("%Y-%m-%d %I:%M:%S %p"))
        
        # Update the current time spinners and AM/PM combo for "Start Recording Now"
        self.current_hour_spin.set_value(current_time.hour % 12 or 12)
        self.current_minute_spin.set_value(current_time.minute)
        self.current_am_pm_combo.set_active(0 if current_time.hour < 12 else 1)
        
        # Update the time picker for scheduled recordings
        self.schedule_hour_spin.set_value(current_time.hour % 12 or 12)
        self.schedule_minute_spin.set_value(current_time.minute)
        self.schedule_am_pm_combo.set_active(0 if current_time.hour < 12 else 1)
        
        # Update the date picker
        self.date_picker.select_month(current_time.month - 1, current_time.year)
        self.date_picker.select_day(current_time.day)
        
        return True  # Continue calling this function every second




    def on_select_custom_region_button_clicked(self, widget):
        self.main_window.iconify()  # Minimize the main window
        time.sleep(0.1)  # Wait for 100 milliseconds to ensure the window is minimized
        self.custom_region(widget)

    def custom_region(self, widget=None):
        self.recording_area_combo.set_active(self.recording_areas.index("Custom Region"))
        self.is_custom_region = True

        def run_xrectsel():
            try:
                output = subprocess.check_output(['xrectsel']).decode('utf-8').strip()
                if output:
                    match = re.match(r'(\d+)x(\d+)\+(\d+)\+(\d+)', output)
                    if match:
                        width, height, x, y = map(int, match.groups())
                        self.custom_region_start_x = x
                        self.custom_region_start_y = y
                        self.custom_region_end_x = x + width
                        self.custom_region_end_y = y + height
                        self.recording_region = (x, y, width, height)
                        GLib.idle_add(self.status_label.set_text, "Custom region selected.")
                        self.scheduler_status_label.set_text("Custom region selected. Please set the schedule time.")
                        GLib.idle_add(self.main_window.deiconify)  # This line brings the main window back up
                    else:
                        logging.error(f"Unexpected output format: {output}")
                        GLib.idle_add(self.status_label.set_text, f"Unexpected output format: {output}")
                        return None
                else:
                    logging.error("No output from xrectsel")
                    GLib.idle_add(self.status_label.set_text, "No region selected")
                    return None
            except subprocess.CalledProcessError as e:
                logging.error(f"Error selecting custom region: {e}")
                GLib.idle_add(self.status_label.set_text, f"Error selecting custom region: {e}")
                return None
            finally:
                # Ensure the main window is brought back up, even if there was an error
                GLib.idle_add(self.main_window.deiconify)

        self.main_window.iconify()  # Minimize the window before selecting region
        time.sleep(0.1)  # Short delay to ensure the window is minimized
        threading.Thread(target=run_xrectsel).start()

    def add_to_schedule(self, widget):
        year, month, day = self.date_picker.get_date()
        hours = self.schedule_hour_spin.get_value_as_int()
        minutes = self.schedule_minute_spin.get_value_as_int()
        am_pm = self.schedule_am_pm_combo.get_active_text()

        # Convert to 24-hour format
        if am_pm == "PM" and hours != 12:
            hours += 12
        elif am_pm == "AM" and hours == 12:
            hours = 0

        duration_hours = self.duration_hours_spin.get_value_as_int()
        duration_minutes = self.duration_minutes_spin.get_value_as_int()

        # Calculate start time
        start_time = datetime(year, month + 1, day, hours, minutes)  # month + 1 because Gtk.Calendar months are 0-11

        if start_time <= datetime.now():
            self.scheduler_status_label.set_text("Cannot schedule recordings in the past.")
            return

        total_duration_minutes = duration_hours * 60 + duration_minutes
        if total_duration_minutes == 0:
            self.scheduler_status_label.set_text("Duration must be greater than 0.")
            return

        self.scheduled_recordings.append({
            'time': start_time,
            'duration': total_duration_minutes,
            'display_time': f"{start_time.strftime('%I:%M %p')}",
            'display_date': f"{start_time.strftime('%Y-%m-%d')}",
            'display_duration': f"{duration_hours}h {duration_minutes}m"
        })
        self.update_schedule_list()
        self.start_scheduler()
        self.update_tray_tooltip()

        self.scheduler_status_label.set_text(f"Recording scheduled for {start_time.strftime('%Y-%m-%d %I:%M %p')}")


    def start_scheduled_recording(self, recording):
        def delayed_start():
            logging.info(f"Starting scheduled recording: {recording['display_date']} {recording['display_time']}")
            
            # Attempt to minimize the main window
            self.main_window.iconify()
            time.sleep(0.5)  # Give some time for the window to minimize

            # Double-check if the window is minimized
            window = self.main_window.get_window()
            if window and not (window.get_state() & Gdk.WindowState.ICONIFIED):
                logging.warning("Window not minimized, attempting alternative methods")
                self.main_window.hide()
                
                # Try using xdotool if available
                try:
                    window_id = window.get_xid()
                    subprocess.run(['xdotool', 'windowminimize', str(window_id)], check=True)
                    logging.info("Used xdotool to minimize window")
                except (subprocess.SubprocessError, FileNotFoundError):
                    logging.warning("xdotool not available or failed to minimize window")

            # Set the recording start time
            self.recording_start_time = datetime.now()
            
            # Calculate and set the scheduled end time
            duration_minutes = recording['duration']
            self.scheduled_end_time = self.recording_start_time + timedelta(minutes=duration_minutes)

            # Start the recording
            self.start_recording(None)

            # Schedule the stop_recording call after the specified duration
            duration_ms = recording['duration'] * 60 * 1000  # Convert minutes to milliseconds
            GLib.timeout_add(duration_ms, self.stop_scheduled_recording, recording)

        # Use GLib.idle_add to ensure this runs in the main thread
        GLib.idle_add(delayed_start)
        return False  # Important for GLib.idle_add
#------------------------------------------------------------------------------------------------
#-----------------------------------Screenshot tool---------------------------------------------


    def on_copy_to_clipboard_toggled(self, widget):
        self.copy_to_clipboard = widget.get_active()
        print(f"Copy to clipboard toggled: {self.copy_to_clipboard}")
        print(f"Current state - Copy to clipboard: {self.copy_to_clipboard}, Save to file: {self.save_to_file}")
        self.update_screenshot_info()

    def on_save_to_file_toggled(self, widget):
        self.save_to_file = widget.get_active()
        print(f"Save to file toggled: {self.save_to_file}")
        print(f"Current state - Copy to clipboard: {self.copy_to_clipboard}, Save to file: {self.save_to_file}")
        self.update_screenshot_info()

    def capture_full_screen(self, widget):
        self.capture_screenshot([], "fullscreen")

    def capture_current_window(self, widget):
        self.capture_screenshot(["-u", "-b"], "current_window")

    def capture_selected_area(self, widget):
        self.capture_screenshot(["-s"], "selected_area")

    def capture_screenshot(self, scrot_args, filename_prefix):
        if not self.copy_to_clipboard and not self.save_to_file:
            self.screenshot_info_label.set_text("Please select at least one option: Copy to Clipboard or Save to File.")
            return

        use_temp_file = self.copy_to_clipboard and not self.save_to_file
        
        pictures_dir = os.path.expanduser("~") + "/Pictures"
        if not os.path.exists(pictures_dir):
            os.makedirs(pictures_dir)
                
        save_path = os.path.join(pictures_dir, self.generate_unique_filename(filename_prefix)) if not use_temp_file else "/tmp/temp_screenshot.png"
        
        print(f"Saving screenshot to: {save_path}")
        
        self.iconify()
        
        GLib.timeout_add(500, self._take_screenshot, scrot_args, save_path, use_temp_file)

        # Always add the screenshot to the list
        self.current_session_screenshots.append(save_path)
        print(f"Added to current session screenshots: {save_path}")  # Debug print

        GLib.timeout_add(1000, self.delayed_preview_update, save_path, use_temp_file)


    def delayed_preview_update(self, save_path, use_temp_file):
        if use_temp_file:
            # For clipboard images
            clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
            if clipboard.wait_is_image_available():
                try:
                    pixbuf = clipboard.wait_for_image()
                    if pixbuf:
                        self.update_preview_image_from_pixbuf(pixbuf)
                    else:
                        print("No image in clipboard")
                except Exception as e:
                    print(f"Error getting image from clipboard: {e}")
            else:
                print("No image available in clipboard")
        else:
            # For saved files
            if os.path.exists(save_path):
                try:
                    self.update_preview_image(save_path)
                except Exception as e:
                    print(f"Error updating preview image: {e}")
            else:
                print(f"File not found, retrying in 1 second: {save_path}")
                GLib.timeout_add(1000, self.delayed_preview_update, save_path, use_temp_file)
        return False

    def _take_screenshot(self, scrot_args, save_path, use_temp_file):
        if self.save_to_file or use_temp_file:
            command = ["scrot", *scrot_args, save_path]
            print(f"Running command: {' '.join(command)}")
            result = subprocess.run(command, capture_output=True, text=True)
            if result.returncode != 0:
                print(f"Error taking screenshot: {result.stderr}")
                return False
            else:
                print("Screenshot taken successfully")
        
        if self.copy_to_clipboard:
            subprocess.run(["xclip", "-selection", "clipboard", "-t", "image/png", "-i", save_path])
            if use_temp_file:
                os.remove(save_path)
                print(f"Temporary file removed: {save_path}")
                # Remove the temporary file from the list
                if save_path in self.current_session_screenshots:
                    self.current_session_screenshots.remove(save_path)
                    print(f"Removed from current session screenshots: {save_path}")
                GLib.idle_add(self.screenshot_info_label.set_text, "Screenshot copied to clipboard")
            elif self.save_to_file:
                GLib.idle_add(self.screenshot_info_label.set_text, f"Screenshot saved to {save_path} and copied to clipboard")
            else:
                GLib.idle_add(self.screenshot_info_label.set_text, "Screenshot copied to clipboard")
        elif self.save_to_file:
            GLib.idle_add(self.screenshot_info_label.set_text, f"Screenshot saved to {save_path}")
        
        self.present()
        
        return False

    def update_preview_image(self, filepath):
        try:
            pixbuf = GdkPixbuf.Pixbuf.new_from_file(filepath)
            self.update_preview_image_from_pixbuf(pixbuf)
            print(f"Preview image updated from file: {filepath}")
        except Exception as e:
            print(f"Error updating preview image from file: {e}")
            self.preview_image.set_from_icon_name("image-missing", Gtk.IconSize.DIALOG)

    def update_preview_image_from_pixbuf(self, pixbuf):
        try:
            # Get the original width and height
            width = pixbuf.get_width()
            height = pixbuf.get_height()
            
            # Calculate the scaling factor
            scale_factor = min(800 / width, 800 / height)
            
            # Calculate new dimensions
            new_width = int(width * scale_factor)
            new_height = int(height * scale_factor)
            
            # Scale the pixbuf
            scaled_pixbuf = pixbuf.scale_simple(new_width, new_height, GdkPixbuf.InterpType.BILINEAR)
            
            # Set the scaled pixbuf to the image widget
            self.preview_image.set_from_pixbuf(scaled_pixbuf)
            
            print("Preview image updated from pixbuf")
        except Exception as e:
            print(f"Error updating preview image from pixbuf: {e}")
            self.preview_image.set_from_icon_name("image-missing", Gtk.IconSize.DIALOG)




    def clear_current_session_screenshots(self):
        self.current_session_screenshots.clear()



    def generate_unique_filename(self, prefix="screenshot"):
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{prefix}_{timestamp}.png"
        print(f"Generated filename: {filename}")  # Debug print
        return filename


    import subprocess
    import os
    from gi.repository import Gtk, Gio

    def open_recent_screenshot(self, widget):
        print(f"Current session screenshots: {self.current_session_screenshots}")  # Debug print
        if self.current_session_screenshots:
            most_recent = self.current_session_screenshots[-1]
            
            print(f"Attempting to open: {most_recent}")
            
            if os.path.exists(most_recent):
                try:
                    self.open_file(most_recent)
                    self.screenshot_info_label.set_text(f"Opened: {os.path.basename(most_recent)}")
                except Exception as e:
                    error_message = f"Error opening file: {e}"
                    print(error_message)
                    self.screenshot_info_label.set_text(error_message)
            else:
                message = f"File not found: {most_recent}"
                print(message)
                self.screenshot_info_label.set_text(message)
        else:
            message = "No screenshots taken in this session."
            print(message)
            self.screenshot_info_label.set_text(message)

    def open_file(self, file_path):
        try:
            Gio.AppInfo.launch_default_for_uri(f"file://{file_path}")
        except Exception as e:
            print(f"Error opening file with Gio: {e}")
            try:
                if os.name == 'posix':  # For Linux and macOS
                    subprocess.call(('xdg-open', file_path))
                elif os.name == 'nt':  # For Windows
                    os.startfile(file_path)
                else:
                    raise OSError("Unsupported operating system")
            except Exception as e:
                raise Exception(f"Failed to open file: {e}")

    def open_save_location(self, widget):
        pictures_dir = os.path.expanduser("~") + "/Pictures"
        if os.path.exists(pictures_dir):
            try:
                self.open_file(pictures_dir)
            except Exception as e:
                self.screenshot_info_label.set_text(f"Error opening Pictures directory: {e}")
        else:
            self.screenshot_info_label.set_text("Pictures directory not found.")



    def update_screenshot_info(self):
        if self.copy_to_clipboard and self.save_to_file:
            info = "Screenshots will be copied to clipboard and saved to file."
        elif self.copy_to_clipboard:
            info = "Screenshots will be copied to clipboard only."
        elif self.save_to_file:
            info = "Screenshots will be saved to file only."
        else:
            info = "Please select at least one option: Copy to Clipboard or Save to File."
        print(f"Updating info label: {info}")
        self.screenshot_info_label.set_text(info)



    def clear_session_screenshots(self):
        self.current_session_screenshots.clear()




    def on_window_delete_event(self, widget, event):
        self.hide()
        return True  # Prevents the window from being destroyed


#-----------------------------------Screenshot tool End-----------------------------------------
#-------------------------------Fix for different Monitor sizes-------------------



    def get_screen(self):
        display = Gdk.Display.get_default()
        monitor = display.get_primary_monitor()
        return monitor.get_geometry()

    def get_adjusted_screen_dimensions(self):
        geometry = self.get_screen()
        width, height = geometry.width, geometry.height
        return self.ensure_even_dimensions(width, height)

    def get_monitor_for_window(self, x, y):
        display = Gdk.Display.get_default()
        return display.get_monitor_at_point(x, y)

    def get_monitor_for_coordinates(self, x, y):
        display = Gdk.Display.get_default()
        return display.get_monitor_at_point(x, y)

    def handle_recording_area(self, selected_recording_area):
        input_args = []
        width, height = 0, 0
        monitor_x, monitor_y = 0, 0

        if selected_recording_area == "Full Screen":
            width, height = self.get_adjusted_screen_dimensions()
            input_args.extend([
                "-f", "x11grab",
                "-framerate", "30",
                "-video_size", f"{width}x{height}",
                "-i", ":0.0"
            ])
            logging.info(f"Full Screen recording: {width}x{height}")

        elif selected_recording_area == "Camera Only":
            selected_camera = self.camera_combo.get_active_text()
            if selected_camera:
                try:
                    camera_index = self.extract_camera_index(selected_camera)
                    device = f"/dev/video{camera_index}"
                    resolution = self.camera_resolution_combo.get_active_text()
                    width, height = map(int, resolution.split('x'))
                    width, height = self.ensure_even_dimensions(width, height)
                    input_args.extend([
                        "-f", "v4l2",
                        "-video_size", f"{width}x{height}",
                        "-framerate", "30",
                        "-i", device
                    ])
                    input_args.extend(["-f", "alsa", "-i", "hw:1"])
                    logging.info(f"Camera recording: {width}x{height}")
                except ValueError as e:
                    raise ValueError(f"Camera setup error: {e}")
            else:
                raise ValueError("No camera selected for Camera Only mode")

        elif selected_recording_area == "Active Window":
            selected_window = self.active_window_combo.get_active_text()
            if selected_window:
                window_info = self.get_window_info_by_name(selected_window)
                if window_info:
                    x_pos, y_pos, width, height = window_info
                    width, height = self.ensure_even_dimensions(width, height)
                    monitor = self.get_monitor_for_window(x_pos, y_pos)
                    monitor_x, monitor_y = monitor.get_geometry().x, monitor.get_geometry().y
                    input_args.extend([
                        "-f", "x11grab",
                        "-framerate", "30",
                        "-video_size", f"{width}x{height}",
                        "-i", f":0.0+{x_pos+monitor_x},{y_pos+monitor_y}"
                    ])
                    logging.info(f"Active Window recording: {width}x{height} at ({x_pos+monitor_x},{y_pos+monitor_y})")
                else:
                    raise ValueError(f"Unable to get information for window: {selected_window}")
            else:
                raise ValueError("No active window selected for Active Window mode")

        elif selected_recording_area == "Custom Region":
            if self.recording_region:
                x, y, w, h = self.recording_region
                w, h = self.ensure_even_dimensions(w, h)
                monitor = self.get_monitor_for_coordinates(x, y)
                monitor_x, monitor_y = monitor.get_geometry().x, monitor.get_geometry().y
                input_args.extend([
                    "-f", "x11grab",
                    "-framerate", "30",
                    "-video_size", f"{w}x{h}",
                    "-i", f":0.0+{x+monitor_x},{y+monitor_y}"
                ])
                logging.info(f"Custom Region recording: {w}x{h} at ({x+monitor_x},{y+monitor_y})")
            else:
                raise ValueError("No custom region selected for Custom Region mode")

        else:
            raise ValueError(f"Unknown recording area: {selected_recording_area}")

        return input_args, width, height




#------------------------------ End------------------------------------------------



#--------------------End-------------------------------------------------------------------------


    def select_custom_region(self, widget=None):
        # Set the recording area to "Custom Region"
        self.recording_area_combo.set_active(self.recording_areas.index("Custom Region"))
        
        self.is_custom_region = True


        # Minimize the main window
        self.main_window.iconify()

        def run_xrectsel():
            try:
                output = subprocess.check_output(['xrectsel']).decode('utf-8').strip()
                if output:
                    match = re.match(r'(\d+)x(\d+)\+(\d+)\+(\d+)', output)
                    if match:
                        width, height, x, y = map(int, match.groups())
                        self.custom_region_start_x = x
                        self.custom_region_start_y = y
                        self.custom_region_end_x = x + width
                        self.custom_region_end_y = y + height
                        self.recording_region = (x, y, width, height)
                        GLib.idle_add(self.status_label.set_text, "Custom region selected. Recording will start now.")

                        time.sleep(0.5)

                        GLib.idle_add(self.start_recording, None)
                    else:
                        logging.error(f"Unexpected output format: {output}")
                        GLib.idle_add(self.status_label.set_text, f"Unexpected output format: {output}")
                        return None
            except subprocess.CalledProcessError as e:
                logging.error(f"Error selecting custom region: {e}")
                GLib.idle_add(self.status_label.set_text, f"Error selecting custom region: {e}")
                return None

        threading.Thread(target=run_xrectsel).start()

    def set_timer(self, hour, minute):
        # Calculate the delay until the scheduled time
        now = datetime.now()
        scheduled_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
        if scheduled_time < now:
            scheduled_time += timedelta(days=1)
        
        delay = (scheduled_time - now).total_seconds()
        GLib.timeout_add_seconds(int(delay), self.start_scheduled_recording)






    def update_completed_schedule_list(self):
        for child in self.completed_schedule_list.get_children():
            self.completed_schedule_list.remove(child)

        for recording in self.completed_scheduled_recordings:
            row = Gtk.ListBoxRow()
            box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            
            date_time_label = Gtk.Label(label=f"{recording['display_date']} {recording['display_time']}")
            duration_label = Gtk.Label(label=f"Duration: {recording['display_duration']}")
            
            box.pack_start(date_time_label, True, True, 0)
            box.pack_start(duration_label, True, True, 0)
            
            row.add(box)
            self.completed_schedule_list.add(row)

        self.completed_schedule_list.show_all()

    def clear_completed_recordings(self, button):
        self.completed_scheduled_recordings.clear()
        self.update_completed_schedule_list()




    def stop_scheduled_recording(self, recording):
        logging.info(f"Attempting to stop scheduled recording: {recording['display_date']} {recording['display_time']}")
        if self.is_recording:
            self.stop_recording(None)
            logging.info("Recording stopped successfully")
        else:
            logging.warning("Attempted to stop recording, but no recording was in progress")
        
        # Remove this recording from the scheduled recordings list
        if recording in self.scheduled_recordings:
            self.scheduled_recordings.remove(recording)
            self.update_schedule_list()
        
        # Add the recording to the completed list
        self.completed_scheduled_recordings.append(recording)
        self.update_completed_schedule_list()
        
        self.update_tray_tooltip()
        return False  # Important for GLib.timeout_add



        # Convert to 24-hour format for internal storage
        if am_pm == "PM" and hours != 12:
            hours += 12
        elif am_pm == "AM" and hours == 12:
            hours = 0

        scheduled_time = datetime(year, month + 1, day, hours, minutes)
        if scheduled_time <= datetime.now():
            self.show_error_dialog("Cannot schedule recordings in the past.")
            return

        total_duration_minutes = duration_hours * 60 + duration_minutes
        if total_duration_minutes == 0:
            self.show_error_dialog("Duration must be greater than 0.")
            return

        self.scheduled_recordings.append({
            'time': scheduled_time,
            'duration': total_duration_minutes,
            'display_time': f"{scheduled_time.strftime('%I:%M %p')}",
            'display_date': f"{scheduled_time.strftime('%Y-%m-%d')}",
            'display_duration': f"{duration_hours}h {duration_minutes}m"
        })
        self.update_schedule_list()
        self.start_scheduler()
        self.update_tray_tooltip()  # Add this line


        # Optionally, show a confirmation message
        self.show_info_dialog(f"Recording scheduled for {scheduled_time.strftime('%Y-%m-%d %I:%M %p')}")

    def update_schedule_list(self):
        for child in self.schedule_list.get_children():
            self.schedule_list.remove(child)

        for index, recording in enumerate(self.scheduled_recordings):
            row = Gtk.ListBoxRow()
            box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            
            time_label = Gtk.Label(label=f"{recording['display_date']} {recording['display_time']}")
            duration_label = Gtk.Label(label=f"Duration: {recording['display_duration']}")
            
            remove_button = Gtk.Button(label="Remove")
            remove_button.connect("clicked", self.remove_from_schedule, index)
            
            box.pack_start(time_label, True, True, 0)
            box.pack_start(duration_label, True, True, 0)
            box.pack_start(remove_button, False, False, 0)
            
            row.add(box)
            self.schedule_list.add(row)

        self.schedule_list.show_all()


    def update_scheduler_status(self):
        status = "Active" if self.scheduler_active else "Inactive"
        self.scheduler_status_label.set_text(f"Scheduler status: {status}")



    def clear_all_scheduled_recordings(self, button):
        # Stop the scheduler first
        self.stop_scheduler()
        
        # Clear the recordings list
        self.scheduled_recordings.clear()
        
        # Clear the completed recordings list
        self.completed_scheduled_recordings.clear()
        
        # Update the UI
        GLib.idle_add(self.update_schedule_list)
        GLib.idle_add(self.update_completed_schedule_list)
        GLib.idle_add(self.update_scheduler_status)
        
        logging.info("All scheduled and completed recordings cleared")


    def start_scheduler(self):
        if not hasattr(self, 'scheduler_thread') or self.scheduler_thread is None:
            self.scheduler_active = True
            self.scheduler_thread = threading.Thread(target=self.run_scheduler)
            self.scheduler_thread.daemon = True
            self.scheduler_thread.start()
            logging.info("Scheduler started")
            GLib.idle_add(self.update_scheduler_status)

    def stop_scheduler(self):
        if hasattr(self, 'scheduler_thread') and self.scheduler_thread is not None:
            self.scheduler_active = False
            self.scheduler_thread.join(timeout=5)  # Wait for up to 5 seconds for the thread to finish
            if self.scheduler_thread.is_alive():
                logging.warning("Scheduler thread did not stop within the timeout period")
            self.scheduler_thread = None
        logging.info("Scheduler stopped")
        GLib.idle_add(self.update_scheduler_status)



    def remove_from_schedule(self, button, index):
        if 0 <= index < len(self.scheduled_recordings):
            removed_recording = self.scheduled_recordings.pop(index)
            logging.info(f"Removed scheduled recording: {removed_recording['display_date']} {removed_recording['display_time']}")
            self.update_schedule_list()
            self.update_tray_tooltip()  # Add this line

            # If there are no more scheduled recordings, stop the scheduler
            if not self.scheduled_recordings:
                self.stop_scheduler()
        else:
            logging.error(f"Invalid index for removal: {index}")



    def run_scheduler(self):
        while self.scheduler_active:
            now = datetime.now()
            for recording in self.scheduled_recordings[:]:  # Create a copy of the list to iterate over
                if recording['time'] <= now:
                    GLib.idle_add(self.start_scheduled_recording, recording)
                    self.scheduled_recordings.remove(recording)
                    GLib.idle_add(self.update_schedule_list)
            time.sleep(1)  # Check every second
        logging.info("Scheduler thread exiting")


    def start_scheduler(self):
        if not hasattr(self, 'scheduler_thread') or self.scheduler_thread is None:
            self.scheduler_active = True
            self.scheduler_thread = threading.Thread(target=self.run_scheduler)
            self.scheduler_thread.daemon = True
            self.scheduler_thread.start()
            self.update_scheduler_status()





    def show_error_dialog(self, message):
        dialog = Gtk.MessageDialog(
            transient_for=self,
            flags=0,
            message_type=Gtk.MessageType.ERROR,
            buttons=Gtk.ButtonsType.OK,
            text="Error"
        )
        dialog.format_secondary_text(message)
        dialog.run()
        dialog.destroy()            



    def show_info_dialog(self, message):
        dialog = Gtk.MessageDialog(
            transient_for=self,
            flags=0,
            message_type=Gtk.MessageType.INFO,
            buttons=Gtk.ButtonsType.OK,
            text="Information"
        )
        dialog.format_secondary_text(message)
        dialog.run()
        dialog.destroy()

    def update_scheduler_tooltip(self):
        if self.scheduled_recordings:
            next_recording = min(self.scheduled_recordings, key=lambda x: x['time'])
            time_until = next_recording['time'] - datetime.now()
            days, seconds = time_until.days, time_until.seconds
            hours, minutes = divmod(seconds // 60, 60)
            
            countdown = f"{days}d {hours}h {minutes}m" if days > 0 else f"{hours}h {minutes}m"
            
            scheduler_info = (
                f"Next scheduled recording:\n"
                f"Date: {next_recording['display_date']}\n"
                f"Time: {next_recording['display_time']}\n"
                f"Duration: {next_recording['display_duration']}\n"
                f"Countdown: {countdown}"
            )
        else:
            scheduler_info = "No scheduled recordings"

        return scheduler_info


    def get_countdown_to_next_event(self):
        if not self.scheduled_recordings:
            return None
        
        now = datetime.now()
        next_event = min(self.scheduled_recordings, key=lambda x: x['time'])
        time_difference = next_event['time'] - now
        
        if time_difference.total_seconds() <= 0:
            return "Event starting now"
        
        days, remainder = divmod(time_difference.total_seconds(), 86400)
        hours, remainder = divmod(remainder, 3600)
        minutes, seconds = divmod(remainder, 60)
        
        if days > 0:
            return f"{int(days)}d {int(hours)}h {int(minutes)}m"
        elif hours > 0:
            return f"{int(hours)}h {int(minutes)}m {int(seconds)}s"
        else:
            return f"{int(minutes)}m {int(seconds)}s"


#--------------------Scheduler End--------------------------------------------------


    def on_window_delete_event(self, widget, event):
        self.cleanup_preview()
        self.hide()
        return True


    def on_image_size_changed(self, scale):
        self.image_size_percentage = scale.get_value()
        logging.info(f"Image size percentage updated to: {self.image_size_percentage}%")
        if self.preview_active:
            self.preview_area.queue_draw()
        self.update_tray_tooltip()


    def on_preview_draw(self, widget, cr):
        allocation = widget.get_allocation()
        width = allocation.width
        height = allocation.height

        # Draw black background
        cr.set_source_rgb(0, 0, 0)
        cr.rectangle(0, 0, width, height)
        cr.fill()

        # If we have a preview pixbuf, draw it
        if hasattr(self, 'preview_pixbuf') and self.preview_pixbuf is not None:
            pixbuf_width = self.preview_pixbuf.get_width()
            pixbuf_height = self.preview_pixbuf.get_height()

            # Calculate scaling to fit the widget while maintaining aspect ratio
            scale = min(width / pixbuf_width, height / pixbuf_height)
            new_width = int(pixbuf_width * scale)
            new_height = int(pixbuf_height * scale)

            # Center the image
            x = (width - new_width) // 2
            y = (height - new_height) // 2

            # Scale and draw the pixbuf
            scaled_pixbuf = self.preview_pixbuf.scale_simple(new_width, new_height, GdkPixbuf.InterpType.BILINEAR)
            Gdk.cairo_set_source_pixbuf(cr, scaled_pixbuf, x, y)
            cr.paint()

        # Draw overlays if enabled
        if self.preview_overlay_toggle.get_active() and self.enable_overlay_checkbox.get_active():
            if self.enable_text_overlay.get_active():
                self.draw_text_overlay(cr, width, height)
            if self.enable_image_overlay.get_active():
                self.draw_image_overlay(cr, width, height)

        return False


    def draw_overlays(self, cr, width, height):
        if self.enable_overlay_checkbox.get_active():
            if self.enable_text_overlay.get_active():
                self.draw_text_overlay(cr, width, height)
            if self.enable_image_overlay.get_active():
                self.draw_image_overlay(cr, width, height)
        if self.is_webcam_overlay:
            self.draw_webcam_overlay(cr, width, height)




    def draw_text_overlay(self, cr, width, height):
        text = self.overlay_text_entry.get_text()
        font_size = self.font_size_spinbutton.get_value_as_int()
        position = self.text_position_combo.get_active_text()

        cr.set_source_rgb(1, 1, 1)  # White text
        cr.select_font_face("Sans", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
        cr.set_font_size(font_size)

        x, y = self.calculate_text_position(cr, text, width, height, position, font_size)

        cr.move_to(x, y)
        cr.show_text(text)


    def calculate_text_position(self, cr, text, width, height, position, font_size):
        text_extents = cr.text_extents(text)
        margin = 20
        if position == "top-left":
            x, y = margin, font_size + margin
        elif position == "top-center":
            x, y = (width - text_extents.width) / 2, font_size + margin
        elif position == "top-right":
            x, y = width - text_extents.width - margin, font_size + margin
        elif position == "bottom-left":
            x, y = margin, height - margin
        elif position == "bottom-center":
            x, y = (width - text_extents.width) / 2, height - margin
        elif position == "bottom-right":
            x, y = width - text_extents.width - margin, height - margin
        return x, y



    def calculate_image_position(self, pixbuf, width, height):
        image_width = pixbuf.get_width()
        image_height = pixbuf.get_height()
        
        if self.image_position == "top-left":
            return 10, 10
        elif self.image_position == "top-center":
            return (width - image_width) // 2, 10
        elif self.image_position == "top-right":
            return width - image_width - 10, 10
        elif self.image_position == "bottom-left":
            return 10, height - image_height - 10
        elif self.image_position == "bottom-center":
            return (width - image_width) // 2, height - image_height - 10
        elif self.image_position == "bottom-right":
            return width - image_width - 10, height - image_height - 10
        else:
            return 10, 10  # Default to top-left if position is not recognized



    def draw_webcam_overlay(self, cr, width, height, x_offset=0, y_offset=0, scale_x=1, scale_y=1):
        if self.is_webcam_overlay and hasattr(self, 'webcam_pixbuf'):
            webcam_width = int(width * (self.webcam_size_percentage / 100))
            webcam_height = int(webcam_width / (self.webcam_pixbuf.get_width() / self.webcam_pixbuf.get_height()))
            
            scaled_webcam = self.webcam_pixbuf.scale_simple(webcam_width, webcam_height, GdkPixbuf.InterpType.BILINEAR)
            
            position = self.webcam_position_combo.get_active_text()
            x, y = self.calculate_webcam_position(scaled_webcam, width, height, position)
            
            Gdk.cairo_set_source_pixbuf(cr, scaled_webcam, x, y)
            cr.paint()





    def exit_journal_mode(self):
        self.is_journal_mode = False
        self.journaling_mode_checkbox.set_active(False)
        
        # Re-enable overlay settings
        self.enable_overlay_checkbox.set_sensitive(True)
        if hasattr(self, 'tray_enable_overlay_item'):
            self.tray_enable_overlay_item.set_sensitive(True)
        
        logging.info("Exited Journal mode, re-enabled overlay settings")
        self.update_tray_tooltip()


#---------------------Webcam Overlay from Final-------------


    def toggle_webcam_preview(self, widget):
        if hasattr(self, 'ffplay_process') and self.ffplay_process:
            print("Closing webcam preview")
            self.close_webcam_preview()
            widget.set_label("Show Webcam Preview")
            # Enable the "Enable Webcam Overlay" checkbox
            self.webcam_overlay_checkbox.set_sensitive(True)
        else:
            print("Showing webcam preview")
            self.show_webcam_preview()
            widget.set_label("Hide Webcam Preview")
            # Disable the "Enable Webcam Overlay" checkbox
            self.webcam_overlay_checkbox.set_sensitive(False)

    def show_webcam_preview(self):
        if hasattr(self, 'ffplay_process') and self.ffplay_process:
            print("Webcam preview is already running")
            return

        # Disable webcam overlay
        self.webcam_overlay_checkbox.set_active(False)
        self.is_webcam_overlay = False
        self.webcam_overlay_checkbox.set_sensitive(False)

        selected_camera = self.camera_combo.get_active_text()
        selected_resolution = self.camera_resolution_combo.get_active_text()
        
        if not selected_camera:
            print("No camera selected")
            return

        try:
            device_index = self.extract_camera_index(selected_camera)
            device = f"/dev/video{device_index}"
            resolution = selected_resolution if selected_resolution else "640x480"
            
            screen_width, screen_height = self.get_screen_dimensions()
            overlay_width = int(screen_width * (self.webcam_size_percentage / 100))
            overlay_height = int(overlay_width * 9 / 16)  # Assuming 16:9 aspect ratio
            
            command = [
                'ffplay',
                '-f', 'v4l2',
                '-input_format', 'yuv420p',
                '-framerate', '30',
                '-video_size', resolution,
                '-i', device,
                '-vf', f'scale={overlay_width}:{overlay_height},hflip',
                '-window_title', 'Webcam Preview',
                '-noborder',
                '-fflags', 'nobuffer',
                '-flags', 'low_delay',
                '-framedrop'
            ]
            
            print(f"Executing command: {' '.join(command)}")
            self.ffplay_process = subprocess.Popen(command)
            
            # Wait for the window to appear
            time.sleep(2)
            
            # Get the window ID
            self.preview_window_id = self.get_window_id_by_name('Webcam Preview')
            if self.preview_window_id:
                self.update_preview_position_and_size()
            else:
                print("Error: Could not find preview window")
            
        except Exception as e:
            print(f"Error starting webcam preview: {e}")
            self.close_webcam_preview()  # Clean up in case of error

    def on_sync_message(self, bus, message):
        if message.get_structure().get_name() == 'prepare-window-handle':
            message.src.set_window_handle(self.xid)

    def on_eos(self, bus, msg):
        print("End-of-stream reached")
        self.pipeline.set_state(Gst.State.NULL)

    def on_error(self, bus, msg):
        err, debug = msg.parse_error()
        print(f"Error: {err.message}")
        print(f"Debug info: {debug}")
        self.pipeline.set_state(Gst.State.NULL)

    def on_preview_window_closed(self, widget, event):
        self.close_webcam_preview()
        self.preview_webcam_button.set_label("Show Webcam Preview")
        return True

    def close_webcam_preview(self):
        try:
            if hasattr(self, 'ffplay_process') and self.ffplay_process:
                self.ffplay_process.terminate()
                self.ffplay_process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            print("Timeout while waiting for ffplay to close. Forcing termination.")
            self.ffplay_process.kill()
        except Exception as e:
            print(f"Error terminating ffplay process: {e}")
        finally:
            if hasattr(self, 'ffplay_process'):
                del self.ffplay_process

        if hasattr(self, 'preview_window_id'):
            try:
                # Use xdotool to close the window
                subprocess.run(['xdotool', 'windowclose', self.preview_window_id])
            except Exception as e:
                print(f"Error closing preview window: {e}")
            del self.preview_window_id

        # Enable the webcam overlay checkbox
        self.webcam_overlay_checkbox.set_sensitive(True)

        print("Webcam preview closed")



    def update_preview_position_and_size(self):
        if not hasattr(self, 'preview_window_id'):
            return

        screen_width, screen_height = self.get_screen_dimensions()
        overlay_width = int(screen_width * (self.webcam_size_percentage / 100))
        overlay_height = int(overlay_width * 9 / 16)  # Assuming 16:9 aspect ratio

        position = self.webcam_position_combo.get_active_text()
        if position == "top-left":
            x, y = 0, 0
        elif position == "top-right":
            x, y = screen_width - overlay_width, 0
        elif position == "bottom-left":
            x, y = 0, screen_height - overlay_height
        elif position == "bottom-right":
            x, y = screen_width - overlay_width, screen_height - overlay_height
        elif position == "center":
            x, y = (screen_width - overlay_width) // 2, (screen_height - overlay_height) // 2
        else:
            x, y = 0, 0

        subprocess.run(['xdotool', 'windowmove', self.preview_window_id, str(x), str(y)])
        subprocess.run(['xdotool', 'windowsize', self.preview_window_id, str(overlay_width), str(overlay_height)])


    def print_webcam_info(self):
        selected_camera = self.camera_combo.get_active_text()
        if selected_camera:
            device_index = self.extract_camera_index(selected_camera)
            device = f"/dev/video{device_index}"
            try:
                output = subprocess.check_output(['v4l2-ctl', '-d', device, '--list-formats-ext'], universal_newlines=True)
                print(f"Webcam info for {device}:")
                print(output)
            except subprocess.CalledProcessError as e:
                print(f"Error getting webcam info: {e}")
        else:
            print("No camera selected")




    def get_window_id_by_name(self, window_name):
        try:
            output = subprocess.check_output(['xdotool', 'search', '--name', f'^{window_name}$']).decode().strip()
            if output:
                return output.split('\n')[-1]  # Return the last (most recent) window ID
            else:
                print(f"No window found with name: {window_name}")
                return None
        except subprocess.CalledProcessError as e:
            print(f"Error getting window ID: {e}")
            return None


    def get_screen_dimensions(self):
        display = Gdk.Display.get_default()
        monitor = display.get_primary_monitor()
        geometry = monitor.get_geometry()
        return geometry.width, geometry.height



    def update_webcam_preview(self):
        while self.webcam_preview_active:
            if self.is_webcam_overlay:
                webcam_pixbuf = self.get_webcam_frame()
                if webcam_pixbuf:
                    GLib.idle_add(self.webcam_preview_area.queue_draw)
            time.sleep(0.03)  # Update at about 30 fps

    def on_webcam_preview_draw(self, widget, cr):
        if self.is_webcam_overlay and hasattr(self, 'webcam_pixbuf'):
            allocation = widget.get_allocation()
            scale_factor = min(allocation.width / self.webcam_pixbuf.get_width(),
                               allocation.height / self.webcam_pixbuf.get_height())
            
            new_width = int(self.webcam_pixbuf.get_width() * scale_factor)
            new_height = int(self.webcam_pixbuf.get_height() * scale_factor)
            
            scaled_pixbuf = self.webcam_pixbuf.scale_simple(new_width, new_height, GdkPixbuf.InterpType.BILINEAR)
            
            x = (allocation.width - new_width) / 2
            y = (allocation.height - new_height) / 2
            
            Gdk.cairo_set_source_pixbuf(cr, scaled_pixbuf, x, y)
            cr.paint()

    def get_webcam_frame(self):
        # Implement this method to capture a frame from the webcam
        # You can use OpenCV or GStreamer to capture the frame
        # For this example, we'll just create a dummy pixbuf
        return GdkPixbuf.Pixbuf.new(GdkPixbuf.Colorspace.RGB, False, 8, 640, 480)


    def get_webcam_position(self, screen_width, screen_height):
        position = self.webcam_position_combo.get_active_text()
        webcam_width, webcam_height = self.calculate_webcam_size(screen_width, screen_height)

        if position == "top-left":
            return "10", "10"
        elif position == "top-right":
            return f"{screen_width - webcam_width - 10}", "10"
        elif position == "bottom-left":
            return "10", f"{screen_height - webcam_height - 10}"
        elif position == "bottom-right":
            return f"{screen_width - webcam_width - 10}", f"{screen_height - webcam_height - 10}"
        elif position == "center":
            return f"{(screen_width - webcam_width) // 2}", f"{(screen_height - webcam_height) // 2}"
        else:
            return "10", "10"  # Default to top-left if position is not recognized





    def on_webcam_size_changed(self, scale):
        self.webcam_size_percentage = scale.get_value()
        self.update_preview_position_and_size()
        self.update_tray_tooltip()

    def on_webcam_position_changed(self, combo):
        self.update_preview_position_and_size()
        self.update_tray_tooltip()



    def calculate_webcam_size(self, screen_width, screen_height):
        webcam_width = int(screen_width * (self.webcam_size_percentage / 100))
        webcam_height = int(webcam_height * (self.webcam_size_percentage / 100))
        return self.ensure_even_dimensions(webcam_width, webcam_height)



    def on_webcam_overlay_toggled(self, button):
        self.is_webcam_overlay = button.get_active()
        if self.is_webcam_overlay:
            # Disable and hide the "Show Webcam Preview" button
            self.preview_webcam_button.set_sensitive(False)
            self.preview_webcam_button.set_visible(False)
            # Close the webcam preview if it's open
            self.close_webcam_preview()
        else:
            # Enable and show the "Show Webcam Preview" button
            self.preview_webcam_button.set_sensitive(True)
            self.preview_webcam_button.set_visible(True)
        self.update_tray_tooltip()



    def set_webcam_position(self, widget, position):
        if widget.get_active():
            self.webcam_position_combo.set_active(self.webcam_positions.index(position))
            self.update_tray_tooltip()

    def set_webcam_size(self, widget, size):
        if widget.get_active():
            self.webcam_size_percentage = size
            self.webcam_size_scale.set_value(size)
            self.update_tray_tooltip()


    def draw_webcam_overlay(self, cr, width, height, x_offset, y_offset, scale_x, scale_y):
        if self.camera_window_id:
            webcam_pixbuf = self.get_window_screenshot(self.camera_window_id)
            if webcam_pixbuf:
                webcam_width, webcam_height = self.calculate_webcam_size(width, height)
                scaled_webcam = webcam_pixbuf.scale_simple(webcam_width, webcam_height, GdkPixbuf.InterpType.BILINEAR)
                
                position = self.webcam_position_combo.get_active_text()
                x, y = self.calculate_webcam_position(scaled_webcam, width, height, position)
                
                cr.save()
                cr.translate(x_offset, y_offset)
                cr.scale(scale_x, scale_y)
                Gdk.cairo_set_source_pixbuf(cr, scaled_webcam, x, y)
                cr.paint()
                cr.restore()

    def calculate_webcam_position(self, webcam_pixbuf, width, height, position):
        webcam_width = webcam_pixbuf.get_width()
        webcam_height = webcam_pixbuf.get_height()
        
        if position == "top-left":
            return 10, 10
        elif position == "top-right":
            return width - webcam_width - 10, 10
        elif position == "bottom-left":
            return 10, height - webcam_height - 10
        elif position == "bottom-right":
            return width - webcam_width - 10, height - webcam_height - 10
        elif position == "center":
            return (width - webcam_width) // 2, (height - webcam_height) // 2
        else:
            return 10, 10  # Default to top-left if position is not recognized


    def get_window_screenshot(self, window_id):
        try:
            root = Gdk.get_default_root_window()
            display = Gdk.Display.get_default()
            screen = display.get_default_screen()
            
            window = None
            for w in screen.get_window_stack():
                if w.get_xid() == int(window_id):
                    window = w
                    break
            
            if window:
                x, y, width, height = window.get_geometry()
                pixbuf = Gdk.pixbuf_get_from_window(root, x, y, width, height)
                return pixbuf
            else:
                logging.error(f"Window with ID {window_id} not found")
                return None
        except Exception as e:
            logging.error(f"Error capturing window screenshot: {e}")
            return None



#-------------------------------End-------------------------

#--------------------Specific Overlays----------------

    def draw_text_overlay(self, cr, width, height):
        text = self.overlay_text_entry.get_text()
        font_size = self.font_size_spinbutton.get_value_as_int()
        position = self.text_position_combo.get_active_text()

        cr.set_source_rgb(1, 1, 1)  # White text
        cr.select_font_face("Sans", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
        cr.set_font_size(font_size)

        x, y = self.calculate_text_position(cr, text, width, height, position, font_size)

        cr.move_to(x, y)
        cr.show_text(text)


    def draw_image_overlay(self, cr, width, height):
        if not hasattr(self, 'image_path') or not self.image_path or not os.path.exists(self.image_path):
            return

        try:
            pixbuf = GdkPixbuf.Pixbuf.new_from_file(self.image_path)
            
            # Calculate the new size based on the scale value
            scale_factor = self.image_size_percentage / 100.0
            original_width = pixbuf.get_width()
            original_height = pixbuf.get_height()
            new_width = int(original_width * scale_factor)
            new_height = int(original_height * scale_factor)
            
            # Ensure the new size doesn't exceed the preview area
            max_width = width * 0.8  # Limit to 80% of preview width
            max_height = height * 0.8  # Limit to 80% of preview height
            if new_width > max_width or new_height > max_height:
                scale = min(max_width / new_width, max_height / new_height)
                new_width = int(new_width * scale)
                new_height = int(new_height * scale)
            
            # Scale the image
            scaled_pixbuf = pixbuf.scale_simple(new_width, new_height, GdkPixbuf.InterpType.BILINEAR)
            
            # Calculate position
            x, y = self.calculate_image_position(scaled_pixbuf, width, height)
            
            # Draw the image
            Gdk.cairo_set_source_pixbuf(cr, scaled_pixbuf, x, y)
            cr.paint()
            
        except GLib.Error as e:
            print(f"Error loading or drawing image: {e}")




    def update_image_size_percentage(self, percentage):
        self.image_size_percentage = percentage
        self.image_size_scale.set_value(percentage)
        logging.info(f"Image size percentage updated to: {percentage}%")
        if self.preview_active:
            self.preview_area.queue_draw()
        self.update_tray_tooltip()



    def draw_webcam_overlay(self, cr, width, height):
        if self.is_webcam_overlay and hasattr(self, 'webcam_pixbuf'):
            webcam_width = int(width * (self.webcam_size_percentage / 100))
            webcam_height = int(webcam_width / (self.webcam_pixbuf.get_width() / self.webcam_pixbuf.get_height()))
            
            scaled_webcam = self.webcam_pixbuf.scale_simple(webcam_width, webcam_height, GdkPixbuf.InterpType.BILINEAR)
            
            position = self.webcam_position_combo.get_active_text()
            x, y = self.calculate_webcam_position(scaled_webcam, width, height, position)
            
            Gdk.cairo_set_source_pixbuf(cr, scaled_webcam, x, y)
            cr.paint()


#--------------------Specific Overlays-----------------------------------

#----------------------Webcam Overlay For Previews-----------------------






#----------------------Webcam Overlay For Previews-----------------------


    def on_overlay_type_changed(self, widget):
        if widget.get_active_text() == "Text":
            self.text_overlay_grid.show()
            self.image_overlay_grid.hide()
        else:
            self.text_overlay_grid.hide()
            self.image_overlay_grid.show()


    def on_choose_image_clicked(self, widget):
        dialog = Gtk.FileChooserDialog(
            title="Please choose an image file",
            parent=self,
            action=Gtk.FileChooserAction.OPEN
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OPEN, Gtk.ResponseType.OK
        )

        filter_image = Gtk.FileFilter()
        filter_image.set_name("Image files")
        filter_image.add_mime_type("image/jpeg")
        filter_image.add_mime_type("image/png")
        filter_image.add_pattern("*.jpg")
        filter_image.add_pattern("*.jpeg")
        filter_image.add_pattern("*.png")
        dialog.add_filter(filter_image)

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            file_path = dialog.get_filename()
            self.image_path_entry.set_text(file_path)
            self.status_label.set_text(f"Image selected: {os.path.basename(file_path)}")
            self.update_image_size_percentage(10)  # Set initial size to 10%
        elif response == Gtk.ResponseType.CANCEL:
            self.status_label.set_text("Image selection cancelled")

        dialog.destroy()


#---------------------Combined Overlay Start-----------------------------------------

    def create_preview_tab(self):
        preview_grid = Gtk.Grid()
        preview_grid.set_column_spacing(10)
        preview_grid.set_row_spacing(10)

        # Monitor selection
        monitor_label = Gtk.Label(label="Select Monitor to Preview:")
        preview_grid.attach(monitor_label, 0, 0, 1, 1)

        self.preview_monitor_combo = Gtk.ComboBoxText()
        if self.monitors:
            for monitor in self.monitors:
                self.preview_monitor_combo.append_text(monitor['name'])
            self.preview_monitor_combo.set_active(0)
            self.preview_monitor_combo.connect("changed", self.on_preview_monitor_changed)
        else:
            self.preview_monitor_combo.append_text("No monitors detected")
            self.preview_monitor_combo.set_active(0)
            self.preview_monitor_combo.set_sensitive(False)
        preview_grid.attach(self.preview_monitor_combo, 1, 0, 3, 1)

        # Preview area
        self.preview_area = Gtk.DrawingArea()
        self.preview_area.set_size_request(900, 500)
        self.preview_area.connect('draw', self.on_preview_draw)
        preview_grid.attach(self.preview_area, 0, 1, 4, 1)

        # Preview controls
        controls_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        
        start_preview_button = Gtk.Button(label="Start Preview")
        start_preview_button.connect("clicked", self.start_preview)
        controls_box.pack_start(start_preview_button, True, True, 0)

        stop_preview_button = Gtk.Button(label="Stop Preview")
        stop_preview_button.connect("clicked", self.stop_preview)
        controls_box.pack_start(stop_preview_button, True, True, 0)

        self.preview_overlay_toggle = Gtk.CheckButton(label="Show Overlays")
        self.preview_overlay_toggle.connect("toggled", self.on_preview_overlay_toggled)
        controls_box.pack_start(self.preview_overlay_toggle, True, True, 0)

        preview_grid.attach(controls_box, 0, 2, 4, 1)

        # Overlay settings
        overlay_frame = Gtk.Frame(label="Overlay Settings")
        overlay_grid = Gtk.Grid()
        overlay_grid.set_column_spacing(20)
        overlay_grid.set_row_spacing(10)
        overlay_frame.add(overlay_grid)

        self.enable_overlay_checkbox = Gtk.CheckButton(label="Enable Global Overlay")
        self.enable_overlay_checkbox.connect("toggled", self.on_global_overlay_toggled)
        overlay_grid.attach(self.enable_overlay_checkbox, 0, 0, 4, 1)

        # Text overlay settings
        text_frame = Gtk.Frame(label="Text Overlay")
        text_grid = Gtk.Grid()
        text_grid.set_column_spacing(10)
        text_grid.set_row_spacing(10)
        text_frame.add(text_grid)

        self.enable_text_overlay = Gtk.CheckButton(label="Enable Text Overlay")
        self.enable_text_overlay.connect("toggled", self.on_text_overlay_toggled)
        text_grid.attach(self.enable_text_overlay, 0, 0, 2, 1)

        text_label = Gtk.Label(label="Text:")
        text_grid.attach(text_label, 0, 1, 1, 1)

        self.overlay_text_entry = Gtk.Entry()
        self.overlay_text_entry.connect("changed", self.on_overlay_settings_changed)
        text_grid.attach(self.overlay_text_entry, 1, 1, 1, 1)

        font_size_label = Gtk.Label(label="Font Size:")
        text_grid.attach(font_size_label, 0, 2, 1, 1)

        self.font_size_spinbutton = Gtk.SpinButton.new_with_range(8, 72, 1)
        self.font_size_spinbutton.set_value(24)
        self.font_size_spinbutton.connect("value-changed", self.on_overlay_settings_changed)
        text_grid.attach(self.font_size_spinbutton, 1, 2, 1, 1)

        text_position_label = Gtk.Label(label="Position:")
        text_grid.attach(text_position_label, 0, 3, 1, 1)

        self.text_position_combo = Gtk.ComboBoxText()
        positions = ["top-left", "top-center", "top-right", "bottom-left", "bottom-center", "bottom-right"]
        for pos in positions:
            self.text_position_combo.append_text(pos)
        self.text_position_combo.set_active(0)
        self.text_position_combo.connect("changed", self.on_overlay_settings_changed)
        text_grid.attach(self.text_position_combo, 1, 3, 1, 1)

        overlay_grid.attach(text_frame, 0, 1, 2, 1)

        # Image overlay settings
        image_frame = Gtk.Frame(label="Image Overlay")
        image_grid = Gtk.Grid()
        image_grid.set_column_spacing(10)
        image_grid.set_row_spacing(10)
        image_frame.add(image_grid)

        self.enable_image_overlay = Gtk.CheckButton(label="Enable Image Overlay")
        self.enable_image_overlay.connect("toggled", self.on_image_overlay_toggled)
        image_grid.attach(self.enable_image_overlay, 0, 0, 3, 1)

        image_label = Gtk.Label(label="Image:")
        image_grid.attach(image_label, 0, 1, 1, 1)

        self.image_path_entry = Gtk.Entry()
        self.image_path_entry.set_editable(False)
        image_grid.attach(self.image_path_entry, 1, 1, 1, 1)

        choose_image_button = Gtk.Button(label="Choose")
        choose_image_button.connect("clicked", self.on_choose_image_clicked)
        image_grid.attach(choose_image_button, 2, 1, 1, 1)

        image_size_label = Gtk.Label(label="Size:")
        image_grid.attach(image_size_label, 0, 2, 1, 1)

        self.image_size_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 10, 100, 1)
        self.image_size_scale.set_value(25)
        self.image_size_scale.connect("value-changed", self.on_overlay_settings_changed)
        image_grid.attach(self.image_size_scale, 1, 2, 2, 1)

        image_position_label = Gtk.Label(label="Position:")
        image_grid.attach(image_position_label, 0, 3, 1, 1)

        self.image_position_combo = Gtk.ComboBoxText()
        for pos in positions:
            self.image_position_combo.append_text(pos)
        self.image_position_combo.set_active(0)
        self.image_position_combo.connect("changed", self.on_overlay_settings_changed)
        image_grid.attach(self.image_position_combo, 1, 3, 2, 1)

        overlay_grid.attach(image_frame, 2, 1, 2, 1)

        preview_grid.attach(overlay_frame, 0, 3, 4, 1)

        return preview_grid

    def on_global_overlay_toggled(self, button):
        is_enabled = button.get_active()
        self.enable_text_overlay.set_sensitive(is_enabled)
        self.enable_image_overlay.set_sensitive(is_enabled)
        self.update_overlay_settings()

    def on_text_overlay_toggled(self, button):
        is_enabled = button.get_active()
        self.overlay_text_entry.set_sensitive(is_enabled)
        self.font_size_spinbutton.set_sensitive(is_enabled)
        self.text_position_combo.set_sensitive(is_enabled)
        self.update_overlay_settings()

    def on_image_overlay_toggled(self, button):
        is_enabled = button.get_active()
        self.image_path_entry.set_sensitive(is_enabled)
        self.image_size_scale.set_sensitive(is_enabled)
        self.image_position_combo.set_sensitive(is_enabled)
        self.update_overlay_settings()

    def update_overlay_settings(self):
        global_overlay_enabled = self.enable_overlay_checkbox.get_active()
        text_overlay_enabled = global_overlay_enabled and self.enable_text_overlay.get_active()
        image_overlay_enabled = global_overlay_enabled and self.enable_image_overlay.get_active()

        self.text_overlay_active = text_overlay_enabled
        self.image_overlay_active = image_overlay_enabled

        if text_overlay_enabled:
            self.overlay_text = self.overlay_text_entry.get_text()
            self.font_size = self.font_size_spinbutton.get_value_as_int()
            self.text_position = self.text_position_combo.get_active_text()
        else:
            self.overlay_text = ""
            self.font_size = 24  # Default font size
            self.text_position = "top-left"  # Default position

        if image_overlay_enabled:
            self.image_path = self.image_path_entry.get_text()
            self.image_size_percentage = self.image_size_scale.get_value()  # Update this line
            self.image_position = self.image_position_combo.get_active_text()
        else:
            self.image_path = ""
            self.image_size_percentage = 50  # Default size (50%)
            self.image_position = "top-left"  # Default position

        # Log the current settings for debugging
        print(f"Text Overlay: {text_overlay_enabled}")
        if text_overlay_enabled:
            print(f"  Text: {self.overlay_text}")
            print(f"  Font Size: {self.font_size}")
            print(f"  Position: {self.text_position}")
        
        print(f"Image Overlay: {image_overlay_enabled}")
        if image_overlay_enabled:
            print(f"  Image Path: {self.image_path}")
            print(f"  Image Size: {self.image_size_percentage}%")
            print(f"  Position: {self.image_position}")

        # Trigger a redraw of the preview
        if hasattr(self, 'preview_area'):
            self.preview_area.queue_draw()

    def on_overlay_settings_changed(self, widget):
        self.update_overlay_settings()

    def on_choose_image_clicked(self, button):
        dialog = Gtk.FileChooserDialog(
            title="Please choose an image file",
            parent=self.get_toplevel(),
            action=Gtk.FileChooserAction.OPEN
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OPEN, Gtk.ResponseType.OK
        )

        filter_image = Gtk.FileFilter()
        filter_image.set_name("Image files")
        filter_image.add_mime_type("image/jpeg")
        filter_image.add_mime_type("image/png")
        dialog.add_filter(filter_image)

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            file_path = dialog.get_filename()
            self.image_path_entry.set_text(file_path)
            self.update_overlay_settings()
        
        dialog.destroy()    


#---------------------Combined Overlay End-----------------------------------------

    def on_preview_monitor_changed(self, combo):
        self.selected_preview_monitor = self.monitors[combo.get_active()]
        if self.preview_active:
            self.stop_preview()
            self.start_preview(None)

    def start_preview(self, widget):
        if not self.preview_active:
            self.preview_active = True
            self.preview_thread = threading.Thread(target=self.preview_loop)
            self.preview_thread.start()
            print("Started preview loop")


    def stop_preview(self, widget=None):
        if not self.preview_active:
            return

        self.preview_active = False
        if self.preview_thread is not None:
            self.preview_thread.join()
            self.preview_thread = None
        GLib.idle_add(self.clear_preview_area)


    def clear_preview_area(self):
        with self.preview_lock:
            self.preview_pixbuf = None
        self.preview_area.queue_draw()




    def take_screenshot(self):
        root_window = Gdk.get_default_root_window()
        monitor = self.selected_preview_monitor['geometry']
        pixbuf = Gdk.pixbuf_get_from_window(root_window, monitor.x, monitor.y, monitor.width, monitor.height)
        return pixbuf



    def cleanup_preview(self):
        if hasattr(self, 'preview_thread') and self.preview_thread is not None:
            self.preview_active = False
            self.preview_thread.join()
        if hasattr(self, 'preview_pixbuf'):
            self.preview_pixbuf = None


    def on_preview_overlay_toggled(self, button):
        self.preview_area.queue_draw()



    def extract_camera_index(self, camera_text):
        match = re.search(r'/dev/video(\d+)', camera_text)
        if match:
            return int(match.group(1))
        else:
            raise ValueError(f"No valid camera index found in: {camera_text}")

    def show_camera_window(self, widget):
        selected_camera = "/dev/video0"  # Example camera device
        resolution = "640x480"
        command = [
            'ffplay', '-f', 'v4l2', '-video_size', resolution, '-i', selected_camera,
            '-vf', 'hflip', '-noborder', '-fflags', 'nobuffer', '-flags', 'low_delay', '-framedrop',
            '-window_title', 'WebcamOverlay'
        ]

        self.camera_window = subprocess.Popen(command)
        time.sleep(1)  # Give time for the window to open

        self.apply_webcam_overlay_settings()

    def apply_webcam_overlay_settings(self):
        # Get the window ID using xwininfo
        try:
            xwininfo_output = subprocess.check_output(['xwininfo', '-name', 'WebcamOverlay']).decode('utf-8')
            window_id_match = re.search(r'Window id: (0x[0-9a-f]+)', xwininfo_output)
            if window_id_match:
                self.camera_window_id = window_id_match.group(1)
                self.set_webcam_overlay_position()
                self.set_webcam_overlay_size()
            else:
                logging.error("Failed to get window ID for WebcamOverlay")
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to get window info: {e}")

    def set_webcam_overlay_position(self, widget=None):
        if hasattr(self, 'camera_window_id'):
            x, y = self.webcam_overlay_position
            subprocess.run(['xdotool', 'windowmove', self.camera_window_id, str(x), str(y)])
        else:
            logging.error("Camera window ID not set. Cannot position webcam overlay.")

    def set_webcam_overlay_size(self, widget=None):
        if hasattr(self, 'camera_window_id'):
            size = self.webcam_overlay_size
            # Assuming you want to scale the window to a percentage of the screen size
            screen = Gdk.Screen.get_default()
            width = screen.get_width() * size // 100
            height = screen.get_height() * size // 100
            subprocess.run(['xdotool', 'windowsize', self.camera_window_id, str(width), str(height)])
        else:
            logging.error("Camera window ID not set. Cannot resize webcam overlay.")






#----------------Monitor Control----------------------------


    def get_available_monitors(self):
        display = Gdk.Display.get_default()
        monitors = []
        for i in range(display.get_n_monitors()):
            monitor = display.get_monitor(i)
            geometry = monitor.get_geometry()
            monitors.append({
                'index': i,
                'name': f"Monitor {i+1}",
                'geometry': geometry
            })
        return monitors


    def get_monitors(self):
        display = Gdk.Display.get_default()
        monitors = []
        for i in range(display.get_n_monitors()):
            monitor = display.get_monitor(i)
            geometry = monitor.get_geometry()
            monitors.append({
                'index': i,
                'name': f"Monitor {i+1}",
                'geometry': geometry
            })
        return monitors

#---------------Monitor End--------------------------------

    def update_video_stats(self):
        if self.is_recording and self.output_filename and os.path.exists(self.output_filename):
            file_size = os.path.getsize(self.output_filename)
            elapsed_time = time.time() - self.start_time
            bitrate = (file_size * 8) / (elapsed_time * 1000)  # in kbps
            
            # Get additional information
            fps = 30  # Assuming 30 FPS, adjust if you have a variable for this
            video_codec = self.video_codecs[self.video_codec_combo.get_active()]
            audio_codec = self.audio_codecs[self.audio_codec_combo.get_active()]
            resolution = self.recording_size_combo.get_active_text()
            
            return {
                "size": self.convert_size(file_size),
                "duration": self.format_time(elapsed_time),
                "bitrate": f"{bitrate:.2f} kbps",
                "fps": f"{fps}",
                "video": video_codec,
                "audio": audio_codec,
                "res": resolution
            }
        else:
            return {key: "N/A" for key in ["size", "duration", "bitrate", "fps", "video", "audio", "res"]}

        return self.is_recording  # Keep updating if still recording

    def update_video_stats_display(self):
        stats = self.update_video_stats()
        
        for key, value in stats.items():
            label = getattr(self, f"{key}_value_label", None)
            if label:
                GLib.idle_add(label.set_text, value)
        
        return True  # Keep updating



    def create_stat_label_pair(self, container, label_text, initial_value):
        label = Gtk.Label(label=label_text)
        value_label = Gtk.Label(label=initial_value)
        
        # Store the value label as an attribute for later updates
        setattr(self, f"{label_text.lower().rstrip(':')}_value_label", value_label)
        
        box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        box.pack_start(label, False, False, 0)
        box.pack_start(value_label, False, False, 0)
        
        container.pack_start(box, False, False, 0)


#-----------------Volume Controls-------------------------





    def get_default_sink(self):
        try:
            output = subprocess.check_output(['pactl', 'get-default-sink']).decode('utf-8').strip()
            return output
        except subprocess.CalledProcessError:
            print("Error getting default sink")
            return None

    def get_default_source(self):
        try:
            output = subprocess.check_output(['pactl', 'get-default-source']).decode('utf-8').strip()
            return output
        except subprocess.CalledProcessError:
            print("Error getting default source")
            return None

    def get_volume(self, device):
        try:
            output = subprocess.check_output(['pactl', 'get-sink-volume', device]).decode('utf-8')
            # Use regular expression to find the volume percentage
            match = re.search(r'(\d+)%', output)
            if match:
                return int(match.group(1))
            else:
                print(f"Couldn't parse volume from output: {output}")
                return 100  # Default to 100% if parsing fails
        except subprocess.CalledProcessError:
            print(f"Error getting volume for {device}")
            return 100  # Default to 100% if there's an error

    def get_mic_level(self, device):
        try:
            output = subprocess.check_output(['pactl', 'get-source-volume', device]).decode('utf-8')
            # Use regular expression to find the volume percentage
            match = re.search(r'(\d+)%', output)
            if match:
                return int(match.group(1))
            else:
                print(f"Couldn't parse microphone level from output: {output}")
                return 100  # Default to 100% if parsing fails
        except subprocess.CalledProcessError:
            print(f"Error getting microphone level for {device}")
            return 100  # Default to 100% if there's an error

    def on_volume_changed(self, scale):
        volume = int(scale.get_value())
        sink = self.get_default_sink()
        if sink:
            try:
                subprocess.run(['pactl', 'set-sink-volume', sink, f'{volume}%'])
                print(f"Volume changed to {volume}%")
                self.update_tray_tooltip()  # Add this line
            except subprocess.CalledProcessError:
                print("Error setting volume")

    def on_mic_changed(self, scale):
        mic_level = int(scale.get_value())
        source = self.get_default_source()
        if source:
            try:
                subprocess.run(['pactl', 'set-source-volume', source, f'{mic_level}%'])
                print(f"Microphone level changed to {mic_level}%")
                self.update_tray_tooltip()  # Add this line
            except subprocess.CalledProcessError:
                print("Error setting microphone level")

    def update_volume_mic_sliders(self):
        sink = self.get_default_sink()
        source = self.get_default_source()
        
        if sink:
            current_volume = self.get_volume(sink)
            print(f"Current volume: {current_volume}%")
            self.volume_scale.set_value(current_volume)
        else:
            print("No default sink found")
        
        if source:
            current_mic_level = self.get_mic_level(source)
            print(f"Current mic level: {current_mic_level}%")
            self.mic_scale.set_value(current_mic_level)
        else:
            print("No default source found")
        
        self.update_tray_tooltip()  # Add this line
        
        return True  # Return True to keep the timeout running




#--------------------End Volume Controls-------------------

    def preview_loop(self):
        while self.preview_active:
            try:
                screenshot = self.take_screenshot()
                with self.preview_lock:
                    self.preview_pixbuf = screenshot
                GLib.idle_add(self.preview_area.queue_draw)
                time.sleep(0.033)  # Aim for ~30 FPS
            except Exception as e:
                logging.error(f"Error in preview loop: {e}")
                break  # Exit the loop if there's an error


        with self.preview_lock:
            if self.preview_pixbuf:
                monitor_geometry = self.selected_preview_monitor['geometry']
                aspect_ratio = monitor_geometry.width / monitor_geometry.height

                preview_width = allocation.width
                preview_height = int(preview_width / aspect_ratio)

                if preview_height > allocation.height:
                    preview_height = allocation.height
                    preview_width = int(preview_height * aspect_ratio)

                scale_x = preview_width / self.preview_pixbuf.get_width()
                scale_y = preview_height / self.preview_pixbuf.get_height()

                scaled_pixbuf = self.preview_pixbuf.scale_simple(preview_width, preview_height, GdkPixbuf.InterpType.BILINEAR)

                x_offset = (allocation.width - preview_width) // 2
                y_offset = (allocation.height - preview_height) // 2

                Gdk.cairo_set_source_pixbuf(cr, scaled_pixbuf, x_offset, y_offset)
                cr.paint()

                # Draw overlays if enabled
                if self.preview_overlay_toggle.get_active():
                    self.draw_overlays(cr, preview_width, preview_height)


                # Add this at the end of the on_preview_draw method
                if self.is_webcam_overlay:
                    self.draw_webcam_overlay(cr, preview_width, preview_height, x_offset, y_offset, scale_x, scale_y)



    def initialize_preview_monitor_combo(self):
        combo = Gtk.ComboBoxText()
        if self.monitors:
            for monitor in self.monitors:
                combo.append_text(monitor['name'])
            combo.set_active(0)
        else:
            combo.append_text("No monitors detected")
            combo.set_active(0)
            combo.set_sensitive(False)
        return combo




    def on_custom_save_toggled(self, button):
        self.use_custom_save = button.get_active()
        self.custom_filename_entry.set_sensitive(self.use_custom_save)
        self.choose_location_button.set_sensitive(self.use_custom_save)
        self.update_tray_tooltip()

    def on_choose_location_clicked(self, button):
        dialog = Gtk.FileChooserDialog(
            title="Choose Save Location",
            parent=self,
            action=Gtk.FileChooserAction.SELECT_FOLDER,
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OPEN, Gtk.ResponseType.OK
        )
        
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            self.custom_save_location = dialog.get_filename()
            self.save_location_label.set_text(self.custom_save_location)
            self.update_tray_tooltip()
        
        dialog.destroy()

    def on_custom_save_toggled_tray(self, widget):
        self.use_custom_save = widget.get_active()
        self.custom_save_checkbox.set_active(self.use_custom_save)
        self.on_custom_save_toggled(self.custom_save_checkbox)






    # Additional methods go here

    def get_available_monitors(self):
        display = Gdk.Display.get_default()
        monitors = []
        for i in range(display.get_n_monitors()):
            monitor = display.get_monitor(i)
            geometry = monitor.get_geometry()
            monitors.append({
                'index': i,
                'name': f"Monitor {i+1}",
                'geometry': geometry
            })
        return monitors


    def set_monitor(self, widget, monitor_index):
        if widget.get_active():
            self.monitor_combo.set_active(monitor_index)
            self.update_tray_tooltip()


    def on_combobox_changed(self, combo):
        self.update_tray_tooltip()
        self.update_tray_selection()




    def update_recent_recording_info_label(self):
        if self.completed_recordings:
            most_recent_recording = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)[0][0]
            if os.path.exists(most_recent_recording):
                recent_recording_filename = os.path.basename(most_recent_recording)
                self.recent_recording_info_label.set_text(f"Recent Recording: {recent_recording_filename}")
            else:
                self.recent_recording_info_label.set_text("Recent recording file not found")
        else:
            self.recent_recording_info_label.set_text("No recent recording")





    def on_window_delete_event(self, widget, event):
        self.cleanup_preview()
        self.hide()
        return True

    def on_journaling_mode_toggled(self, button):
        self.is_journal_mode = button.get_active()

    def get_available_resolutions(self):
        try:
            output = subprocess.check_output(['xrandr']).decode('utf-8')
            resolutions = re.findall(r'(\d+x\d+)\s+\d+\.\d+\*', output)
            return [(res, res) for res in resolutions]
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting available resolutions: {e}")
            return []

    def get_available_audio_inputs(self):
        try:
            output = subprocess.check_output(['pactl', 'list', 'sources']).decode('utf-8')
            inputs = re.findall(r'Name: (.+)', output)
            logging.debug(f"Available audio inputs: {inputs}")
            return inputs
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting available audio inputs: {e}")
            return []

    def get_active_windows(self):
        try:
            output = subprocess.check_output(['wmctrl', '-l']).decode('utf-8')
            windows = re.findall(r'0x[0-9a-fA-F]+\s+\d+\s+\S+\s+(.+)', output)
            return windows
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting active windows: {e}")
            return []

    def update_active_windows(self):
        self.active_window_combo.remove_all()
        active_windows = self.get_active_windows()
        for window in active_windows:
            self.active_window_combo.append_text(window)
        self.active_window_combo.set_active(0)

    def refresh_windows(self, widget):
        self.update_active_windows()
        self.status_label.set_text("Window list refreshed.")

    def cleanup_on_exit(self, signum=None, frame=None):
        logging.info("Starting cleanup process...")
        
        # Stop all ongoing recordings
        if self.is_recording:
            logging.info("Stopping ongoing recording...")
            self.stop_recording(None)
            logging.info("Recording stopped.")
        
        # Stop any ongoing "Start Now" recordings
        if self.is_recording:
            self.stop_recording(None)


        # Stop all threads
        logging.info("Stopping active threads...")
        self.preview_active = False
        if hasattr(self, 'preview_thread') and self.preview_thread:
            self.preview_thread.join(timeout=5)
            logging.info("Preview thread stopped.")
        
        # Remove all GLib timeouts
        logging.info("Removing GLib timeouts...")
        timeout_ids = [self.volume_update_timeout, self.tray_update_timeout]  # Add all timeout IDs here
        for timeout_id in timeout_ids:
            try:
                if timeout_id is not None and GLib.MainContext.default().find_source_by_id(timeout_id):
                    GLib.source_remove(timeout_id)
                    logging.info(f"Removed timeout source {timeout_id}")
                else:
                    logging.info(f"Timeout source {timeout_id} not found or already removed")
            except Exception as e:
                logging.warning(f"Error removing timeout source {timeout_id}: {e}")
        
        # Terminate FFmpeg processes
        if self.ffmpeg_process:
            logging.info("Terminating FFmpeg process...")
            try:
                self.close_camera_window(None)
                self.ffmpeg_process.terminate()
                self.ffmpeg_process.wait(timeout=20)
                logging.info("FFmpeg process terminated successfully.")
            except subprocess.TimeoutExpired:
                logging.warning("FFmpeg process termination timed out. Attempting to kill with pkill...")
                try:
                    subprocess.run(['pkill', '-f', 'ffmpeg'])
                    logging.info("FFmpeg process killed with pkill.")
                except Exception as e:
                    logging.error(f"Error killing FFmpeg process with pkill: {e}")
            except Exception as e:
                logging.error(f"Error terminating FFmpeg process: {e}")
            finally:
                self.ffmpeg_process = None
        
        # Close ffplay windows
        logging.info("Closing ffplay windows...")
        try:
            subprocess.run(['pkill', '-f', 'ffplay'])
            logging.info("ffplay windows closed.")
        except Exception as e:
            logging.error(f"Error closing ffplay windows: {e}")
        
        # Clean up Gstreamer pipeline
        if hasattr(self, 'audio_monitor'):
            logging.info("Cleaning up Gstreamer pipeline...")
            self.audio_monitor.set_state(Gst.State.NULL)
            del self.audio_monitor
            logging.info("Gstreamer pipeline cleaned up.")
        
        # Remove tray icon
        if hasattr(self, 'indicator') and self.indicator:
            logging.info("Removing tray icon...")
            self.indicator.set_status(AppIndicator3.IndicatorStatus.PASSIVE)
            del self.indicator
            logging.info("Tray icon removed.")
        
        # Release webcam
        if hasattr(self, 'webcam_capture'):
            logging.info("Releasing webcam...")
            self.webcam_capture.release()
            logging.info("Webcam released.")
        
        # Close webcam preview
        logging.info("Closing webcam preview...")
        self.close_webcam_preview()
        logging.info("Webcam preview closed.")
        
        # Quit Gtk main loop if it's running
        if Gtk.main_level() > 0:
            logging.info("Quitting Gtk main loop...")
            Gtk.main_quit()
            logging.info("Gtk main loop quit.")
        
        logging.info("Cleanup process completed.")


        
    def get_screen_resolution(self):
        display = Gdk.Display.get_default()
        monitor = display.get_primary_monitor()
        geometry = monitor.get_geometry()
        return geometry.width, geometry.height

    def calculate_webcam_size(self, screen_width, screen_height):
        webcam_width = int(screen_width * (self.webcam_size_percentage / 100))
        webcam_height = int(screen_height * (self.webcam_size_percentage / 100))
        return self.ensure_even_dimensions(webcam_width, webcam_height)

    def stop_all_threads(self):
        self.is_recording = False
        self.preview_active = False
        # Add flags to stop other loops if necessary


    def ensure_even_dimensions(self, width, height):
        return (
            width if width % 2 == 0 else width - 1,
            height if height % 2 == 0 else height - 1
        )


    def check_ffmpeg_fps_mode_support(self):
        try:
            help_output = subprocess.check_output(["ffmpeg", "-h", "filter=fps"], universal_newlines=True)
            fps_mode_supported = "fps_mode" in help_output
            logging.info(f"fps_mode supported: {fps_mode_supported}")
            return fps_mode_supported
        except subprocess.CalledProcessError as e:
            logging.error(f"Error checking FFmpeg capabilities: {e}")
            return False





    def start_recording(self, widget):
        if not self.is_recording:
            logging.debug("Record button clicked, starting recording...")
            logging.info(f"Starting recording. Current image size percentage: {self.image_size_percentage}%")

            # Disable record buttons
            self.settings_record_button.set_sensitive(False)
            self.controls_record_button.set_sensitive(False)
            if hasattr(self, 'tray_record_item'):
                self.tray_record_item.set_sensitive(False)

            logging.debug(f"Settings record button sensitivity: {self.settings_record_button.get_sensitive()}")
            logging.debug(f"Controls record button sensitivity: {self.controls_record_button.get_sensitive()}")

            self.is_recording = True
            self.start_time = time.time()
            self.recording_start_time = datetime.now()

            # Get recording settings
            selected_size = self.recording_size_combo.get_active_text()
            selected_output_format = ["mkv", "mp4", "webm"][self.output_format_combo.get_active()]
            selected_recording_area = self.recording_areas[self.recording_area_combo.get_active()]
            selected_video_codec = self.video_codecs[self.video_codec_combo.get_active()]
            selected_audio_codec = self.audio_codecs[self.audio_codec_combo.get_active()]
            selected_audio_config = self.audio_input_configs[self.audio_input_config_combo.get_active()]
            selected_streaming_service = self.streaming_combo.get_active_text()
            streaming_key = self.streaming_key_entry.get_text()

            self.is_custom_region = (selected_recording_area == "Custom Region")

            if selected_size is None:
                self.status_label.set_text("Error: No recording size selected.")
                return

            if "x" in selected_size:
                width, height = map(int, selected_size.split('x'))
                width, height = self.ensure_even_dimensions(width, height)
            else:
                self.status_label.set_text("Error: Invalid recording size.")
                return

            # Prepare output filename
            timestamp = time.strftime("%m-%d-%Y_%I-%M-%S%p")
            if self.use_custom_save:
                custom_filename = self.custom_filename_entry.get_text()
                if custom_filename:
                    filename_prefix = custom_filename
                else:
                    filename_prefix = "recording"
                self.output_filename = os.path.join(self.custom_save_location, f"{filename_prefix}_{timestamp}.{selected_output_format}")
            else:
                filename_prefix = "Journal" if self.is_journal_mode else "recording"
                if self.is_keep_mode:
                    filename_prefix += "_keep"
                self.output_filename = os.path.join(self.output_directory, f"{filename_prefix}_{timestamp}.{selected_output_format}")

            os.makedirs(os.path.dirname(self.output_filename), exist_ok=True)

            # Prepare audio inputs
            primary_audio_input = self.audio_inputs[self.audio_input_combo.get_active()]
            secondary_audio_input = self.secondary_audio_inputs[self.secondary_audio_input_combo.get_active()]

            logging.info(f"Primary audio input: {primary_audio_input}")
            logging.info(f"Secondary audio input: {secondary_audio_input}")

            # Prepare FFmpeg command
            input_args = ["-thread_queue_size", "1024"]

            if self.is_webcam_overlay:
                input_args.extend(["-itsoffset", "-1.1"])

            # Get selected monitor
            selected_monitor = self.monitors[self.monitor_combo.get_active()]
            monitor_geometry = selected_monitor['geometry']
            monitor_x, monitor_y = monitor_geometry.x, monitor_geometry.y

            # Add video input based on selected recording area
            if selected_recording_area == "Full Screen":
                width, height = self.ensure_even_dimensions(monitor_geometry.width, monitor_geometry.height)
                input_args.extend(["-f", "x11grab", "-framerate", "30", "-video_size", f"{width}x{height}", "-i", f":0.0+{monitor_x},{monitor_y}"])
            elif selected_recording_area == "Camera Only":
                selected_camera = self.camera_combo.get_active_text()
                if selected_camera:
                    try:
                        camera_index = self.extract_camera_index(selected_camera)
                        device = f"/dev/video{camera_index}"
                        resolution = self.camera_resolution_combo.get_active_text()
                        width, height = map(int, resolution.split('x'))
                        width, height = self.ensure_even_dimensions(width, height)
                        input_args.extend(["-f", "v4l2", "-video_size", f"{width}x{height}", "-framerate", "30", "-i", device])
                        input_args.extend(["-f", "alsa", "-i", "hw:1"])
                    except ValueError as e:
                        self.status_label.set_text(f"Error: {e}")
                        return
                else:
                    self.status_label.set_text("Error: No camera selected.")
                    return
            elif selected_recording_area == "Active Window":
                selected_window = self.active_window_combo.get_active_text()
                if selected_window:
                    window_info = self.get_window_info_by_name(selected_window)
                    if window_info:
                        x_pos, y_pos, width, height = window_info
                        width, height = self.ensure_even_dimensions(width, height)
                        input_args.extend(["-f", "x11grab", "-framerate", "30", "-video_size", f"{width}x{height}", "-i", f":0.0+{x_pos+monitor_x},{y_pos+monitor_y}"])
                else:
                    self.status_label.set_text("Error: No active window selected.")
                    return
            elif selected_recording_area == "Custom Region":
                if self.recording_region:
                    x, y, w, h = self.recording_region
                    w, h = self.ensure_even_dimensions(w, h)
                    input_args.extend(["-f", "x11grab", "-framerate", "30", "-video_size", f"{w}x{h}", "-i", f":0.0+{x+monitor_x},{y+monitor_y}"])
                else:
                    self.status_label.set_text("Error: No custom region selected.")
                    return

            # Prepare audio filters
            audio_filters = "aresample=async=1:min_hard_comp=0.100000:first_pts=0"
            if selected_audio_codec == "aac":
                audio_filters += ", volume=1.5, equalizer=f=1000:t=q:w=1:g=-5"

            # Add audio input based on selected configuration
            audio_args = []
            if selected_audio_config == "Primary Only":
                audio_args.extend(["-f", "pulse", "-i", primary_audio_input, "-af", audio_filters])
            elif selected_audio_config == "Secondary Only":
                audio_args.extend(["-f", "pulse", "-i", secondary_audio_input, "-af", audio_filters])

            buffer_args = ["-bufsize", "750M", "-rtbufsize", "750M"]
            sync_args = ["-fps_mode", "vfr"]

            # Initialize the filter graph and input counter
            filter_graph = "[0:v]fps=fps=30[v0];"
            input_count = 1  # Start with 1 for the main video input

            if self.is_webcam_overlay:
                selected_camera = self.camera_combo.get_active_text()
                if selected_camera:
                    try:
                        camera_index = self.extract_camera_index(selected_camera)
                        webcam_device = f"/dev/video{camera_index}"
                        screen_width, screen_height = self.get_screen_resolution()
                        webcam_width, webcam_height = self.calculate_webcam_size(screen_width, screen_height)
                        input_args.extend([
                            "-f", "v4l2",
                            "-video_size", f"{webcam_width}x{webcam_height}",
                            "-framerate", "30",
                            "-i", webcam_device
                        ])
                        
                        webcam_position = self.webcam_position_combo.get_active_text()
                        if webcam_position == "top-left":
                            overlay_position = "10:10"
                        elif webcam_position == "top-right":
                            overlay_position = "main_w-overlay_w-10:10"
                        elif webcam_position == "bottom-left":
                            overlay_position = "10:main_h-overlay_h-10"
                        elif webcam_position == "bottom-right":
                            overlay_position = "main_w-overlay_w-10:main_h-overlay_h-10"
                        elif webcam_position == "center":
                            overlay_position = "(main_w-overlay_w)/2:(main_h-overlay_h)/2"
                        else:
                            overlay_position = "main_w-overlay_w-10:main_h-overlay_h-10"  # Default to bottom-right

                        filter_graph += f"[{input_count}:v]hflip,fps=fps=30[webcam];"  # Add hflip here
                        filter_graph += f"[v0][webcam]overlay={overlay_position}[v1];"
                        input_count += 1
                    except ValueError as e:
                        self.status_label.set_text(f"Error: {e}")
                        return
                else:
                    self.status_label.set_text("Error: No webcam selected.")
                    return
            else:
                filter_graph += "[v0]null[v1];"

            # Check if overlay is enabled and add to filter graph if so
            if self.enable_overlay_checkbox.get_active():
                if self.enable_text_overlay.get_active():
                    overlay_text = self.overlay_text_entry.get_text()
                    font_size = self.font_size_spinbutton.get_value_as_int()

                    # Define margin
                    margin = 20

                    position = self.text_position_combo.get_active_text()
                    if position.startswith("top"):
                        y_position = f"{margin}"  # Margin from the top
                    elif position.startswith("bottom"):
                        y_position = f"h - text_h - {margin}"  # Margin from the bottom
                    else:
                        y_position = "(h - text_h) / 2"  # Center

                    if position.endswith("left"):
                        x_position = f"{margin}"  # Margin from the left
                    elif position.endswith("right"):
                        x_position = f"w - text_w - {margin}"  # Margin from the right
                    else:
                        x_position = "(w - text_w) / 2"  # Center

                    filter_graph += (
                        f"[v1]drawtext=fontfile=/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf:"
                        f"fontsize={font_size}:"
                        f"fontcolor=white:box=1:boxcolor=black@0.5:boxborderw=5:"
                        f"text='{overlay_text}':x={x_position}:y={y_position}:"
                        f"shadowcolor=black@0.5:shadowx=2:shadowy=2:"
                        f"expansion=normal[vtext];"
                    )
                else:
                    filter_graph += "[v1]null[vtext];"

                if self.enable_image_overlay.get_active():
                    image_path = self.image_path_entry.get_text()
                    if image_path and os.path.isfile(image_path):
                        logging.info(f"Image overlay enabled. Path: {image_path}")
                        logging.info(f"Current image size percentage: {self.image_size_percentage}%")

                        position = self.image_position_combo.get_active_text()
                        if position == "top-left":
                            overlay_position = "10:10"
                        elif position == "top-right":
                            overlay_position = "main_w-overlay_w-10:10"
                        elif position == "bottom-left":
                            overlay_position = "10:main_h-overlay_h-10"
                        elif position == "bottom-right":
                            overlay_position = "main_w-overlay_w-10:main_h-overlay_h-10"
                        elif position == "top-center":
                            overlay_position = "(main_w-overlay_w)/2:10"
                        else:  # bottom-center
                            overlay_position = "(main_w-overlay_w)/2:main_h-overlay_h-10"

                        scale_factor = self.image_size_percentage / 100
                        logging.info(f"Calculated scale factor: {scale_factor}")

                        # Calculate the maximum allowed size for the overlay
                        max_width = int(width * 0.3)  # 30% of video width
                        max_height = int(height * 0.3)  # 30% of video height

                        filter_graph += (f"movie={image_path},"
                                         f"scale=iw*{scale_factor}:ih*{scale_factor},"
                                         f"scale=w='min({max_width},iw)':h='min({max_height},ih)':force_original_aspect_ratio=decrease[watermark];"
                                         f"[vtext][watermark]overlay={overlay_position}[vfinal];")

                        logging.info(f"FFmpeg filter graph for image overlay: {filter_graph}")
                    else:
                        self.status_label.set_text("Error: No valid image selected for overlay.")
                        filter_graph += "[vtext]null[vfinal];"
                else:
                    filter_graph += "[vtext]null[vfinal];"
            else:
                filter_graph += "[v1]null[vfinal];"

            # Ensure the filter graph ends with a named output
            filter_graph += "[vfinal]format=yuv420p[outv]"

            filter_args = ["-filter_complex", filter_graph]

            # Prepare output arguments
            output_args = [
                "-map", "[outv]",
                "-map", f"{input_count}:a",  # Use the correct audio input index
                "-c:v", selected_video_codec,
                "-c:a", selected_audio_codec,
                "-preset", "fast",
                "-crf", "23"
            ]

            # Combine all arguments into final command
            command = ["ffmpeg", "-y"] + input_args + audio_args + buffer_args + sync_args + filter_args + output_args + [self.output_filename]

            # Check FFmpeg capabilities and adjust command if necessary
            fps_mode_supported = self.check_ffmpeg_fps_mode_support()
            if not fps_mode_supported:
                command = [arg for arg in command if arg != "-fps_mode" and arg != "vfr"]
                logging.info("Removed -fps_mode vfr from FFmpeg command due to lack of support")

            logging.info(f"FFmpeg command: {' '.join(command)}")

            # Set up audio monitor for visualizer
            self.setup_audio_monitor()

    # Start recording process and monitoring threads
            threading.Thread(target=self.start_ffmpeg_process, args=(command,)).start()
            threading.Thread(target=self.monitor_file_size).start()
            threading.Thread(target=self.update_tray_info).start()

            # Start updating video stats
            GLib.timeout_add(1000, self.update_video_stats)

            self.update_tray_status(True)

            # Enable stop and pause buttons, disable resume button
            GLib.idle_add(self.stop_button.set_sensitive, True)
            GLib.idle_add(self.pause_button.set_sensitive, True)
            GLib.idle_add(self.resume_button.set_sensitive, False)

            # Handle timer if active
            if self.timer_active:
                hours = int(self.timer_hours_combo.get_active_text() or "0")
                minutes = int(self.timer_minutes_combo.get_active_text() or "0")
                self.timer_seconds = hours * 3600 + minutes * 60
                if self.timer_seconds <= 0:
                    logging.warning("Timer is active but duration is set to 0 seconds. No timer will be used.")
                    self.timer_active = False
                else:
                    logging.info(f"Timer active. Duration: {self.timer_seconds} seconds")
                    self.start_timer()
            else:
                logging.info("Timer not active")

            # Update UI
            GLib.idle_add(self.update_ui_for_recording_start)

            # Start dynamic tooltip updates
            if hasattr(self, 'tray_update_timeout') and self.tray_update_timeout is not None:
                GLib.source_remove(self.tray_update_timeout)
            self.tray_update_timeout = GLib.timeout_add(1000, self.update_tray_tooltip)

            # Update tray tooltip
            self.update_tray_tooltip()

        else:
            logging.warning("Attempted to start recording while already recording")
            self.status_label.set_text("Already recording")

#-------------------------TRIM METHOD-----------------------------

    def trim_video(self, widget):
        if not self.completed_recordings:
            self.status_label.set_text("No recordings available to trim.")
            return

        most_recent_recording = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)[0][0]
        
        dialog = VideoTrimmingDialog(self, most_recent_recording)
        response = dialog.run()

        if response == Gtk.ResponseType.OK:
            start_time, end_time = dialog.get_trim_times()
            dialog.destroy()

            # Perform trimming
            output_path = os.path.splitext(most_recent_recording)[0] + "_trimmed" + os.path.splitext(most_recent_recording)[1]
            command = [
                'ffmpeg', '-i', most_recent_recording,
                '-ss', str(start_time),
                '-to', str(end_time),
                '-c', 'copy',  # This copies the streams without re-encoding
                output_path
            ]

            try:
                subprocess.run(command, check=True)
                self.status_label.set_text(f"Video trimmed successfully: {output_path}")
                # Add the trimmed video to completed recordings
                self.completed_recordings.append((output_path, time.time()))
                self.update_recent_recording_info_label()
            except subprocess.CalledProcessError as e:
                self.status_label.set_text(f"Error trimming video: {e}")
        else:
            dialog.destroy()

#-------------------------END TRIM METHOD-------------------------






    def setup_audio_monitor(self):
        pipeline_str = (
            f"pulsesrc device={self.audio_input_combo.get_active_text()} ! "
            "audioconvert ! audioresample ! audio/x-raw,channels=2,rate=44100 ! "
            "level name=level interval=100000000 ! "
            "fakesink"
        )
        self.audio_monitor = Gst.parse_launch(pipeline_str)
        bus = self.audio_monitor.get_bus()
        bus.add_signal_watch()
        bus.connect('message::element', self.on_audio_level)
        self.audio_monitor.set_state(Gst.State.PLAYING)
        def on_audio_level(self, bus, message):
            if message.get_structure().get_name() == 'level':
                structure = message.get_structure()
                level = structure.get_value('peak')[0]
                normalized_level = min(max(0, (level + 60) / 60), 1)  # Normalize to 0-1 range
                GLib.idle_add(self.audio_visualizer.update_level, normalized_level)


    def on_audio_level(self, bus, message):
        if message.get_structure().get_name() == 'level':
            structure = message.get_structure()
            peak_values = structure.get_value('peak')
            
            if peak_values and len(peak_values) >= 2:
                left_peak = peak_values[0]
                right_peak = peak_values[1]
                
                # Normalize levels to 0-1 range
                left_level = min(max(0, (left_peak + 60) / 60), 1)
                right_level = min(max(0, (right_peak + 60) / 60), 1)
                
                GLib.idle_add(self.audio_visualizer.update_levels, left_level, right_level)





    def start_timer(self):
        if self.timer_thread and self.timer_thread.is_alive():
            logging.info("Timer thread already running. Stopping existing timer.")
            self.timer_active = False
            self.timer_thread.join()

        self.timer_active = True
        self.timer_thread = threading.Thread(target=self.timer_countdown)
        self.timer_thread.start()
        logging.info("Timer thread started")



    def update_ui_for_recording_start(self):
        logging.debug("Updating UI for recording start...")
        
        # Update status label
        self.status_label.set_text("Recording...")
        
        # Disable record buttons
        self.settings_record_button.set_sensitive(False)
        self.controls_record_button.set_sensitive(False)
        
        # Enable stop buttons
        self.stop_button_settings.set_sensitive(True)
        self.stop_button.set_sensitive(True)
        
        # Update tray record item if it exists
        if hasattr(self, 'tray_record_item'):
            self.tray_record_item.set_sensitive(False)
        
        # Enable pause button, disable resume button
        self.pause_button.set_sensitive(True)
        self.resume_button.set_sensitive(False)
        
        # Update tray icon and tooltip
        self.update_tray_status(True)
        self.update_tray_tooltip()
        
        # If there's a timer active, update the timer display
        if self.timer_active:
            remaining_time = self.timer_seconds
            self.update_timer_display(remaining_time)
        
        # Update file size display (using existing method)
        if self.output_filename and os.path.exists(self.output_filename):
            size = os.path.getsize(self.output_filename)
            GLib.idle_add(self.file_size_label.set_text, f"File size: {self.convert_size(size)}")
        else:
            GLib.idle_add(self.file_size_label.set_text, "File size: N/A")
        
        # Update elapsed time display
        elapsed_time = time.time() - self.start_time
        GLib.idle_add(self.elapsed_time_menu_item.set_label, f"Elapsed Time: {self.format_time(elapsed_time)}")
        
        # Update video stats if applicable
        if hasattr(self, 'update_video_stats_display'):
            self.update_video_stats_display()
        
        # Ensure the window stays minimized if it was minimized before
        window = self.main_window.get_window()
        if window and window.get_state() & Gdk.WindowState.ICONIFIED:
            self.main_window.iconify()
        
        logging.debug("UI update for recording start completed")
        return False  # Important for GLib.idle_add



    def on_timer_toggled(self, button):
        self.timer_active = button.get_active()
        self.tray_timer_item.set_active(self.timer_active)  # Synchronize with tray icon menu
        self.update_tray_tooltip()
        if self.timer_active:
            hours = int(self.timer_hours_combo.get_active_text() or "0")
            minutes = int(self.timer_minutes_combo.get_active_text() or "0")
            self.timer_seconds = hours * 3600 + minutes * 60
            self.update_timer_display(self.timer_seconds)
            self.timer_completed = False  # Reset the flag when timer is enabled
            if self.is_recording:
                self.start_timer()
            else:
                self.status_label.set_text("Timer enabled")
        else:
            self.status_label.set_text("Timer disabled")
            if self.timer_thread and self.timer_thread.is_alive():
                self.timer_thread.join()
            self.timer_thread = None
            self.timer_seconds = 0

    def on_timer_toggled_tray(self, widget):
        self.timer_active = widget.get_active()
        self.timer_checkbox.set_active(self.timer_active)  # Synchronize with main window
        self.on_timer_toggled(self.timer_checkbox)

    def de_toggle_timer_checkbox(self):
        self.timer_checkbox.set_active(False)
        self.tray_timer_item.set_active(False)  # Synchronize with tray icon menu
        self.timer_hours_combo.set_active(0)  # Reset hours to 0
        self.timer_minutes_combo.set_active(0)  # Reset minutes to 0
        self.on_timer_toggled(self.timer_checkbox)  # Call this to update any related UI elements
        self.update_tray_tooltip()  # Update the tray tooltip to reflect the changes


    def on_timer_changed(self, widget):
        if self.timer_active:
            hours = int(self.timer_hours_combo.get_active_text() or "0")
            minutes = int(self.timer_minutes_combo.get_active_text() or "0")
            self.timer_seconds = hours * 3600 + minutes * 60
            self.update_timer_display(self.timer_seconds)
            self.update_tray_tooltip()
            if self.is_recording and not self.timer_thread:
                self.start_timer()




    def timer_countdown(self):
        logging.info(f"Starting timer countdown from {self.timer_seconds} seconds")
        start_time = time.time()
        while self.is_recording and self.timer_active and self.timer_seconds > 0:
            elapsed_time = time.time() - start_time
            remaining = max(0, self.timer_seconds - elapsed_time)

            logging.debug(f"Timer countdown: remaining={remaining:.2f}, is_recording={self.is_recording}, timer_active={self.timer_active}")

            if remaining <= 0:
                logging.info("Timer reached 0. Attempting to stop recording.")
                self.timer_completed = True
                GLib.idle_add(self.update_timer_display, 0)
                GLib.idle_add(self.safe_stop_recording)
                GLib.idle_add(self.de_toggle_timer_checkbox)  # Deactivate timer in both main window and tray icon menu
                break
            else:
                GLib.idle_add(self.update_timer_display, int(remaining))

            time.sleep(1)

        if not self.is_recording:
            logging.info("Timer countdown interrupted: Recording stopped")
        elif not self.timer_active:
            logging.info("Timer countdown interrupted: Timer deactivated")
        else:
            logging.info("Timer countdown finished")

        self.timer_thread = None
        logging.info("Timer thread ended")


    def de_toggle_timer_checkbox(self):
        self.timer_checkbox.set_active(False)
        self.timer_hours_combo.set_active(0)  # Reset hours to 0
        self.timer_minutes_combo.set_active(0)  # Reset minutes to 0
        self.on_timer_toggled(self.timer_checkbox)  # Call this to update any related UI elements

        # Update the tray icon menu item
        if hasattr(self, 'tray_timer_item'):
            self.tray_timer_item.set_active(False)





    def safe_stop_recording(self):
        logging.info("safe_stop_recording called")
        if self.is_recording:
            self.stop_recording(None)
        else:
            logging.warning("safe_stop_recording called but is_recording is already False")
        # De-toggle the timer in the main window
        self.timer_checkbox.set_active(False)
        # De-toggle the timer in the tray icon menu
        for item in self.indicator.get_menu().get_children():
            if isinstance(item, Gtk.CheckMenuItem) and item.get_label() == "Enable Timer":
                item.set_active(False)
        return False  # Important for GLib.idle_add






    def update_timer_display(self, remaining_seconds):
        minutes, seconds = divmod(remaining_seconds, 60)
        hours, minutes = divmod(minutes, 60)
        timer_text = f"Timer Remaining: {hours:02d}:{minutes:02d}:{seconds:02d}"
        self.status_label.set_text(f"Recording... {timer_text}")
        return False


    def get_webcam_position(self, screen_width, screen_height):
        position = self.webcam_position_combo.get_active_text()
        webcam_width, webcam_height = map(int, self.webcam_resolution.split('x'))
        
        # Ensure the webcam overlay doesn't exceed a certain percentage of the screen
        max_width = int(screen_width * 0.3)
        max_height = int(screen_height * 0.3)
        
        if webcam_width > max_width or webcam_height > max_height:
            scale = min(max_width / webcam_width, max_height / webcam_height)
            webcam_width = int(webcam_width * scale)
            webcam_height = int(webcam_height * scale)

        if position == "top-left":
            return f"10:10:{webcam_width}:{webcam_height}"
        elif position == "top-right":
            return f"{screen_width - webcam_width - 10}:10:{webcam_width}:{webcam_height}"
        elif position == "bottom-left":
            return f"10:{screen_height - webcam_height - 10}:{webcam_width}:{webcam_height}"
        elif position == "bottom-right":
            return f"{screen_width - webcam_width - 10}:{screen_height - webcam_height - 10}:{webcam_width}:{webcam_height}"
        elif position == "center":
            return f"{(screen_width - webcam_width) // 2}:{(screen_height - webcam_height) // 2}:{webcam_width}:{webcam_height}"
        else:
            return f"10:10:{webcam_width}:{webcam_height}"  # Default to top-left if position is not recognized






    def get_webcam_position(self, screen_width, screen_height):
        position = self.webcam_position_combo.get_active_text()
        webcam_width, webcam_height = self.calculate_webcam_size(screen_width, screen_height)

        if position == "top-left":
            return f"10:10"
        elif position == "top-right":
            return f"{screen_width - webcam_width - 10}:10"
        elif position == "bottom-left":
            return f"10:{screen_height - webcam_height - 10}"
        elif position == "bottom-right":
            return f"{screen_width - webcam_width - 10}:{screen_height - webcam_height - 10}"
        elif position == "center":
            return f"{(screen_width - webcam_width) // 2}:{(screen_height - webcam_height) // 2}"
        else:
            return f"10:10"  # Default to top-left if position is not recognized


    def start_ffmpeg_process(self, command):
        try:
            self.ffmpeg_process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.monitor_ffmpeg_output()
            self.ffmpeg_process.wait()
        except Exception as e:
            logging.error(f"Error starting FFmpeg process: {e}")
        finally:
            self.is_recording = False
            GLib.idle_add(self.update_status, "Recording stopped.")

    def monitor_ffmpeg_output(self):
        if self.ffmpeg_process:
            while self.ffmpeg_process.poll() is None:
                rlist, _, _ = select.select([self.ffmpeg_process.stdout, self.ffmpeg_process.stderr], [], [])
                for stream in rlist:
                    output = stream.readline()
                    if output:
                        print(output.strip().decode('utf-8'))

    def pause_recording(self, widget):
        if self.is_recording and not self.is_paused:
            if self.ffmpeg_process:
                self.ffmpeg_process.send_signal(signal.SIGSTOP)
                self.is_paused = True
                self.status_label.set_text("Recording paused.")
                self.update_tray_status(paused=True)
                self.pause_button.set_sensitive(False)
                self.resume_button.set_sensitive(True)

    def resume_recording(self, widget):
        if self.is_recording and self.is_paused:
            if self.ffmpeg_process:
                self.ffmpeg_process.send_signal(signal.SIGCONT)
                self.is_paused = False
                self.status_label.set_text("Recording resumed.")
                self.update_tray_status(resumed=True)
                self.pause_button.set_sensitive(True)
                self.resume_button.set_sensitive(False)

    def update_status(self, status_text):
        self.status_label.set_text(status_text)
        self.settings_record_button.set_sensitive(True)
        self.controls_record_button.set_sensitive(True)
        self.stop_button.set_sensitive(False)
        self.pause_button.set_sensitive(False)
        self.resume_button.set_sensitive(False)
        if hasattr(self, 'tray_record_item'):
            self.tray_record_item.set_sensitive(True)
        self.update_recent_recording_menu_item()
        return False

    def update_tray_info(self):
        while self.is_recording:
            file_size_text = f"File Size: {self.convert_size(self.file_size)}"
            elapsed_time = time.time() - self.start_time
            elapsed_time_text = f"Elapsed Time: {self.format_time(elapsed_time)}"
            recording_status_text = "Status: Recording..."

            if self.completed_recordings:
                sorted_recordings = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)
                most_recent_path = sorted_recordings[0][0]
                most_recent_filename = os.path.basename(most_recent_path)
                try:
                    if os.path.exists(most_recent_path):
                        most_recent_file_size = self.convert_size(os.path.getsize(most_recent_path))
                        recent_recording_text = f"Recent Recording: {most_recent_filename} ({most_recent_file_size})"
                    else:
                        recent_recording_text = f"Recent Recording: {most_recent_filename} (File not found)"
                except Exception as e:
                    logging.error(f"Error accessing recent recording: {e}")
                    recent_recording_text = "Error accessing recent recording"
            else:
                recent_recording_text = "No recent recording"

            GLib.idle_add(self.file_size_menu_item.set_label, file_size_text)
            GLib.idle_add(self.elapsed_time_menu_item.set_label, elapsed_time_text)
            GLib.idle_add(self.recording_status_menu_item.set_label, recording_status_text)
            GLib.idle_add(self.recent_recording_menu_item.set_label, recent_recording_text)

            time.sleep(1)

    def update_tray_status(self, recording=False, paused=False, resumed=False, duration=None, file_size=None):
        if recording:
            status = "Recording..."
            icon_name = "media-record"
            if duration is not None:
                status += f" Duration: {self.format_time(duration)}"
            if file_size is not None:
                status += f" File Size: {self.convert_size(file_size)}"
        elif paused:
            status = "Recording paused"
            icon_name = "media-playback-pause"
        elif resumed:
            status = "Recording resumed"
            icon_name = "media-record"
        else:
            status = "Not Recording"
            icon_name = "media-playback-stop"

        GLib.idle_add(self.recording_status_menu_item.set_label, status)
        GLib.idle_add(self.indicator.set_icon_full, icon_name, status)

#--------------Update Tray Tooltip-------------------------------------

    def update_tray_tooltip(self):
        settings = []

        def safe_get_text(combo):
            try:
                return combo.get_active_text() or "Not selected"
            except:
                return "Error"

        # Add monitor status first
        if hasattr(self, 'monitor_combo'):
            selected_monitor = safe_get_text(self.monitor_combo)
            settings.append(f"Selected Monitor: {selected_monitor}")

        attribute_map = {
            'recording_size_combo': "Recording Size",
            'recording_area_combo': "Recording Area",
            'video_codec_combo': "Video Codec",
            'output_format_combo': "Output Format",
            'audio_input_config_combo': "Audio Input Config",
            'audio_codec_combo': "Audio Codec",
            'audio_input_combo': "Primary Audio Input",
            'secondary_audio_input_combo': "Secondary Audio Input",
            'active_window_combo': "Active Window",
            'camera_combo': "Camera",
            'camera_resolution_combo': "Camera Resolution",
            'webcam_position_combo': "Webcam Position",
            'streaming_combo': "Streaming Service"
        }

        for attr, label in attribute_map.items():
            if hasattr(self, attr):
                combo = getattr(self, attr)
                if isinstance(combo, Gtk.ComboBoxText):
                    settings.append(f"{label}: {safe_get_text(combo)}")

        # Add volume and microphone levels
        if hasattr(self, 'volume_scale'):
            volume_level = int(self.volume_scale.get_value())
            settings.append(f"Volume Level: {volume_level}%")

        if hasattr(self, 'mic_scale'):
            mic_level = int(self.mic_scale.get_value())
            settings.append(f"Microphone Level: {mic_level}%")

        if hasattr(self, 'is_webcam_overlay'):
            settings.append(f"Webcam Overlay: {'Enabled' if self.is_webcam_overlay else 'Disabled'}")

        if hasattr(self, 'streaming_key_entry'):
            key = self.streaming_key_entry.get_text()
            settings.append(f"Streaming Key: {'******' if key else 'N/A'}")

        if hasattr(self, 'timer_active') and self.timer_active:
            if hasattr(self, 'timer_hours_combo') and hasattr(self, 'timer_minutes_combo'):
                hours = safe_get_text(self.timer_hours_combo)
                minutes = safe_get_text(self.timer_minutes_combo)
                timer_set_for = f"{hours}h {minutes}m"
                settings.append(f"Timer Active: Yes\nTimer Set For: {timer_set_for}")
        else:
            settings.append("Timer Active: No")

        # Add custom save information
        if self.use_custom_save:
            settings.append("Custom Save: Enabled")
            settings.append(f"Save Location: {self.custom_save_location}")
            custom_filename = self.custom_filename_entry.get_text()
            settings.append(f"Custom Filename: {custom_filename if custom_filename else 'Not set'}")
        else:
            settings.append("Custom Save: Disabled")

        # Add image overlay size information
        if hasattr(self, 'enable_image_overlay') and self.enable_image_overlay.get_active():
            settings.append(f"Image Overlay Size: {self.image_size_percentage}%")

        # Add scheduler information
        countdown = self.get_countdown_to_next_event()
        if countdown:
            next_event = min(self.scheduled_recordings, key=lambda x: x['time'])
            settings.append(f"Next scheduled recording:")
            settings.append(f"  Date: {next_event['display_date']}")
            settings.append(f"  Time: {next_event['display_time']}")
            settings.append(f"  Duration: {next_event['display_duration']}")
            settings.append(f"  Countdown: {countdown}")
        else:
            settings.append("No scheduled recordings")

        self.static_tooltip_text = "\n".join(settings)

        if self.is_recording:
            current_time = time.time()
            elapsed_time = current_time - self.start_time
            
            dynamic_info = ["Recording Info"]
            
            # Add recording start time
            start_time_str = self.recording_start_time.strftime('%Y-%m-%d %I:%M:%S %p')
            dynamic_info.append(f"Started: {start_time_str}")
            
            # Add scheduled end time if it exists
            if self.scheduled_end_time:
                end_time_str = self.scheduled_end_time.strftime('%Y-%m-%d %I:%M:%S %p')
                dynamic_info.append(f"Scheduled End: {end_time_str}")
            
            dynamic_info.append(f"Elapsed Time: {self.format_time(int(elapsed_time))}")
            
            if self.scheduled_end_time:
                remaining = int((self.scheduled_end_time - datetime.now()).total_seconds())
                time_remaining = self.format_time(remaining) if remaining > 0 else "Overtime"
                dynamic_info.append(f"Time Remaining: {time_remaining}")
            
            if self.timer_active:
                timer_remaining = self.format_time(max(int(self.timer_seconds - elapsed_time), 0))
                dynamic_info.append(f"Timer Remaining: {timer_remaining}")
            
            if self.output_filename and os.path.exists(self.output_filename):
                file_size = self.convert_size(os.path.getsize(self.output_filename))
                dynamic_info.append(f"File Size: {file_size}")
                dynamic_info.append(f"File Name: {os.path.basename(self.output_filename)}")
            
            if self.is_paused:
                dynamic_info.insert(0, "Recording Paused")
            
            dynamic_text = "\n".join(dynamic_info)
            tooltip_text = f"{self.static_tooltip_text}\n\n{dynamic_text}"
        else:
            tooltip_text = self.static_tooltip_text

        # Check if the indicator attribute exists before using it
        if hasattr(self, 'indicator') and self.indicator:
            try:
                GLib.idle_add(self.indicator.set_title, tooltip_text)
            except Exception as e:
                print(f"Error setting indicator title: {e}")

        return True  # Keep the update loop running

    def format_time(self, seconds):
        hours, remainder = divmod(seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        return f"{hours:02d}:{minutes:02d}:{seconds:02d}"

    def convert_size(self, size_bytes):
        if size_bytes == 0:
            return "0 B"
        size_name = ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_name[i]}"





#--------------End Update Tray Tooltip-------------------------------------


    def some_method_that_starts_recording(self):
        if not self.start_recording():
            # Handle the case where recording couldn't be started
            logging.warning("Failed to start recording")
            # Possibly update UI or take other actions



    def update_tray_tooltip_continuously(self):
        while self.is_recording or self.is_paused:
            file_size_text = f"File Size: {self.convert_size(self.file_size)}"
            elapsed_time = time.time() - self.start_time
            elapsed_time_text = f"Elapsed Time: {self.format_time(elapsed_time)}"
            file_name_text = f"File Name: {os.path.basename(self.output_filename) if self.output_filename else 'N/A'}"
            recording_status_text = "Recording Info" if self.is_recording else "Recording Paused"

            if self.timer_active:
                elapsed_time_since_start = time.time() - self.start_time
                timer_remaining_seconds = max(self.timer_seconds - elapsed_time_since_start, 0)
                timer_remaining = f"Timer Remaining: {self.format_time(timer_remaining_seconds)}"
                tooltip_text = (
                    f"{self.static_tooltip_text}\n"
                    f"\n{recording_status_text}\n{file_name_text}\n{file_size_text}\n{elapsed_time_text}\n{timer_remaining}"
                )
            else:
                tooltip_text = (
                    f"{self.static_tooltip_text}\n"
                    f"\n{recording_status_text}\n{file_name_text}\n{file_size_text}\n{elapsed_time_text}"
                )

            # Check if the indicator attribute exists before using it
            if hasattr(self, 'indicator'):
                GLib.idle_add(self.indicator.set_title, tooltip_text)
            GLib.idle_add(self.elapsed_time_menu_item.set_label, elapsed_time_text)
            time.sleep(1)  # Update every second

        # After the recording has stopped
        file_size_text = f"File Size: {self.convert_size(self.file_size)}"
        elapsed_time = time.time() - self.start_time
        elapsed_time_text = f"Elapsed Time: {self.format_time(elapsed_time)}"
        file_name_text = f"File Name: {os.path.basename(self.output_filename) if self.output_filename else 'N/A'}"

        tooltip_text = (
            f"{self.static_tooltip_text}\n"
            f"\nRecording Stopped\n{file_name_text}\n{file_size_text}\n{elapsed_time_text}"
        )
        # Check if the indicator attribute exists before using it
        if hasattr(self, 'indicator'):
            GLib.idle_add(self.indicator.set_title, tooltip_text)
        GLib.idle_add(self.elapsed_time_menu_item.set_label, elapsed_time_text)




    #def update_recent_recordings_controls(self):
        #if not self.completed_recordings:
       #     self.recent_recordings_label_controls.set_text("Recent Recordings:\nNone")
        #else:
            #recent_recordings_text = "Recent Recordings:\n"
            #for recording, timestamp in sorted(self.completed_recordings, key=lambda x: x[1], reverse=True):
             #   filename = os.path.basename(recording)
             #   recent_recordings_text += f"{filename}\n"
            #self.recent_recordings_label_controls.set_text(recent_recordings_text)


    def stop_recording(self, widget=None, scheduled=False):
        if self.is_recording:
            logging.debug("Stopping recording...")
            self.is_recording = False

            # Disable stop button and enable record button
            self.stop_button_settings.set_sensitive(False)
            self.stop_button.set_sensitive(False)
            self.settings_record_button.set_sensitive(True)
            self.controls_record_button.set_sensitive(True)
            if hasattr(self, 'tray_record_item'):
                self.tray_record_item.set_sensitive(True)

            # Stop the FFmpeg recording process
            if self.ffmpeg_process:
                try:
                    logging.debug("Terminating ffmpeg process")
                    self.ffmpeg_process.terminate()
                    self.ffmpeg_process.wait(timeout=20)
                except subprocess.TimeoutExpired:
                    logging.warning("FFmpeg process termination timed out. Attempting to kill...")
                    try:
                        self.ffmpeg_process.kill()
                        self.ffmpeg_process.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        logging.error("FFmpeg process could not be killed.")
                    except Exception as e:
                        logging.error(f"Error killing FFmpeg process: {e}")
                except Exception as e:
                    logging.error(f"Error terminating FFmpeg process: {e}")
                finally:
                    self.ffmpeg_process = None
                    logging.debug("ffmpeg process terminated")

            # Stop the audio monitor for the visualizer
            if hasattr(self, 'audio_monitor'):
                self.audio_monitor.set_state(Gst.State.NULL)
                del self.audio_monitor

            # Add the recording to the recent recordings list
            if self.output_filename and os.path.exists(self.output_filename):
                self.completed_recordings.append((self.output_filename, time.time()))
                self.update_recent_recording_info_label()
                logging.info(f"Added recording to completed list: {self.output_filename}")
            else:
                logging.warning("Output file not found or not created")

            # Reset timer if it was active
            self.timer_active = False
            self.timer_seconds = 0
            if self.timer_thread is not None:
                try:
                    self.timer_thread.join(timeout=5)
                    if self.timer_thread.is_alive():
                        logging.warning("Timer thread did not finish in time")
                except Exception as e:
                    logging.error(f"Error while stopping timer thread: {e}")
            self.timer_thread = None

            # Reset recording area if it was a custom region
            if self.is_custom_region:
                self.reset_recording_area()

            # Update video stats one last time
            self.update_video_stats()
            self.update_video_stats_display()

            # If we were in Journal mode, exit it and restore overlay if needed
            if self.is_journal_mode:
                self.is_journal_mode = False
                self.journaling_mode_checkbox.set_active(False)
                
                # Re-enable overlay if it was initially enabled
                if self.overlay_was_enabled:
                    logging.info("Re-enabling overlay after Journal mode")
                    self.enable_overlay_checkbox.set_active(True)
                    if hasattr(self, 'tray_enable_overlay_item'):
                        self.tray_enable_overlay_item.set_active(True)
                
                # Reset the flag
                self.overlay_was_enabled = False

                # Close the camera window if it's still open
                if hasattr(self, 'camera_window') and self.camera_window:
                    self.camera_window.terminate()
                    self.camera_window = None

            # Update UI elements
            GLib.idle_add(self.update_ui_for_recording_stop)

            # Stop tray tooltip updates
            if hasattr(self, 'tray_update_timeout') and self.tray_update_timeout is not None:
                GLib.source_remove(self.tray_update_timeout)
            self.tray_update_timeout = None

            # Update tray tooltip one last time
            self.update_tray_tooltip()

            if scheduled:
                self.status_label.set_text("Scheduled recording completed.")
            else:
                self.status_label.set_text("Recording stopped.")

            logging.debug("Recording stop process completed")
        else:
            logging.warning("Attempted to stop recording, but no recording was in progress")

        # Ensure all flags and states are reset
        self.is_paused = False
        self.is_custom_region = False
        self.recording_region = None

        # If this was a scheduled recording, update the scheduler
        if scheduled:
            self.update_schedule_list()
            self.update_completed_schedule_list()

        return False  # For use with GLib.idle_add



    def update_ui_for_recording_stop(self):
        logging.debug("Updating UI for recording stop...")
        
        self.status_label.set_text("Recording stopped.")
        self.settings_record_button.set_sensitive(True)
        self.controls_record_button.set_sensitive(True)
        logging.debug(f"Settings record button sensitivity after stop: {self.settings_record_button.get_sensitive()}")
        logging.debug(f"Controls record button sensitivity after stop: {self.controls_record_button.get_sensitive()}")
        
        if hasattr(self, 'tray_record_item'):
            self.tray_record_item.set_sensitive(True)
        self.stop_button.set_sensitive(False)
        self.pause_button.set_sensitive(False)
        self.resume_button.set_sensitive(False)

        # Update file size and elapsed time one last time
        if self.output_filename and os.path.exists(self.output_filename):
            final_size = os.path.getsize(self.output_filename)
            self.file_size_label.set_text(f"File size: {self.convert_size(final_size)}")
        
        elapsed_time = time.time() - self.start_time
        self.elapsed_time_menu_item.set_label(f"Elapsed Time: {self.format_time(elapsed_time)}")

        # Reset timer if it was active
        if hasattr(self, 'timer_checkbox'):
            self.timer_checkbox.set_active(False)
            if hasattr(self, 'timer_hours_combo'):
                self.timer_hours_combo.set_active(0)
            if hasattr(self, 'timer_minutes_combo'):
                self.timer_minutes_combo.set_active(0)

        # Update tray icon and tooltip
        self.update_tray_status(False)
        self.update_tray_tooltip()
        
        # Update recent recording info label
        self.update_recent_recording_info_label()

        logging.debug("UI update for recording stop completed")
        return False  # Important for GLib.idle_add



    def stop_recording_from_timer(self):
        logging.info("stop_recording_from_timer called")
        self.stop_recording(None)
        return False  # Important for GLib.idle_add


    def de_toggle_timer_checkbox(self):
        self.timer_checkbox.set_active(False)
        self.timer_hours_combo.set_active(0)  # Reset hours to 0
        self.timer_minutes_combo.set_active(0)  # Reset minutes to 0
        self.on_timer_toggled(self.timer_checkbox)  # Call this to update any related UI elements
        self.update_tray_tooltip()  # Update the tray tooltip to reflect the changes




    def capture_active_window(self, widget):
        window_info = self.get_active_window_info()
        if window_info:
            x_pos, y_pos, width, height = window_info
            self.custom_region_start_x = x_pos
            self.custom_region_start_y = y_pos
            self.custom_region_end_x = x_pos + width
            self.custom_region_end_y = y_pos + height
            self.recording_region = (x_pos, y_pos, width, height)
            self.status_label.set_text("Active window captured for recording.")




    def get_active_window_info(self):
        try:
            output = subprocess.check_output(['xwininfo', '-id', self.get_active_window_id()]).decode('utf-8')
            x_pos = int(re.search(r'Absolute upper-left X:\s+(\d+)', output).group(1))
            y_pos = int(re.search(r'Absolute upper-left Y:\s+(\d+)', output).group(1))
            width = int(re.search(r'Width:\s+(\d+)', output).group(1))
            height = int(re.search(r'Height:\s+(\d+)', output).group(1))
            return (x_pos, y_pos, width, height)
        except Exception as e:
            self.status_label.set_text(f"Error getting active window info: {e}")
            return None

    def get_active_window_id(self):
        try:
            output = subprocess.check_output(['xdotool', 'getactivewindow']).decode('utf-8').strip()
            return output
        except Exception as e:
            self.status_label.set_text(f"Error getting active window ID: {e}")
            return None



    def get_window_info_by_name(self, window_name):
        window_id = self.get_window_id_by_name(window_name)
        if window_id:
            try:
                output = subprocess.check_output(['xwininfo', '-id', window_id]).decode('utf-8')
                x_pos = int(re.search(r'Absolute upper-left X:\s+(\d+)', output).group(1))
                y_pos = int(re.search(r'Absolute upper-left Y:\s+(\d+)', output).group(1))
                width = int(re.search(r'Width:\s+(\d+)', output).group(1))
                height = int(re.search(r'Height:\s+(\d+)', output).group(1))
                return (x_pos, y_pos, width, height)
            except Exception as e:
                self.status_label.set_text(f"Error getting window info by name: {e}")
                return None
        else:
            self.status_label.set_text("Error: Window not found.")
            return None

    def monitor_file_size(self):
        start_time = time.time()
        while self.is_recording:
            time.sleep(1)
            elapsed_time = time.time() - start_time
            if self.output_filename and os.path.exists(self.output_filename):
                size = os.path.getsize(self.output_filename)
                self.file_size = size
                GLib.idle_add(self.file_size_label.set_text, f"File size: {self.convert_size(size)}")
            else:
                GLib.idle_add(self.file_size_label.set_text, "File size: N/A")
            GLib.idle_add(self.status_label.set_text, f"Recording... Elapsed time: {self.format_time(elapsed_time)}")
            GLib.idle_add(self.elapsed_time_menu_item.set_label, f"Elapsed Time: {self.format_time(elapsed_time)}")

    def format_time(self, elapsed_time):
        minutes, seconds = divmod(elapsed_time, 60)
        hours, minutes = divmod(minutes, 60)
        return "{:02}:{:02}:{:02}".format(int(hours), int(minutes), int(seconds))

    def convert_size(self, size_bytes):
        if size_bytes == 0:
            return "0B"
        size_name = ("B", "KB", "MB", "GB", "TB")
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_name[i]}"



    def extract_camera_index(self, camera_text):
        match = re.search(r'/dev/video(\d+)', camera_text)
        if match:
            return int(match.group(1))
        else:
            raise ValueError(f"No valid camera index found in: {camera_text}")

    def show_camera_window(self, widget):
        selected_camera = self.camera_combo.get_active_text()
        selected_resolution = self.camera_resolution_combo.get_active_text()
        logging.debug(f"Selected camera: {selected_camera}, resolution: {selected_resolution}")
        if selected_camera:
            try:
                device_index = self.extract_camera_index(selected_camera)
                device = f"/dev/video{device_index}"
                logging.debug(f"Using device: {device}")
                resolution = selected_resolution if selected_resolution else "640x480"
                command = ['ffplay', '-f', 'v4l2', '-video_size', resolution, '-i', device, '-vf', 'hflip', '-noborder', '-fflags', 'nobuffer', '-flags', 'low_delay', '-framedrop', '-window_title', 'WebcamPreview']

                self.camera_window = subprocess.Popen(command)
                time.sleep(1)  # Give more time for the window to open
                
                # Get the window ID using xwininfo
                xwininfo_output = subprocess.check_output(['xwininfo', '-name', 'WebcamPreview']).decode('utf-8')
                window_id_match = re.search(r'Window id: (0x[0-9a-f]+)', xwininfo_output)
                if window_id_match:
                    self.camera_window_id = int(window_id_match.group(1), 16)
                    print(f"Camera window ID: {self.camera_window_id}")
                else:
                    logging.error("Failed to get window ID")
                
                self.bring_camera_window_to_front()
            except Exception as e:
                logging.error(f"Failed to open camera: {e}")
                self.status_label.set_text(f"Failed to open camera: {e}")
        else:
            logging.error("No camera selected")
            self.status_label.set_text("Error: No camera selected.")



    def bring_camera_window_to_front(self):
        if self.camera_window:
            try:
                output = subprocess.check_output(['xdotool', 'search', '--pid', str(self.camera_window.pid)]).decode('utf-8').strip()
                self.camera_window_id = output.split('\n')[-1]
                subprocess.run(['xdotool', 'windowactivate', '--sync', self.camera_window_id])
                subprocess.run(['xdotool', 'windowraise', self.camera_window_id])
                if self.is_camera_on_top:
                    subprocess.run(['xdotool', 'windowfocus', '--sync', self.camera_window_id])
                    subprocess.run(['xdotool', 'windowraise', self.camera_window_id])
                    subprocess.run(['wmctrl', '-i', '-r', self.camera_window_id, '-b', 'add,above'])
                else:
                    subprocess.run(['wmctrl', '-i', '-r', self.camera_window_id, '-b', 'remove,above'])
            except Exception as e:
                logging.error(f"Failed to bring camera window to front: {e}")

    def close_camera_window(self, widget):
        if self.camera_window:
            self.camera_window.terminate()
            self.camera_window = None
            self.camera_window_id = None
        else:
            command = ['pkill', '-f', 'ffplay -f v4l2']
            try:
                subprocess.run(command)
            except Exception as e:
                logging.error(f"Failed to close camera windows: {e}")

    def on_keep_camera_on_top_toggled(self, button):
        self.is_camera_on_top = button.get_active()
        self.bring_camera_window_to_front()

    def get_available_cameras_v4l2(self):
        try:
            output = subprocess.check_output(['v4l2-ctl', '--list-devices']).decode('utf-8')
            devices = re.findall(r'([^\n]+)\n\t([^\n]+)', output)
            logging.debug(f"Available cameras: {devices}")
            cameras = []
            for device in devices:
                cameras.append(f"{device[0]} ({device[1]})")
            return cameras
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting available cameras: {e}")
            return []

    def create_tray_icon(self):
        self.indicator = AppIndicator3.Indicator.new(
            "screen-recorder-indicator",
            "media-playback-stop",
            AppIndicator3.IndicatorCategory.APPLICATION_STATUS
        )
        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)

        menu = Gtk.Menu()

        show_item = Gtk.MenuItem()
        show_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        show_icon = Gtk.Image.new_from_icon_name("preferences-system", Gtk.IconSize.MENU)
        show_label = Gtk.Label("Main/Settings Window")
        show_box.pack_start(show_icon, False, False, 0)
        show_box.pack_start(show_label, False, False, 0)
        show_item.add(show_box)
        show_item.connect("activate", self.show_window)
        menu.append(show_item)

        # Timer configuration in tray
        self.tray_timer_item = Gtk.CheckMenuItem(label="Enable Timer")
        self.tray_timer_item.set_active(False)
        self.tray_timer_item.connect("toggled", self.on_timer_toggled_tray)
        menu.append(self.tray_timer_item)

        timer_hours_item = Gtk.ImageMenuItem(label="Set Timer Hours")
        timer_hours_submenu = Gtk.Menu()
        self.timer_hours_group = []
        for hour in range(24):
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.timer_hours_group else self.timer_hours_group[0], str(hour))
            item.connect("activate", self.set_timer_hours, hour)
            self.timer_hours_group.append(item)
            timer_hours_submenu.append(item)
        timer_hours_item.set_submenu(timer_hours_submenu)
        menu.append(timer_hours_item)

        timer_minutes_item = Gtk.ImageMenuItem(label="Set Timer Minutes")
        timer_minutes_submenu = Gtk.Menu()
        self.timer_minutes_group = []
        for minute in range(60):
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.timer_minutes_group else self.timer_minutes_group[0], str(minute))
            item.connect("activate", self.set_timer_minutes, minute)
            self.timer_minutes_group.append(item)
            timer_minutes_submenu.append(item)
        timer_minutes_item.set_submenu(timer_minutes_submenu)
        menu.append(timer_minutes_item)

        # Initialize monitor selection group
        self.monitor_group = []
        monitor_menu = Gtk.ImageMenuItem(label="Select Monitor")
        monitor_icon = Gtk.Image.new_from_icon_name("video-display", Gtk.IconSize.MENU)
        monitor_menu.set_image(monitor_icon)
        monitor_submenu = Gtk.Menu()

        for monitor in self.monitors:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.monitor_group else self.monitor_group[0], monitor['name'])
            item.connect("activate", self.set_monitor, monitor['index'])
            self.monitor_group.append(item)
            monitor_submenu.append(item)
        monitor_menu.set_submenu(monitor_submenu)
        menu.append(monitor_menu)

        # Initialize recording area group
        self.recording_area_group = []
        recording_area_menu = Gtk.ImageMenuItem(label="Select Recording Area")
        recording_area_icon = Gtk.Image.new_from_icon_name("video-display", Gtk.IconSize.MENU)
        recording_area_menu.set_image(recording_area_icon)
        recording_area_submenu = Gtk.Menu()

        full_screen_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "Full Screen")
        active_window_item = Gtk.RadioMenuItem.new_with_label_from_widget(full_screen_item, "Active Window")
        custom_region_item = Gtk.RadioMenuItem.new_with_label_from_widget(full_screen_item, "Custom Region")
        camera_only_item = Gtk.RadioMenuItem.new_with_label_from_widget(full_screen_item, "Camera Only")

        full_screen_item.connect("activate", self.set_recording_area, "Full Screen")
        active_window_item.connect("activate", self.set_recording_area, "Active Window")
        custom_region_item.connect("activate", self.set_recording_area, "Custom Region")
        camera_only_item.connect("activate", self.set_recording_area, "Camera Only")

        self.recording_area_group.extend([
            full_screen_item, active_window_item, custom_region_item, camera_only_item
        ])

        recording_area_submenu.append(full_screen_item)
        recording_area_submenu.append(active_window_item)
        recording_area_submenu.append(custom_region_item)
        recording_area_submenu.append(camera_only_item)

        recording_area_menu.set_submenu(recording_area_submenu)
        menu.append(recording_area_menu)

        # Initialize active window group
        self.active_window_group = []
        active_window_menu = Gtk.ImageMenuItem(label="Select Active Window")
        active_window_icon = Gtk.Image.new_from_icon_name("window", Gtk.IconSize.MENU)
        active_window_menu.set_image(active_window_icon)
        active_window_submenu = Gtk.Menu()

        active_windows = self.get_active_windows()
        for window in active_windows:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.active_window_group else self.active_window_group[0], window)
            item.connect("activate", self.set_active_window, window)
            self.active_window_group.append(item)
            active_window_submenu.append(item)
        active_window_menu.set_submenu(active_window_submenu)
        menu.append(active_window_menu)

        # Update the webcam position submenu in the tray icon
        webcam_position_menu = Gtk.ImageMenuItem(label="Webcam Position")
        webcam_position_icon = Gtk.Image.new_from_icon_name("camera-web", Gtk.IconSize.MENU)
        webcam_position_menu.set_image(webcam_position_icon)
        webcam_position_submenu = Gtk.Menu()

        self.webcam_position_group = []
        for position in self.webcam_positions:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(
                None if not self.webcam_position_group else self.webcam_position_group[0],
                position
            )
            item.connect("activate", self.set_webcam_position, position)
            self.webcam_position_group.append(item)
            webcam_position_submenu.append(item)

        webcam_position_menu.set_submenu(webcam_position_submenu)
        menu.append(webcam_position_menu)

        # Update the create_tray_icon method to add a submenu for webcam size
        webcam_size_menu = Gtk.MenuItem(label="Webcam Overlay Size")
        webcam_size_submenu = Gtk.Menu()

        for size in [10, 20, 30, 40, 50]:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(
                None if size == 10 else webcam_size_submenu.get_children()[0],
                f"{size}%"
            )
            item.connect("activate", self.set_webcam_size, size)
            webcam_size_submenu.append(item)

        webcam_size_menu.set_submenu(webcam_size_submenu)
        menu.append(webcam_size_menu)

        # Overlay settings
        overlay_menu = Gtk.MenuItem(label="Overlay Settings")
        overlay_submenu = Gtk.Menu()

        self.tray_enable_overlay_item = Gtk.CheckMenuItem(label="Enable Overlay")
        self.tray_enable_overlay_item.connect("toggled", self.on_tray_enable_overlay_toggled)
        overlay_submenu.append(self.tray_enable_overlay_item)

        overlay_type_item = Gtk.MenuItem(label="Set Overlay Type")
        overlay_type_item.connect("activate", self.on_tray_set_overlay_type)
        overlay_submenu.append(overlay_type_item)

        overlay_content_item = Gtk.MenuItem(label="Set Overlay Content")
        overlay_content_item.connect("activate", self.on_tray_set_overlay_content)
        overlay_submenu.append(overlay_content_item)

        overlay_menu.set_submenu(overlay_submenu)
        menu.append(overlay_menu)


        refresh_windows_item = Gtk.ImageMenuItem(label="Refresh Windows")
        refresh_icon = Gtk.Image.new_from_icon_name("view-refresh", Gtk.IconSize.MENU)
        refresh_windows_item.set_image(refresh_icon)
        refresh_windows_item.connect("activate", self.refresh_windows)
        menu.append(refresh_windows_item)

        # Initialize output format group
        self.output_format_group = []
        output_format_menu = Gtk.ImageMenuItem(label="Select Output Format")
        output_format_icon = Gtk.Image.new_from_icon_name("document-save", Gtk.IconSize.MENU)
        output_format_menu.set_image(output_format_icon)
        output_format_submenu = Gtk.Menu()

        mkv_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "mkv")
        mp4_item = Gtk.RadioMenuItem.new_with_label_from_widget(mkv_item, "mp4")
        webm_item = Gtk.RadioMenuItem.new_with_label_from_widget(mkv_item, "webm")
        mkv_item.set_active(True)
        mkv_item.connect("activate", self.set_output_format, "mkv")
        mp4_item.connect("activate", self.set_output_format, "mp4")
        webm_item.connect("activate", self.set_output_format, "webm")
        self.output_format_group.append(mkv_item)
        self.output_format_group.append(mp4_item)
        self.output_format_group.append(webm_item)

        output_format_submenu.append(mkv_item)
        output_format_submenu.append(mp4_item)
        output_format_submenu.append(webm_item)
        output_format_menu.set_submenu(output_format_submenu)
        menu.append(output_format_menu)

        # Initialize audio codec group
        self.audio_codec_group = []
        audio_codec_menu = Gtk.ImageMenuItem(label="Select Audio Codec")
        audio_codec_icon = Gtk.Image.new_from_icon_name("audio-x-generic", Gtk.IconSize.MENU)
        audio_codec_menu.set_image(audio_codec_icon)
        audio_codec_submenu = Gtk.Menu()

        aac_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "aac")
        mp3_item = Gtk.RadioMenuItem.new_with_label_from_widget(aac_item, "mp3")
        opus_item = Gtk.RadioMenuItem.new_with_label_from_widget(aac_item, "opus")
        aac_item.connect("activate", self.set_audio_codec, "aac")
        mp3_item.connect("activate", self.set_audio_codec, "mp3")
        opus_item.connect("activate", self.set_audio_codec, "opus")
        self.audio_codec_group.append(aac_item)
        self.audio_codec_group.append(mp3_item)
        self.audio_codec_group.append(opus_item)

        audio_codec_submenu.append(aac_item)
        audio_codec_submenu.append(mp3_item)
        audio_codec_submenu.append(opus_item)
        audio_codec_menu.set_submenu(audio_codec_submenu)
        menu.append(audio_codec_menu)

        # Initialize audio input config group
        self.audio_input_config_group = []
        audio_input_config_menu = Gtk.ImageMenuItem(label="Select Audio Input Configuration")
        audio_input_config_icon = Gtk.Image.new_from_icon_name("preferences-desktop-sound", Gtk.IconSize.MENU)
        audio_input_config_menu.set_image(audio_input_config_icon)
        audio_input_config_submenu = Gtk.Menu()

        primary_only_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "Primary Only")
        secondary_only_item = Gtk.RadioMenuItem.new_with_label_from_widget(primary_only_item, "Secondary Only")
        primary_only_item.connect("activate", self.set_audio_input_config, "Primary Only")
        secondary_only_item.connect("activate", self.set_audio_input_config, "Secondary Only")
        self.audio_input_config_group.append(primary_only_item)
        self.audio_input_config_group.append(secondary_only_item)

        audio_input_config_submenu.append(primary_only_item)
        audio_input_config_submenu.append(secondary_only_item)
        audio_input_config_menu.set_submenu(audio_input_config_submenu)
        menu.append(audio_input_config_menu)

        # Initialize primary audio input group
        self.primary_audio_input_group = []
        primary_audio_input_menu = Gtk.ImageMenuItem(label="Select Primary Audio Input")
        primary_audio_input_icon = Gtk.Image.new_from_icon_name("audio-input-microphone", Gtk.IconSize.MENU)
        primary_audio_input_menu.set_image(primary_audio_input_icon)
        primary_audio_input_submenu = Gtk.Menu()

        for input_device in self.audio_inputs:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.primary_audio_input_group else self.primary_audio_input_group[0], input_device)
            item.connect("activate", self.set_primary_audio_input, input_device)
            self.primary_audio_input_group.append(item)
            primary_audio_input_submenu.append(item)
        primary_audio_input_menu.set_submenu(primary_audio_input_submenu)
        menu.append(primary_audio_input_menu)

        # Initialize secondary audio input group
        self.secondary_audio_input_group = []
        secondary_audio_input_menu = Gtk.ImageMenuItem(label="Select Secondary Audio Input")
        secondary_audio_input_icon = Gtk.Image.new_from_icon_name("audio-input-line", Gtk.IconSize.MENU)
        secondary_audio_input_menu.set_image(secondary_audio_input_icon)
        secondary_audio_input_submenu = Gtk.Menu()

        for input_device in self.secondary_audio_inputs:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.secondary_audio_input_group else self.secondary_audio_input_group[0], input_device)
            item.connect("activate", self.set_secondary_audio_input, input_device)
            self.secondary_audio_input_group.append(item)
            secondary_audio_input_submenu.append(item)
        secondary_audio_input_menu.set_submenu(secondary_audio_input_submenu)
        menu.append(secondary_audio_input_menu)

        select_custom_region_item = Gtk.ImageMenuItem(label="Select Custom Region")
        custom_region_icon = Gtk.Image.new_from_icon_name("image-x-generic", Gtk.IconSize.MENU)
        select_custom_region_item.set_image(custom_region_icon)
        select_custom_region_item.connect("activate", self.select_custom_region)
        menu.append(select_custom_region_item)

    # Add the Journal launcher
        journal_launcher_item = Gtk.ImageMenuItem(label="Journal")
        journal_launcher_icon = Gtk.Image.new_from_icon_name("media-record", Gtk.IconSize.MENU)
        journal_launcher_item.set_image(journal_launcher_icon)
        journal_launcher_item.connect("activate", self.launch_journal)
        menu.append(journal_launcher_item)

        record_item = Gtk.ImageMenuItem(label="Record")
        record_icon = Gtk.Image.new_from_icon_name("media-record", Gtk.IconSize.MENU)
        record_item.set_image(record_icon)
        record_item.connect("activate", self.start_recording)
        menu.append(record_item)
        self.tray_record_item = record_item  # Store a reference to the tray record item

        pause_item = Gtk.ImageMenuItem(label="Pause Recording")
        pause_icon = Gtk.Image.new_from_icon_name("media-playback-pause", Gtk.IconSize.MENU)
        pause_item.set_image(pause_icon)
        pause_item.connect("activate", self.pause_recording)
        menu.append(pause_item)

        resume_item = Gtk.ImageMenuItem(label="Resume Recording")
        resume_icon = Gtk.Image.new_from_icon_name("media-playback-start", Gtk.IconSize.MENU)
        resume_item.set_image(resume_icon)
        resume_item.connect("activate", self.resume_recording)
        menu.append(resume_item)

        stop_record_item = Gtk.ImageMenuItem(label="Stop Recording")
        stop_record_icon = Gtk.Image.new_from_icon_name("media-playback-stop", Gtk.IconSize.MENU)
        stop_record_item.set_image(stop_record_icon)
        stop_record_item.connect("activate", self.stop_recording)
        menu.append(stop_record_item)

        trim_item = Gtk.ImageMenuItem(label="Trim Recent Recording")
        trim_icon = Gtk.Image.new_from_icon_name("edit-cut", Gtk.IconSize.MENU)
        trim_item.set_image(trim_icon)
        trim_item.connect("activate", self.trim_video)
        menu.append(trim_item)

        self.recent_recording_menu_item = Gtk.ImageMenuItem(label="No recent recording")
        recent_recording_icon = Gtk.Image.new_from_icon_name("document-open-recent", Gtk.IconSize.MENU)
        self.recent_recording_menu_item.set_image(recent_recording_icon)
        self.recent_recording_menu_item.connect("activate", self.open_recent_recording)
        menu.append(self.recent_recording_menu_item)

        about_item = Gtk.ImageMenuItem(label="About Us")
        about_icon = Gtk.Image.new_from_icon_name("help-about", Gtk.IconSize.MENU)
        about_item.set_image(about_icon)
        about_item.connect("activate", self.show_about_dialog)
        menu.append(about_item)

        quit_item = Gtk.ImageMenuItem(label="Quit")
        quit_icon = Gtk.Image.new_from_icon_name("application-exit", Gtk.IconSize.MENU)
        quit_item.set_image(quit_icon)
        quit_item.connect("activate", self.quit_app)
        menu.append(quit_item)

        separator = Gtk.SeparatorMenuItem()
        menu.append(separator)

        self.recording_status_menu_item = Gtk.MenuItem(label="Not Recording")
        menu.append(self.recording_status_menu_item)

        self.file_size_menu_item = Gtk.MenuItem(label="File Size: 0B")
        menu.append(self.file_size_menu_item)

        self.elapsed_time_menu_item = Gtk.MenuItem(label="Elapsed Time: 00:00:00")
        menu.append(self.elapsed_time_menu_item)

        menu.show_all()
        self.indicator.set_menu(menu)

        self.update_tray_selection()  # Initialize the tray selections

    def on_tray_enable_overlay_toggled(self, widget):
        self.enable_overlay_checkbox.set_active(widget.get_active())

    def on_tray_set_overlay_type(self, widget):
        dialog = Gtk.Dialog(title="Set Overlay Type", parent=self, flags=0)
        dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OK, Gtk.ResponseType.OK)

        combo = Gtk.ComboBoxText()
        combo.append_text("Text")
        combo.append_text("Image")
        combo.set_active(self.overlay_type_combo.get_active())
        dialog.vbox.pack_start(combo, True, True, 0)

        dialog.show_all()
        response = dialog.run()

        if response == Gtk.ResponseType.OK:
            self.overlay_type_combo.set_active(combo.get_active())

        dialog.destroy()

    def on_tray_set_overlay_content(self, widget):
        overlay_type = self.overlay_type_combo.get_active_text()
        if overlay_type == "Text":
            dialog = Gtk.Dialog(title="Set Overlay Text", parent=self, flags=0)
            dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OK, Gtk.ResponseType.OK)

            entry = Gtk.Entry()
            entry.set_text(self.overlay_text_entry.get_text())
            dialog.vbox.pack_start(entry, True, True, 0)

            dialog.show_all()
            response = dialog.run()

            if response == Gtk.ResponseType.OK:
                self.overlay_text_entry.set_text(entry.get_text())

            dialog.destroy()
        else:
            self.on_choose_image_clicked(None)




    # Add this method to the ScreenRecorder class
    def set_webcam_size(self, widget, size):
        if widget.get_active():
            self.webcam_size_percentage = size
            self.webcam_size_scale.set_value(size)
            self.update_tray_tooltip()



    def set_webcam_position(self, widget, position):
        if widget.get_active():
            self.webcam_position_combo.set_active(self.webcam_positions.index(position))
            self.update_tray_tooltip()



    def create_menu_item_with_icon(self, label, icon_name):
        item = Gtk.ImageMenuItem(label=label)
        icon = Gtk.Image.new_from_icon_name(icon_name, Gtk.IconSize.MENU)
        item.set_image(icon)
        item.set_always_show_image(True)
        return item



    def on_timer_toggled_tray(self, widget):
        self.timer_active = widget.get_active()
        self.timer_checkbox.set_active(self.timer_active)
        self.on_timer_toggled(self.timer_checkbox)

    def set_timer_hours(self, widget, hours):
        if widget.get_active():
            self.timer_hours_combo.set_active(hours)
            self.on_timer_changed(self.timer_hours_combo)

    def set_timer_minutes(self, widget, minutes):
        if widget.get_active():
            self.timer_minutes_combo.set_active(minutes)
            self.on_timer_changed(self.timer_minutes_combo)

#---------Journal Area----------------------------#

    def launch_journal(self, widget):
        logging.info("Launching Journal")
        self.status_label.set_text("Initializing Journal...")

        # Remember the initial state of the overlay
        self.overlay_was_enabled = self.enable_overlay_checkbox.get_active()

        try:
            # Ensure webcam overlay is disabled
            if self.webcam_overlay_checkbox.get_active():
                logging.info("Disabling webcam overlay for Journal mode")
                self.webcam_overlay_checkbox.set_active(False)
                self.is_webcam_overlay = False
                self.update_tray_tooltip()

            # Disable the Enable Overlay option if it's on
            if self.overlay_was_enabled:
                logging.info("Disabling overlay for Journal mode")
                self.enable_overlay_checkbox.set_active(False)
                if hasattr(self, 'tray_enable_overlay_item'):
                    self.tray_enable_overlay_item.set_active(False)
                self.update_tray_tooltip()

            # Toggle on the Journal mode checkbox
            self.journaling_mode_checkbox.set_active(True)
            self.is_journal_mode = True
            logging.info("Journal mode activated")

            # Step 1: Launch the web camera
            available_cameras = self.get_available_cameras_v4l2()
            if not available_cameras:
                raise Exception("No webcam detected")

            selected_camera = available_cameras[0]  # Select the first available camera
            selected_resolution = "640x480"
            device = f"/dev/video{self.extract_camera_index(selected_camera)}"
            command = ['ffplay', '-f', 'v4l2', '-video_size', selected_resolution, '-vf', 'hflip', device]

            self.camera_window = subprocess.Popen(command)
            time.sleep(2)  # Give more time for the camera window to open

            # Step 2: Refresh active windows to include the new camera window
            self.update_active_windows()
            active_windows = self.get_active_windows()
            logging.info(f"Updated active windows: {active_windows}")

            # Step 3: Find the active window corresponding to /dev/video0
            window_name = next((window for window in active_windows if "/dev/video0" in window), None)
            if window_name is None:
                raise Exception("Webcam window not found in active windows list")
            logging.info(f"Found webcam window: {window_name}")

            # Step 4: Set the recording area to Active Window and select the webcam window
            self.recording_area_combo.set_active(self.recording_areas.index("Active Window"))
            window_index = active_windows.index(window_name)
            self.active_window_combo.set_active(window_index)
            logging.info(f"Set recording area to Active Window and selected webcam window at index {window_index}")

            # Verify the selection
            if self.recording_area_combo.get_active_text() != "Active Window":
                raise Exception("Failed to set recording area to Active Window")
            if self.active_window_combo.get_active_text() != window_name:
                raise Exception("Failed to select the correct active window")

            # Step 5: Get window info and set the recording region
            window_info = self.get_window_info_by_name(window_name)
            if not window_info:
                raise Exception("Failed to get window info for webcam")
            self.custom_region_start_x, self.custom_region_start_y, width, height = window_info
            self.custom_region_end_x = self.custom_region_start_x + width
            self.custom_region_end_y = self.custom_region_start_y + height
            self.recording_region = (self.custom_region_start_x, self.custom_region_start_y, width, height)
            logging.info(f"Set recording region: {self.recording_region}")

            # Step 6: Set the primary audio input to the web camera
            self.refresh_audio_inputs()
            available_audio_inputs = self.audio_inputs
            logging.info(f"Available audio inputs: {available_audio_inputs}")

            # Look for any webcam-related audio input
            webcam_audio_input = next((input for input in available_audio_inputs if any(cam in input.lower() for cam in ["webcam", "camera", "video"])), None)
            if not webcam_audio_input:
                # If no webcam-specific audio input is found, use the default input
                webcam_audio_input = available_audio_inputs[0]
                logging.warning(f"No webcam-specific audio input found. Using default: {webcam_audio_input}")

            webcam_audio_index = self.audio_inputs.index(webcam_audio_input)
            self.audio_input_combo.set_active(webcam_audio_index)
            logging.info(f"Set primary audio input to: {webcam_audio_input}")

            # Verify the audio input selection
            if self.audio_input_combo.get_active_text() != webcam_audio_input:
                raise Exception(f"Failed to set the correct audio input. Expected: {webcam_audio_input}, Got: {self.audio_input_combo.get_active_text()}")
            
            # Step 7: Start recording
            self.start_recording(widget)
            if not self.is_recording:
                raise Exception("Failed to start recording")
            logging.info("Recording started successfully")

            # Step 8: Start monitoring the camera window
            threading.Thread(target=self.monitor_camera_window).start()

            self.status_label.set_text("Journal mode active. Recording in progress...")

        except Exception as e:
            logging.error(f"Error in launch_journal: {e}")
            self.status_label.set_text(f"Journal launch failed: {e}")
            if hasattr(self, 'camera_window') and self.camera_window:
                self.camera_window.terminate()
            
            # De-toggle the Journal mode
            self.journaling_mode_checkbox.set_active(False)
            self.is_journal_mode = False
            logging.info("Journal mode deactivated due to error")

            # Re-enable overlay if it was initially enabled
            if self.overlay_was_enabled:
                self.enable_overlay_checkbox.set_active(True)
                if hasattr(self, 'tray_enable_overlay_item'):
                    self.tray_enable_overlay_item.set_active(True)

        finally:
            # This block will run whether there was an exception or not
            if not self.is_journal_mode:
                logging.info("Journal mode is not active")
            else:
                logging.info("Journal mode is active")
            
            # Update UI to reflect final state
            self.update_tray_tooltip()




    def refresh_audio_inputs(self):
            self.audio_inputs = self.get_available_audio_inputs()
            self.audio_input_combo.remove_all()
            for input_device in self.audio_inputs:
                self.audio_input_combo.append_text(input_device)
            self.audio_input_combo.set_active(0)
            logging.info(f"Refreshed audio inputs: {self.audio_inputs}")

    def close_camera_preview(self):
        if hasattr(self, 'camera_preview') and self.camera_preview:
            self.camera_preview.terminate()
            self.camera_preview.wait()
            self.camera_preview = None
            logging.info("Closed camera preview")

    def check_camera_window_opened(self):
        try:
            output = subprocess.check_output(['wmctrl', '-l']).decode('utf-8')
            return any("video" in line.lower() for line in output.splitlines())
        except subprocess.CalledProcessError:
            logging.error("Failed to check for camera window using wmctrl")
            return False

    def refresh_audio_inputs(self):
        self.audio_inputs = self.get_available_audio_inputs()
        self.audio_input_combo.remove_all()
        for input_device in self.audio_inputs:
            self.audio_input_combo.append_text(input_device)
        self.audio_input_combo.set_active(0)
        logging.info(f"Refreshed audio inputs: {self.audio_inputs}")




    def monitor_camera_window(self):
        while self.camera_window.poll() is None:
            time.sleep(1)
        
        # Camera window closed
        logging.info("Camera window closed. Stopping recording and deactivating Journal mode.")
        
        # Stop the recording
        GLib.idle_add(self.stop_recording, None)
        
        # De-toggle the Journal mode
        GLib.idle_add(self.deactivate_journal_mode)
        
        # Reset recording area and audio input
        GLib.idle_add(self.reset_recording_area)
        GLib.idle_add(self.reset_audio_input)


    def deactivate_journal_mode(self):
        self.journaling_mode_checkbox.set_active(False)
        self.is_journal_mode = False
        logging.info("Journal mode deactivated")
        self.status_label.set_text("Journal mode deactivated")
        

    def reset_recording_area(self):
        GLib.idle_add(self._reset_recording_area_impl)



    def _reset_recording_area_impl(self):
        # Update the main window's recording area combo box
        self.recording_area_combo.set_active(self.recording_areas.index("Full Screen"))
        
        # Update the status label
        self.status_label.set_text("Recording area reset to Full Screen.")
        
        # Update the tray tooltip
        self.update_tray_tooltip()
        
        # Reset custom region variables
        self.custom_region_start_x = None
        self.custom_region_start_y = None
        self.custom_region_end_x = None
        self.custom_region_end_y = None
        self.recording_region = None
        
        # Update the tray menu to reflect the change
        for item in self.recording_area_group:
            if item.get_label() == "Full Screen":
                item.set_active(True)
                break
        
        # Ensure the is_custom_region flag is reset
        self.is_custom_region = False
        
        return False  # This is needed for GLib.idle_add




    def reset_audio_input(self):
        default_audio_input = "analog-stereo.4.monitor"
        logging.info(f"Attempting to reset audio input to: {default_audio_input}")
        
        # Refresh the audio inputs
        self.refresh_audio_inputs()
        
        try:
            index = self.audio_inputs.index(default_audio_input)
            self.audio_input_combo.set_active(index)
            logging.info(f"Successfully reset audio input to {default_audio_input}")
        except ValueError:
            logging.warning(f"Default audio input '{default_audio_input}' not found. Using first available input.")
            if self.audio_inputs:
                self.audio_input_combo.set_active(0)
                logging.info(f"Set audio input to: {self.audio_inputs[0]}")
            else:
                logging.error("No audio inputs available")



#--------------Journal End------------------# 

    def set_active_window(self, widget, window):
        if widget.get_active():
            self.active_window_combo.set_active(self.active_window_combo.get_model().iter_n_children() - 1)
            self.update_tray_tooltip()

    def set_output_format(self, widget, format):
        if widget.get_active():
            self.output_format_combo.set_active(["mkv", "mp4", "webm"].index(format))
            self.update_tray_tooltip()

    def set_audio_codec(self, widget, codec):
        if widget.get_active():
            self.audio_codec_combo.set_active(self.audio_codecs.index(codec))
            self.update_tray_tooltip()

    def set_audio_input_config(self, widget, config):
        if widget.get_active():
            self.audio_input_config_combo.set_active(self.audio_input_configs.index(config))
            self.update_tray_tooltip()

    def set_primary_audio_input(self, widget, input_device):
        if widget.get_active():
            self.audio_input_combo.set_active(self.audio_inputs.index(input_device))
            self.update_tray_tooltip()

    def set_secondary_audio_input(self, widget, input_device):
        if widget.get_active():
            self.secondary_audio_input_combo.set_active(self.secondary_audio_inputs.index(input_device))
            self.update_tray_tooltip()

    def update_tray_selection(self):
        recording_area_active = self.recording_area_combo.get_active_text()
        for item in self.recording_area_group:
            if item.get_label() == recording_area_active:
                item.set_active(True)

        active_window_active = self.active_window_combo.get_active_text()
        for item in self.active_window_group:
            if item.get_label() == active_window_active:
                item.set_active(True)

        output_format_active = self.output_format_combo.get_active_text()
        for item in self.output_format_group:
            if item.get_label() == output_format_active:
                item.set_active(True)

        audio_codec_active = self.audio_codec_combo.get_active_text()
        for item in self.audio_codec_group:
            if item.get_label() == audio_codec_active:
                item.set_active(True)

        audio_input_config_active = self.audio_input_config_combo.get_active_text()
        for item in self.audio_input_config_group:
            if item.get_label() == audio_input_config_active:
                item.set_active(True)

        primary_audio_input_active = self.audio_input_combo.get_active_text()
        for item in self.primary_audio_input_group:
            if item.get_label() == primary_audio_input_active:
                item.set_active(True)

        secondary_audio_input_active = self.secondary_audio_input_combo.get_active_text()
        for item in self.secondary_audio_input_group:
            if item.get_label() == secondary_audio_input_active:
                item.set_active(True)



        webcam_position_active = self.webcam_position_combo.get_active_text()
        for item in self.webcam_position_group:
            if item.get_label() == webcam_position_active:
                item.set_active(True)


    def set_recording_area(self, widget, area):
        if widget.get_active():
            self.recording_area_combo.set_active(self.recording_areas.index(area))
            self.update_tray_tooltip()

    def update_recent_recording_menu_item(self):
        if self.completed_recordings:
            self.recent_recording_menu_item.set_label(f"Play Recent Recording: {os.path.basename(self.output_filename)}")
            self.recent_recording_menu_item.set_sensitive(True)
        else:
            self.recent_recording_menu_item.set_label("No recent recording")
            self.recent_recording_menu_item.set_sensitive(False)


    def open_recent_recording(self, widget):
        if self.completed_recordings:
            most_recent_recording = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)[0][0]
            if os.path.exists(most_recent_recording):
                subprocess.run(['xdg-open', most_recent_recording])
            else:
                self.status_label.set_text("Error: Recent recording file not found.")

    def show_window(self, widget):
        self.main_window.deiconify()
        self.main_window.present()

    def show_about_dialog(self, widget):
        about_dialog = Gtk.AboutDialog()
        about_dialog.set_program_name("Seekers Eye Of The Storm Recorder")
        about_dialog.set_version("4.6_hybrid")
        about_dialog.set_comments("A powerful and easy-to-use screen recording application.")
        about_dialog.set_authors(["The Seeker", "Ben StormOS Dev", "Ricki aka YughioMaster88", "Fishman aka Pescado"])
        about_dialog.set_logo_icon_name("help-about")
        about_dialog.run()
        about_dialog.destroy()

    def quit_app(self, widget):
        try:
            self.cleanup_on_exit()
            self.cleanup_preview()
        except Exception as e:
            logging.error(f"Error during application cleanup: {e}")
        finally:
            Gtk.main_quit()



if __name__ == "__main__":
    Gst.init(None)
    app = ScreenRecorder()
    Gtk.main()
    
    # Add a timeout to force quit if the application doesn't close properly
    GLib.timeout_add_seconds(5, lambda: os._exit(0))
